import { IStorage } from "./storage";
import { Task, InsertTask } from "@shared/schema";
import { 
  addMonths, addDays, format, 
  startOfMonth, endOfMonth, 
  subDays, isAfter,
  addYears
} from "date-fns";
import { approveTask } from "./task-approval";

const DEFAULT_LEAD_DAYS = 14; // Default lead time for generating recurring tasks

/**
 * TaskScheduler is responsible for generating recurring tasks
 * based on their frequency and compliance periods
 */
export class ImprovedTaskScheduler {
  private storage: IStorage;
  private leadDaysOverride: number | null;
  
  constructor(storage: IStorage, leadDaysOverride: number | null = null) {
    this.storage = storage;
    this.leadDaysOverride = leadDaysOverride;
  }
  
  /**
   * Generate upcoming recurring tasks for all tenants
   * This should be run periodically (e.g., daily) to create tasks for upcoming periods
   */
  public async generateUpcomingRecurringTasks(): Promise<void> {
    try {
      // Get all tenants
      const tenants = await this.getAllTenants();
      
      for (const tenant of tenants) {
        await this.generateRecurringTasksForTenant(tenant.id);
      }
      
      console.log(`Recurring task generation completed for ${tenants.length} tenants`);
    } catch (error) {
      console.error("Error generating recurring tasks:", error);
    }
  }
  
  /**
   * Generate recurring tasks for a specific tenant
   */
  public async generateRecurringTasksForTenant(tenantId: number): Promise<void> {
    try {
      // Get tenant-specific settings for lead days
      const leadDaysSetting = await this.storage.getTenantSetting(
        tenantId,
        "recurring_task_lead_days"
      );
      
      // Use tenant setting, override, or default
      const leadDays = this.leadDaysOverride !== null
        ? this.leadDaysOverride
        : (leadDaysSetting?.value ? parseInt(leadDaysSetting.value, 10) : DEFAULT_LEAD_DAYS);
      
      console.log(`Using configured lead days: ${leadDays} for tenant ${tenantId}`);
      
      // Find all recurring tasks for this tenant that haven't been canceled
      const allTasks = await this.storage.getTasks(tenantId);
      const recurringTasks = allTasks.filter(task => 
        task.isRecurring && 
        !task.isCanceled && 
        !task.isAutoGenerated
      );
      
      console.log(`Found ${recurringTasks.length} recurring tasks for tenant ${tenantId}`);
      
      // Process each recurring task
      for (const task of recurringTasks) {
        await this.processRecurringTask(task, leadDays);
      }
      
      console.log(`Generated recurring tasks for tenant ${tenantId}`);
    } catch (error) {
      console.error(`Error generating recurring tasks for tenant ${tenantId}:`, error);
    }
  }
  
  /**
   * Get tasks that need approval
   */
  public async getTasksNeedingApproval(tenantId: number): Promise<Task[]> {
    try {
      const allTasks = await this.storage.getTasks(tenantId);
      
      // We want to show only auto-generated tasks that still need approval (needsApproval flag)
      // and are flagged as auto-generated - this ensures only task instances that actually need approval
      // are included in the auto-generated tasks list
      const tasksNeedingApproval = allTasks.filter(task => {
        // We must have an explicit check for both flags to be true
        const isAutoGenerated = task.isAutoGenerated === true;
        const needsApproval = task.needsApproval === true;
        
        if (isAutoGenerated && needsApproval) {
          return true;
        }
        return false;
      });
      
      console.log(`Found ${tasksNeedingApproval.length} tasks needing approval out of ${allTasks.length} total tasks`);
      return tasksNeedingApproval;
    } catch (error) {
      console.error("Error fetching tasks needing approval:", error);
      return [];
    }
  }
  
  /**
   * Get task history (previously approved auto-generated tasks)
   */
  public async getTaskHistory(tenantId: number): Promise<Task[]> {
    try {
      const allTasks = await this.storage.getTasks(tenantId);
      
      // We want to show only auto-generated tasks that have already been approved
      // but are still flagged as auto-generated
      const historicalTasks = allTasks.filter(task => {
        // Task must be explicitly flagged as auto-generated
        const isAutoGenerated = task.isAutoGenerated === true;
        
        // Task must NOT need approval anymore (it's been processed)
        const doesNotNeedApproval = task.needsApproval === false;
        
        // Task should have a parent task ID to be part of a recurring series
        const hasParentTask = task.parentTaskId !== null && task.parentTaskId !== undefined;
        
        return isAutoGenerated && doesNotNeedApproval && hasParentTask;
      });
      
      console.log(`Found ${historicalTasks.length} historical tasks out of ${allTasks.length} total tasks`);
      return historicalTasks;
    } catch (error) {
      console.error("Error fetching task history:", error);
      return [];
    }
  }
  
  /**
   * Approve a specific auto-generated task and convert it to a regular task
   * 
   * This method uses the new improved implementation from task-approval.ts
   */
  public async approveTask(taskId: number, tenantId: number): Promise<boolean> {
    return await approveTask(this.storage, taskId, tenantId);
  }
  
  /**
   * Reject a pending auto-generated task
   */
  public async rejectTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated || !task.needsApproval) {
        console.log(`Task ${taskId} not eligible for rejection (Not auto-generated or not needing approval)`);
        return false;
      }
      
      console.log(`Rejecting auto-generated task ${taskId}`);
      
      // Update the task to be canceled
      const update = {
        needsApproval: false, // No longer needs approval (it's been rejected)
        isCanceled: true,
        canceledAt: new Date(),
        updatedAt: new Date()
      };
      
      await this.storage.updateTask(taskId, update);
      return true;
    } catch (error) {
      console.error(`Error rejecting task ${taskId}:`, error);
      return false;
    }
  }
  
  /**
   * Approve all pending tasks for a tenant
   */
  public async approveAllPendingTasks(tenantId: number): Promise<number> {
    try {
      const pendingTasks = await this.getTasksNeedingApproval(tenantId);
      let approvedCount = 0;
      
      for (const task of pendingTasks) {
        const taskIdToApprove = task.id;
        console.log(`Approving task ${taskIdToApprove} as part of batch approval`);
        
        try {
          const approved = await this.approveTask(taskIdToApprove, tenantId);
          if (approved) {
            approvedCount++;
          }
        } catch (error) {
          console.error(`Error approving task ${taskIdToApprove} in batch:`, error);
        }
      }
      
      console.log(`Approved ${approvedCount} tasks out of ${pendingTasks.length} pending tasks`);
      return approvedCount;
    } catch (error) {
      console.error("Error approving all pending tasks:", error);
      return 0;
    }
  }
  
  /**
   * Set a task to active (sets activatedAt timestamp)
   */
  public async activateTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated) {
        return false;
      }
      
      // Get the "In Progress" status for this tenant
      const statuses = await this.storage.getTaskStatuses(tenantId);
      const inProgressStatus = statuses.find(status => status.name.toLowerCase().includes('progress') || status.rank === 2);
      
      if (!inProgressStatus) {
        console.error(`No suitable "In Progress" status found for tenant ${tenantId}`);
        return false;
      }
      
      // Update the task to be active
      const update = {
        activatedAt: new Date(),
        statusId: inProgressStatus.id,
        updatedAt: new Date() // Set updatedAt to track status change
      };
      
      const updated = await this.storage.updateTask(taskId, update);
      return !!updated;
    } catch (error) {
      console.error("Error activating task:", error);
      return false;
    }
  }
  
  /**
   * Cancel a task (sets isCanceled flag and canceledAt timestamp)
   */
  public async cancelTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated) {
        return false;
      }
      
      // Update the task to be canceled
      const update = {
        isCanceled: true,
        canceledAt: new Date(),
        updatedAt: new Date() // Set updatedAt to track status change
      };
      
      const updated = await this.storage.updateTask(taskId, update);
      return !!updated;
    } catch (error) {
      console.error("Error canceling task:", error);
      return false;
    }
  }
  
  /**
   * Get all tenants from the system
   */
  private async getAllTenants() {
    return await this.storage.getTenants();
  }
  
  // The following are helper methods used in the task generation process
  // These are kept as-is from the original implementation
  
  private async processRecurringTask(task: Task, leadDays: number): Promise<void> {
    try {
      if (!task.complianceFrequency || !task.complianceStartDate || !task.complianceEndDate) {
        console.log(`Task ${task.id} has no compliance frequency, start date, or end date, skipping`);
        return;
      }
      
      // Calculate next period based on frequency (monthly, quarterly, yearly, etc.)
      const { newStartDate, newEndDate } = this.calculateNextComplianceDates(
        task.complianceFrequency,
        new Date(task.complianceStartDate),
        new Date(task.complianceEndDate)
      );
      
      console.log(`Processing recurring task ${task.id}:`);
      console.log(`Current period: ${task.compliancePeriod}`);
      console.log(`Current start date: ${task.complianceStartDate}`);
      console.log(`Current end date: ${task.complianceEndDate}`);
      console.log(`Next start date: ${newStartDate}`);
      console.log(`Next end date: ${newEndDate}`);
      
      // Calculate compliance period string for the next period
      const nextCompliancePeriod = this.calculateCompliancePeriod(
        task.complianceFrequency,
        newStartDate
      );
      
      console.log(`Next compliance period: ${nextCompliancePeriod}`);
      
      // Check if task already exists for this period
      const existingTasks = await this.storage.getTasks(task.tenantId);
      const duplicateExists = existingTasks.some(existingTask => 
        existingTask.parentTaskId === task.id && 
        existingTask.compliancePeriod === nextCompliancePeriod
      );
      
      if (duplicateExists) {
        console.log(`Task already exists for period ${nextCompliancePeriod}, skipping`);
        return;
      }
      
      // Create new instance of this task with the calculated next period
      await this.createRecurringTaskInstance(task, newStartDate, newEndDate, nextCompliancePeriod);
    } catch (error) {
      console.error(`Error processing recurring task ${task.id}:`, error);
    }
  }
  
  private doesPeriodExist(task: Task, startDate: Date, endDate: Date, existingTasks: Task[]): boolean {
    const period = this.calculateCompliancePeriod(task.complianceFrequency || "", startDate);
    return existingTasks.some(existingTask => 
      existingTask.parentTaskId === task.id && 
      existingTask.compliancePeriod === period
    );
  }
  
  /**
   * Calculate the next start and end dates for a compliance period
   * based on the current dates and frequency
   */
  private calculateNextComplianceDates(
    frequency: string,
    currentStartDate: Date,
    currentEndDate: Date
  ): { newStartDate: Date, newEndDate: Date } {
    const frequencyLower = frequency.toLowerCase();
    
    // Default to the next day after current end date for start date
    let newStartDate = new Date(currentEndDate);
    newStartDate.setDate(newStartDate.getDate() + 1);
    newStartDate.setHours(0, 0, 0, 1); // Start of day with 1ms offset to ensure proper sorting
    
    let newEndDate = new Date(newStartDate);
    
    if (frequencyLower.includes('month')) {
      // Monthly: Advance to next month
      newStartDate = startOfMonth(addMonths(currentStartDate, 1));
      newEndDate = endOfMonth(newStartDate);
    } else if (frequencyLower.includes('quarter')) {
      // Quarterly: Advance by 3 months
      newStartDate = startOfMonth(addMonths(currentStartDate, 3));
      newEndDate = endOfMonth(addMonths(newStartDate, 2)); // End of the quarter (3 months)
    } else if (frequencyLower.includes('semi') || frequencyLower.includes('bi-annual')) {
      // Semi-annual: Advance by 6 months
      newStartDate = startOfMonth(addMonths(currentStartDate, 6));
      newEndDate = endOfMonth(addMonths(newStartDate, 5)); // End of the half year (6 months)
    } else if (frequencyLower.includes('annual') || frequencyLower.includes('year')) {
      let yearIncrement = 1; // Default for annual
      
      // Check for multi-year periods
      if (frequencyLower.includes('2')) {
        yearIncrement = 2;
      } else if (frequencyLower.includes('3')) {
        yearIncrement = 3;
      } else if (frequencyLower.includes('4')) {
        yearIncrement = 4;
      } else if (frequencyLower.includes('5')) {
        yearIncrement = 5;
      }
      
      // Advance by specified number of years
      newStartDate = new Date(currentStartDate);
      newStartDate.setFullYear(newStartDate.getFullYear() + yearIncrement);
      
      newEndDate = new Date(currentEndDate);
      newEndDate.setFullYear(newEndDate.getFullYear() + yearIncrement);
    }
    
    // Set time components for proper ordering and display
    // Start date gets 00:00:00.001, end date gets 23:59:59.999
    newStartDate.setHours(0, 0, 0, 1);
    newEndDate.setHours(23, 59, 59, 999);
    
    return { newStartDate, newEndDate };
  }
  
  private calculateDueDate(endDate: Date): Date {
    // Calculate a due date that is a few days before the end date
    // Default to 5 days before end of period unless it's a short period
    const daysBeforeEnd = 5;
    return subDays(endDate, daysBeforeEnd);
  }
  
  /**
   * Calculate compliance period based on frequency and start date
   */
  private calculateCompliancePeriod(frequency: string, startDate: Date): string {
    if (!frequency || !startDate) {
      return "";
    }

    const frequencyLower = frequency.toLowerCase();
    
    // Calculate compliance period based on frequency
    if (frequencyLower.includes('month')) {
      // Monthly format: "May 2025"
      return format(startDate, 'MMMM yyyy');
    } else if (frequencyLower.includes('quarter')) {
      // Quarterly format: "Q2 2025"
      const quarter = Math.floor(startDate.getMonth() / 3) + 1;
      return `Q${quarter} ${startDate.getFullYear()}`;
    } else if (frequencyLower.includes('annual') || frequencyLower.includes('year')) {
      if (frequencyLower.includes('5')) {
        // 5-year format: "2025-2029"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 4}`;
      } else if (frequencyLower.includes('4')) {
        // 4-year format: "2025-2028"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 3}`;
      } else if (frequencyLower.includes('3')) {
        // 3-year format: "2025-2027"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 2}`;
      } else if (frequencyLower.includes('2')) {
        // 2-year format: "2025-2026"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 1}`;
      } else {
        // Standard annual: "2025"
        return `${startDate.getFullYear()}`;
      }
    } else if (frequencyLower.includes('semi') || frequencyLower.includes('bi-annual')) {
      // Semi-annual format: "H1 2025" or "H2 2025"
      const half = startDate.getMonth() < 6 ? 1 : 2;
      return `H${half} ${startDate.getFullYear()}`;
    } else if (frequencyLower.includes('one time') || frequencyLower.includes('once')) {
      // One-time format: "May 2025 (One-time)"
      return `${format(startDate, 'MMMM yyyy')} (One-time)`;
    } else {
      // Default format for unknown frequencies
      return format(startDate, 'MMMM yyyy');
    }
  }
  
  private async createRecurringTaskInstance(
    templateTask: Task, 
    startDate: Date, 
    endDate: Date,
    compliancePeriod: string
  ): Promise<void> {
    try {
      // Find "New" status 
      const statuses = await this.storage.getTaskStatuses(templateTask.tenantId);
      const newStatus = statuses.find(status => status.name.toLowerCase() === 'new' || status.rank === 1);
      
      if (!newStatus) {
        console.error(`No "New" status found for tenant ${templateTask.tenantId}`);
        return;
      }
      
      // Calculate due date (few days before end of period)
      const dueDate = this.calculateDueDate(endDate);
      
      // Get the year from the start date for the compliance year
      const complianceYear = format(startDate, 'yyyy');
      
      console.log(`Creating task with data: ${JSON.stringify({
        tenantId: templateTask.tenantId,
        isAdmin: templateTask.isAdmin,
        taskType: templateTask.taskType,
        clientId: templateTask.clientId,
        entityId: templateTask.entityId,
        serviceTypeId: templateTask.serviceTypeId,
        taskCategoryId: templateTask.taskCategoryId,
        assigneeId: templateTask.assigneeId,
        dueDate,
        statusId: newStatus.id,
        taskDetails: templateTask.taskDetails,
        nextToDo: templateTask.nextToDo || '',
        isRecurring: false,
        complianceFrequency: templateTask.complianceFrequency,
        complianceYear,
        complianceDuration: templateTask.complianceDuration,
        complianceStartDate: startDate,
        complianceEndDate: endDate,
        compliancePeriod,
        currency: templateTask.currency,
        serviceRate: templateTask.serviceRate,
        parentTaskId: templateTask.id,
        isAutoGenerated: true,
        needsApproval: true
      }, null, 2)}`);
      
      // Create new task from template
      const newTaskData: InsertTask = {
        tenantId: templateTask.tenantId,
        isAdmin: templateTask.isAdmin,
        taskType: templateTask.taskType,
        clientId: templateTask.clientId,
        entityId: templateTask.entityId,
        serviceTypeId: templateTask.serviceTypeId,
        taskCategoryId: templateTask.taskCategoryId,
        assigneeId: templateTask.assigneeId,
        dueDate,
        statusId: newStatus.id,
        taskDetails: templateTask.taskDetails,
        nextToDo: templateTask.nextToDo || '',
        isRecurring: false,
        complianceFrequency: templateTask.complianceFrequency,
        complianceYear,
        complianceDuration: templateTask.complianceDuration,
        complianceStartDate: startDate,
        complianceEndDate: endDate,
        compliancePeriod,
        currency: templateTask.currency,
        serviceRate: templateTask.serviceRate,
        parentTaskId: templateTask.id,
        isAutoGenerated: true,
        needsApproval: true
      };
      
      console.log(`Inserting task with filtered fields: ${JSON.stringify(newTaskData, null, 2)}`);
      await this.storage.createTask(newTaskData);
      console.log(`Created new task for period ${compliancePeriod}`);
    } catch (error) {
      console.error(`Error creating recurring task instance:`, error);
    }
  }
}