import { IStorage } from "./storage";
import { Task, InsertTask } from "@shared/schema";
import { 
  addMonths, addDays, format, 
  startOfMonth, endOfMonth, 
  startOfQuarter, endOfQuarter, 
  subDays, isBefore, isAfter,
  differenceInMonths, differenceInQuarters,
  addQuarters, differenceInYears, addYears,
  isEqual, differenceInWeeks, addWeeks
} from "date-fns";

const DEFAULT_LEAD_DAYS = 14; // Default lead time for generating recurring tasks

/**
 * TaskScheduler is responsible for generating recurring tasks
 * based on their frequency and compliance periods
 */
export class TaskScheduler {
  private storage: IStorage;
  private leadDaysOverride: number | null;
  
  constructor(storage: IStorage, leadDaysOverride: number | null = null) {
    this.storage = storage;
    this.leadDaysOverride = leadDaysOverride;
  }
  
  /**
   * Generate upcoming recurring tasks for all tenants
   * This should be run periodically (e.g., daily) to create tasks for upcoming periods
   */
  public async generateUpcomingRecurringTasks(): Promise<void> {
    try {
      // Get all tenants
      const tenants = Array.from(await this.getAllTenants());
      
      for (const tenant of tenants) {
        await this.generateRecurringTasksForTenant(tenant.id);
      }
      
      console.log(`Recurring task generation completed for ${tenants.length} tenants`);
    } catch (error) {
      console.error("Error generating recurring tasks:", error);
    }
  }
  
  /**
   * Generate recurring tasks for a specific tenant
   */
  public async generateRecurringTasksForTenant(tenantId: number): Promise<void> {
    try {
      // If we have a lead days override (for manual generation), use that value
      // Otherwise get the auto generate days setting or use default
      let leadDays: number;
      
      if (this.leadDaysOverride !== null) {
        // Use the override (typically 0 for manual generation to force immediate creation)
        leadDays = this.leadDaysOverride;
        console.log(`Using override lead days: ${leadDays} for tenant ${tenantId}`);
      } else {
        // Get setting from database
        const autoGenerateSetting = await this.storage.getTenantSetting(tenantId, "auto_generate_task_days");
        leadDays = autoGenerateSetting ? parseInt(autoGenerateSetting.value) : DEFAULT_LEAD_DAYS;
        console.log(`Using configured lead days: ${leadDays} for tenant ${tenantId}`);
      }
      
      // Get all recurring tasks for this tenant
      const allTasks = await this.storage.getTasks(tenantId);
      const recurringTasks = allTasks.filter(task => task.isRecurring);
      
      if (recurringTasks.length === 0) {
        console.log(`No recurring tasks found for tenant ${tenantId}`);
      } else {
        console.log(`Found ${recurringTasks.length} recurring tasks for tenant ${tenantId}`);
      }
      
      // Process existing tasks to generate periods up to current month
      for (const task of recurringTasks) {
        try {
          // Process regular recurring tasks (for past to current periods)
          await this.processRecurringTask(task, leadDays);
        } catch (error) {
          console.error(`Error processing recurring task ${task.id}:`, error);
          // Continue with next task instead of stopping the entire process
        }
      }
      
      // We no longer generate future tasks here
      // All tasks will be generated strictly up to the current month
      // Users will need to explicitly approve tasks to generate the next month
      
      console.log(`Generated recurring tasks for tenant ${tenantId}`);
    } catch (error) {
      console.error(`Error generating recurring tasks for tenant ${tenantId}:`, error);
    }
  }
  
  /**
   * Process a single recurring task and create new instances if needed
   */
  private async processRecurringTask(task: Task, leadDays: number): Promise<void> {
    // Skip processing if task doesn't have compliance frequency
    if (!task.complianceFrequency) {
      console.log(`Skipping task ${task.id} - Missing frequency. Frequency: ${task.complianceFrequency}, Duration: ${task.complianceDuration}`);
      return;
    }
    
    // Skip one-time tasks - they don't need recurring generation
    if (task.complianceFrequency.toLowerCase() === 'one time' || 
        task.complianceFrequency.toLowerCase() === 'once') {
      console.log(`Skipping one-time task ${task.id} - Not eligible for recurring generation`);
      return;
    }
    
    // Skip auto-generated tasks (they should not generate further tasks)
    if (task.isAutoGenerated) {
      console.log(`Skipping auto-generated task ${task.id} - Auto-generated tasks don't spawn new tasks`);
      return;
    }
    
    // Initialize duration to empty string if not provided
    const duration = task.complianceDuration || '';
    
    console.log(`Processing recurring task ${task.id}: ${task.taskDetails || 'No details'}. Frequency: ${task.complianceFrequency}, Start: ${task.complianceStartDate}, End: ${task.complianceEndDate}`);
    
    // Get the existing tasks for this tenant/client/entity to check for existing periods
    const existingTasks = await this.storage.getTasks(
      task.tenantId,
      task.clientId || undefined,
      task.entityId || undefined,
      task.isAdmin
    );
    
    // Get original period - require compliance dates
    if (!task.complianceStartDate || !task.complianceEndDate) {
      console.log(`Skipping task ${task.id} - Missing compliance dates`);
      return;
    }
    
    // Determine the starting reference date (end of original compliance period)
    const originalEndDate = new Date(task.complianceEndDate);
    let referenceDate = originalEndDate;
    
    // Get current date as the upper limit (for future tasks, we'll check lead time)
    const now = new Date();
    
    // Collection to store all periods that need to be generated
    let periodsToGenerate: { startDate: Date, endDate: Date, dueDate: Date }[] = [];
    
    // Track the current period start date
    let currentPeriodStart = referenceDate;
    
    // Generate sequence of periods from original to current month
    console.log(`Generating periods from ${format(originalEndDate, 'yyyy-MM')} to current month ${format(now, 'yyyy-MM')}`);
    
    // Limit to 24 iterations to prevent infinite loops
    for (let i = 0; i < 24; i++) {
      // Calculate the next period after the reference date
      const nextPeriod = this.calculateNextCompliancePeriod(
        task.complianceFrequency,
        duration,
        currentPeriodStart
      );
      
      if (!nextPeriod) {
        console.log(`Could not calculate period after ${currentPeriodStart.toISOString()} for task ${task.id}`);
        break;
      }
      
      const { startDate, endDate } = nextPeriod;
      
      // Ensure start date is first day of month at 00:00:00
      const firstDayOfMonth = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
      firstDayOfMonth.setHours(0, 0, 0, 0);
      
      // Ensure end date is last day of month at 23:59:59
      const lastDayOfMonth = new Date(endDate.getFullYear(), endDate.getMonth() + 1, 0);
      lastDayOfMonth.setHours(23, 59, 59, 999);
      
      // Calculate due date (usually a few days before end date)
      const dueDate = this.calculateDueDate(lastDayOfMonth);
      
      // Compare month/year of this period with current month/year
      const periodMonthYear = format(firstDayOfMonth, 'yyyy-MM');
      const nowMonthYear = format(now, 'yyyy-MM');
      
      // Only generate tasks up to the current month, not future months
      // Future months will be generated based on lead time
      if (isAfter(firstDayOfMonth, now)) {
        console.log(`Stopping at period ${periodMonthYear} as it's beyond current month`);
        break;
      }
      
      // Check if this period already exists
      const periodExists = this.doesPeriodExist(task, firstDayOfMonth, lastDayOfMonth, existingTasks);
      
      if (!periodExists) {
        // Only add to generation queue if period doesn't already exist
        periodsToGenerate.push({ 
          startDate: firstDayOfMonth, 
          endDate: lastDayOfMonth, 
          dueDate 
        });
      }
      
      // Move to the next period
      currentPeriodStart = lastDayOfMonth;
    }
    
    console.log(`Found ${periodsToGenerate.length} periods to generate for task ${task.id}`);
    
    // Generate tasks for all missing periods
    for (const period of periodsToGenerate) {
      const { startDate, endDate, dueDate } = period;
      
      // For manual generation (leadDays = 0), always generate all periods
      if (leadDays === 0) {
        console.log(`Generating task for period ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')} (manual mode)`);
        await this.createRecurringTaskInstance(task, startDate, endDate, dueDate);
        continue;
      }
      
      // All periods are in the past or current month at this point
      // (future periods were filtered out earlier)
      console.log(`Generating task for period ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      await this.createRecurringTaskInstance(task, startDate, endDate, dueDate);
    }
  }
  
  /**
   * Check if a task already exists for a specific compliance period
   */
  private doesPeriodExist(task: Task, startDate: Date, endDate: Date, existingTasks: Task[]): boolean {
    // Convert dates to month/year format for easier comparison (e.g., "2025-05")
    const periodMonthYear = format(startDate, 'yyyy-MM');
    
    return existingTasks.some(existingTask => {
      // Skip tasks without compliance dates
      if (!existingTask.complianceStartDate || !existingTask.complianceEndDate) {
        return false;
      }
      
      const existingStartDate = new Date(existingTask.complianceStartDate);
      const existingPeriodMonthYear = format(existingStartDate, 'yyyy-MM');
      
      // Match by month/year rather than exact date
      // This ensures we don't generate multiple tasks for the same month
      const periodMatch = existingPeriodMonthYear === periodMonthYear;
      
      if (!periodMatch) {
        return false;
      }
      
      // Check that other critical fields match
      const basicFieldsMatch = 
        existingTask.clientId === task.clientId &&
        existingTask.entityId === task.entityId &&
        existingTask.serviceTypeId === task.serviceTypeId &&
        existingTask.taskCategoryId === task.taskCategoryId;
      
      if (!basicFieldsMatch) {
        return false;
      }
      
      // Consider a period to exist if:
      const statusMatch = (
        // It's an auto-generated task waiting for approval
        (existingTask.isAutoGenerated && existingTask.needsApproval) ||
        // Or it's an approved auto-generated task (in history)
        (existingTask.isAutoGenerated && !existingTask.needsApproval) ||
        // Or it's a regular task for this period with a parent task ID
        (!existingTask.isAutoGenerated && existingTask.parentTaskId !== null) ||
        // Or it's a regular task with the same compliance period (even without parent task)
        (!existingTask.isAutoGenerated && existingTask.complianceFrequency === task.complianceFrequency)
      );
      
      if (statusMatch) {
        console.log(`Task already exists for period ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')} - Task ID: ${existingTask.id}`);
      }
      
      return statusMatch;
    });
  }
  
  /**
   * Create a new instance of a recurring task for a specific period
   */
  private async createRecurringTaskInstance(
    templateTask: Task, 
    startDate: Date, 
    endDate: Date,
    dueDate: Date
  ): Promise<void> {
    try {
      // Ensure the dates are properly formatted with consistent time components
      // Start date: First day of month at 00:00:00
      const complianceStartDate = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
      complianceStartDate.setHours(0, 0, 0, 0);
      
      // End date: Last day of month at 23:59:59.999
      const complianceEndDate = new Date(endDate.getFullYear(), endDate.getMonth() + 1, 0);
      complianceEndDate.setHours(23, 59, 59, 999);
      
      // Format as month/year for logging and validation
      const periodMonthYear = format(complianceStartDate, 'yyyy-MM');
      
      // First, check if a task already exists for this exact month/year to avoid duplication
      const existingTasks = await this.storage.getTasks(
        templateTask.tenantId,
        templateTask.clientId || undefined,
        templateTask.entityId || undefined
      );
      
      // Only check auto-generated tasks that match the exact month/year
      const duplicateExists = existingTasks.some(task => {
        if (!task.isAutoGenerated || !task.complianceStartDate) {
          return false;
        }
        
        const taskMonthYear = format(new Date(task.complianceStartDate), 'yyyy-MM');
        return taskMonthYear === periodMonthYear && 
               task.parentTaskId === templateTask.id &&
               task.serviceTypeId === templateTask.serviceTypeId;
      });
      
      if (duplicateExists) {
        console.log(`Skipping creation - Task already exists for period ${periodMonthYear}`);
        return;
      }
      
      // Get the "New" status (rank 1) for this tenant
      const statuses = await this.storage.getTaskStatuses(templateTask.tenantId);
      const newStatus = statuses.find(status => status.rank === 1);
      
      if (!newStatus) {
        console.error(`No "New" status (rank 1) found for tenant ${templateTask.tenantId}`);
        return;
      }
      
      // Check if auto-approval setting is enabled
      const autoApproveTasksSetting = await this.storage.getTenantSetting(
        templateTask.tenantId, 
        "auto_approve_recurring_tasks"
      );
      
      const needsApproval = !autoApproveTasksSetting || 
                            autoApproveTasksSetting.value.toLowerCase() !== "true";
      
      // Set a descriptive task name based on the compliance period
      let taskDetails = templateTask.taskDetails || '';
      
      // If no task details exist, generate a default description
      if (!taskDetails) {
        const serviceName = templateTask.serviceTypeId 
          ? (await this.getServiceName(templateTask.tenantId, templateTask.serviceTypeId)) || 'Service'
          : 'Task';
        
        taskDetails = `${serviceName} - ${templateTask.complianceFrequency} compliance for period ${format(complianceStartDate, 'MMM yyyy')}`;
      }
      
      // Determine if this is a one-time task
      const isOneTime = templateTask.complianceFrequency?.toLowerCase() === 'one time' || 
                       templateTask.complianceFrequency?.toLowerCase() === 'once';
      
      // Prepare the new task data
      const newTaskData: InsertTask = {
        tenantId: templateTask.tenantId,
        isAdmin: templateTask.isAdmin,
        taskType: templateTask.taskType,
        clientId: templateTask.clientId || undefined,
        entityId: templateTask.entityId || undefined,
        serviceTypeId: templateTask.serviceTypeId || undefined,
        taskCategoryId: templateTask.taskCategoryId || undefined,
        assigneeId: templateTask.assigneeId,
        dueDate: dueDate,
        statusId: newStatus.id,
        taskDetails: taskDetails,
        nextToDo: templateTask.nextToDo,
        isRecurring: false, // Auto-generated tasks are never recurring themselves
        complianceFrequency: templateTask.complianceFrequency,
        complianceYear: format(complianceStartDate, 'yyyy'),
        complianceDuration: templateTask.complianceDuration,
        complianceStartDate: complianceStartDate,
        complianceEndDate: complianceEndDate,
        currency: templateTask.currency,
        serviceRate: templateTask.serviceRate,
        // New tracking fields
        isAutoGenerated: true,
        parentTaskId: templateTask.id,
        needsApproval: needsApproval,
        updatedAt: new Date(), // Track when the auto-generated task was created
      };
      
      // Create the new task
      await this.storage.createTask(newTaskData);
      console.log(`Created recurring task instance for period ${format(complianceStartDate, 'yyyy-MM-dd')} to ${format(complianceEndDate, 'yyyy-MM-dd')} ${needsApproval ? '(needs approval)' : '(auto-approved)'}`);
    } catch (error) {
      console.error("Error creating recurring task instance:", error);
    }
  }
  
  /**
   * Retrieve service name for better task descriptions
   */
  private async getServiceName(tenantId: number, serviceTypeId: number): Promise<string | undefined> {
    try {
      const service = await this.storage.getServiceType(serviceTypeId, tenantId);
      return service?.name;
    } catch (error) {
      console.error("Error fetching service name:", error);
      return undefined;
    }
  }
  
  /**
   * Get all tasks that need approval (generated tasks marked as needing approval)
   */
  public async getTasksNeedingApproval(tenantId: number): Promise<Task[]> {
    try {
      const allTasks = await this.storage.getTasks(tenantId);
      return allTasks.filter(task => task.isAutoGenerated && task.needsApproval);
    } catch (error) {
      console.error("Error fetching tasks needing approval:", error);
      return [];
    }
  }
  
  /**
   * Get task history (previously approved auto-generated tasks)
   */
  public async getTaskHistory(tenantId: number): Promise<Task[]> {
    try {
      const allTasks = await this.storage.getTasks(tenantId);
      return allTasks.filter(task => 
        task.isAutoGenerated && 
        !task.needsApproval && 
        task.parentTaskId !== null
      );
    } catch (error) {
      console.error("Error fetching task history:", error);
      return [];
    }
  }
  
  /**
   * Approve a generated task (remove approval flag)
   * When approved, creates a regular task in the Tasks module
   * and marks the original parent task as non-recurring
   */
  public async approveTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      console.log(`*** NEW APPROVAL LOGIC: Attempting to approve task ${taskId} for tenant ${tenantId} ***`);

      // 1. Fetch the Approved Auto-Generated Task
      const approvedTask = await this.storage.getTask(taskId, tenantId); // Ensure getTask returns full Task object

      if (!approvedTask) {
        console.error(`Task ${taskId} not found for tenant ${tenantId}`);
        return false;
      }

      if (!approvedTask.isAutoGenerated || !approvedTask.needsApproval) {
        console.warn(`Task ${taskId} is not an auto-generated task needing approval. isAutoGenerated: ${approvedTask.isAutoGenerated}, needsApproval: ${approvedTask.needsApproval}`);
        return false;
      }

      // Ensure parentTaskId exists on the approvedTask object from storage.getTask
      if (approvedTask.parentTaskId === null || approvedTask.parentTaskId === undefined) { 
        console.error(`Task ${taskId} is auto-generated but has no parentTaskId. Cannot proceed with 'baton pass'.`);
        return false;
      }

      // 2. Fetch its Original Parent Task
      const originalParentTask = await this.storage.getTask(approvedTask.parentTaskId, tenantId);

      if (!originalParentTask) {
        console.error(`Original parent task ${approvedTask.parentTaskId} not found for approved task ${taskId}.`);
        return false; 
      }

      // 3. Prepare Updates for the Approved Task (to make IT the new recurring master)
      const approvedTaskUpdates: Partial<Task> = { // Ensure Task type is imported if not globally available
        isRecurring: true,
        isAutoGenerated: false,
        needsApproval: false,
        // statusId: ID_OF_ACTIVE_STATUS, // Optional: Consider adding status update logic if needed
        updatedAt: new Date(),
      };

      // 4. Perform the Update on the Approved Task (IN PLACE)
      console.log(`Updating approved task ${approvedTask.id} with:`, JSON.stringify(approvedTaskUpdates));
      const approvedTaskUpdated = await this.storage.updateTask(approvedTask.id, approvedTaskUpdates);
      if (!approvedTaskUpdated) {
        console.error(`Failed to update approved task ${approvedTask.id}.`);
        return false;
      }
      console.log(`Approved task ${approvedTask.id} successfully updated.`);

      // 5. Prepare Updates for the Original Parent Task
      const parentTaskUpdates: Partial<Task> = { // Ensure Task type is imported
        isRecurring: false,
        // statusId: ID_OF_SUPERSEDED_STATUS, // Optional: Consider adding status update logic
        updatedAt: new Date(),
      };

      // 6. Perform the Update on the Original Parent Task (IN PLACE)
      console.log(`Updating original parent task ${originalParentTask.id} with:`, JSON.stringify(parentTaskUpdates));
      const parentTaskUpdated = await this.storage.updateTask(originalParentTask.id, parentTaskUpdates);
      if (!parentTaskUpdated) {
        // Log an error but consider if this should be a fatal error for the approval
        console.error(`Failed to update original parent task ${originalParentTask.id} to set isRecurring=false.`);
      } else {
        console.log(`Original parent task ${originalParentTask.id} successfully updated.`);
      }

      console.log(`Task ${taskId} approved successfully with 'baton pass' logic.`);
      return true;

    } catch (error) {
      console.error(`Error in approveTask for task ${taskId}:`, error);
      return false;
    }
  }
  
  /**
   * Approve all pending tasks for a tenant
   */
  public async approveAllPendingTasks(tenantId: number): Promise<number> {
    try {
      const pendingTasks = await this.getTasksNeedingApproval(tenantId);
      let approvedCount = 0;
      
      for (const task of pendingTasks) {
        const success = await this.approveTask(task.id, tenantId);
        if (success) approvedCount++;
      }
      
      return approvedCount;
    } catch (error) {
      console.error("Error approving all pending tasks:", error);
      return 0;
    }
  }
  
  /**
   * Reject a generated task (delete it)
   */
  public async rejectTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated || !task.needsApproval) {
        return false;
      }
      
      // Delete the task
      return await this.storage.deleteTask(taskId, tenantId);
    } catch (error) {
      console.error("Error rejecting task:", error);
      return false;
    }
  }
  
  /**
   * Set a task to active (sets activatedAt timestamp)
   */
  public async activateTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated) {
        return false;
      }
      
      // Get the "In Progress" status for this tenant (typically rank 2 or 3)
      const statuses = await this.storage.getTaskStatuses(tenantId);
      const inProgressStatus = statuses.find(status => status.name.toLowerCase().includes('progress') || status.rank === 2);
      
      if (!inProgressStatus) {
        console.error(`No suitable "In Progress" status found for tenant ${tenantId}`);
        return false;
      }
      
      // Update the task to be active and change its status
      const update = {
        isCanceled: false,
        activatedAt: new Date(),
        // Use undefined instead of null for Date field to avoid type errors
        canceledAt: undefined,
        statusId: inProgressStatus.id,
        updatedAt: new Date() // Set updatedAt to track status change
      };
      
      const updated = await this.storage.updateTask(taskId, update);
      return !!updated;
    } catch (error) {
      console.error("Error activating task:", error);
      return false;
    }
  }
  
  /**
   * Cancel a task (sets isCanceled flag and canceledAt timestamp)
   */
  public async cancelTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated) {
        return false;
      }
      
      // Get the "Canceled" status for this tenant
      const statuses = await this.storage.getTaskStatuses(tenantId);
      const canceledStatus = statuses.find(status => 
        status.name.toLowerCase().includes('cancel') || 
        status.name.toLowerCase().includes('archived')
      );
      
      if (!canceledStatus) {
        console.error(`No "Canceled" status found for tenant ${tenantId}`);
        return false;
      }
      
      // Update the task to be canceled and change its status
      const update = {
        isCanceled: true,
        canceledAt: new Date(),
        statusId: canceledStatus.id,
        updatedAt: new Date() // Set updatedAt to track status change
      };
      
      const updated = await this.storage.updateTask(taskId, update);
      return !!updated;
    } catch (error) {
      console.error("Error canceling task:", error);
      return false;
    }
  }
  
  /**
   * Resume a previously canceled task
   */
  public async resumeTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated || !task.isCanceled) {
        return false;
      }
      
      // Get the "In Progress" status for this tenant
      const statuses = await this.storage.getTaskStatuses(tenantId);
      const inProgressStatus = statuses.find(status => status.name.toLowerCase().includes('progress') || status.rank === 2);
      
      if (!inProgressStatus) {
        console.error(`No suitable "In Progress" status found for tenant ${tenantId}`);
        return false;
      }
      
      // Update the task to be no longer canceled and change its status
      const update = {
        isCanceled: false,
        canceledAt: undefined, // Use undefined instead of null for Date field
        activatedAt: new Date(),
        statusId: inProgressStatus.id,
        updatedAt: new Date() // Set updatedAt to track status change
      };
      
      const updated = await this.storage.updateTask(taskId, update);
      return !!updated;
    } catch (error) {
      console.error("Error resuming task:", error);
      return false;
    }
  }
  
  /**
   * Permanently delete a task
   */
  public async deleteTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated) {
        return false;
      }
      
      // Delete the task
      return await this.storage.deleteTask(taskId, tenantId);
    } catch (error) {
      console.error("Error deleting task:", error);
      return false;
    }
  }
  
  /**
   * Calculate the next compliance period based on frequency and duration
   */
  private calculateNextCompliancePeriod(
    frequency: string, 
    duration: string,
    referenceDate: Date
  ): { startDate: Date; endDate: Date } | null {
    try {
      // Common reference values used across multiple cases
      const refYear = referenceDate.getFullYear();
      const refMonth = referenceDate.getMonth();
      
      console.log(`Calculating next period for frequency: ${frequency}, duration: ${duration}, reference date: ${referenceDate.toISOString()}`);
      
      let startDate: Date, endDate: Date;
      
      switch (frequency.toLowerCase()) {
        case 'daily':
          // For daily, the next period is tomorrow
          const nextDay = addDays(referenceDate, 1);
          startDate = new Date(nextDay.setHours(0, 0, 0, 0));
          // End date is the same day at 23:59:59.999
          endDate = new Date(startDate);
          endDate.setHours(23, 59, 59, 999);
          break;
          
        case 'weekly':
          // For weekly, the next period is the next 7 days
          const tomorrow = addDays(referenceDate, 1);
          startDate = new Date(tomorrow.setHours(0, 0, 0, 0));
          // End date is the 6th day after start (7 days total) at 23:59:59.999
          endDate = new Date(startDate);
          endDate.setDate(endDate.getDate() + 6);
          endDate.setHours(23, 59, 59, 999);
          break;
          
        case 'biweekly':
          // For biweekly, the next period is the next 14 days
          const dayAfterTomorrow = addDays(referenceDate, 1);
          startDate = new Date(dayAfterTomorrow.setHours(0, 0, 0, 0));
          // End date is the 13th day after start (14 days total) at 23:59:59.999
          endDate = new Date(startDate);
          endDate.setDate(endDate.getDate() + 13);
          endDate.setHours(23, 59, 59, 999);
          break;
          
        case 'monthly':
          // For monthly, always calculate the NEXT month after the reference date
          // This ensures we're always advancing forward in time and not stuck on the current month
          
          // Always calculate the next month after the reference date
          const nextMonthIdx = (refMonth + 1) % 12; // 0-11 for Jan-Dec
          const nextMonthYear = nextMonthIdx === 0 ? refYear + 1 : refYear; // Increment year if month rolls over
          
          // First day of next month
          startDate = new Date(nextMonthYear, nextMonthIdx, 1);
          startDate.setHours(0, 0, 0, 0);
          
          // Last day of next month
          endDate = new Date(nextMonthYear, nextMonthIdx + 1, 0);
          endDate.setHours(23, 59, 59, 999);
          
          console.log(`Monthly task - Next month is: ${startDate.toDateString()} to ${endDate.toDateString()}`);
          break;
          
        case 'quarterly':
          // For quarterly, always move to the next quarter after the reference date
          const refQuarter = Math.floor(refMonth / 3); // 0-3 for Q1-Q4
          
          // Calculate next quarter (0-3) and year
          const nextQuarter = (refQuarter + 1) % 4;
          const nextQuarterYear = refQuarter === 3 ? refYear + 1 : refYear; // Increment year if moving from Q4 to Q1
          
          // First month of next quarter (0, 3, 6, or 9)
          const nextQuarterStartMonth = nextQuarter * 3; 
          
          // First day of next quarter at 00:00:00
          startDate = new Date(nextQuarterYear, nextQuarterStartMonth, 1);
          startDate.setHours(0, 0, 0, 0);
          
          // Last day of next quarter at 23:59:59.999
          // Add 3 months to the start date, then go back 1 day
          endDate = new Date(nextQuarterYear, nextQuarterStartMonth + 3, 0);
          endDate.setHours(23, 59, 59, 999);
          break;
          
        case 'semi-annual':
        case 'biannual':
          // For semi-annual, move to the next 6-month period after the reference date
          // Split the year into 2 periods: Jan-Jun and Jul-Dec
          
          // Determine which half of the year the reference date falls in
          const refHalf = refMonth < 6 ? 0 : 1; // 0 = Jan-Jun, 1 = Jul-Dec
          
          // Calculate next half and year
          const nextHalf = (refHalf + 1) % 2; // Toggle between 0 and 1
          // If we're moving from second half to first half, increment the year
          const nextHalfYear = nextHalf === 0 ? refYear + 1 : refYear;
          
          // Start month is either January (0) or July (6)
          const nextHalfStartMonth = nextHalf * 6;
          
          // First day of next 6-month period
          startDate = new Date(nextHalfYear, nextHalfStartMonth, 1);
          startDate.setHours(0, 0, 0, 0);
          
          // Last day of the 6-month period (June 30 or December 31)
          endDate = new Date(nextHalfYear, nextHalfStartMonth + 6, 0);
          endDate.setHours(23, 59, 59, 999);
          
          console.log(`Semi-annual task - Next period: ${startDate.toDateString()} to ${endDate.toDateString()}`);
          break;
          
        case 'yearly':
        case 'annual':
          // For yearly compliance, handle special cases based on the duration
          if (duration.toLowerCase() === 'fy' || duration.toLowerCase() === 'fiscal year') {
            // Fiscal year - assuming fiscal year starts in July
            // This can be customized based on the country or organization's fiscal year
            const currentFY = refMonth >= 6 ? refYear : refYear - 1;
            const nextFY = currentFY + 1;
            
            // July 1st of next fiscal year
            startDate = new Date(nextFY, 6, 1);
            startDate.setHours(0, 0, 0, 0);
            
            // June 30th of year after next fiscal year at 23:59:59.999
            endDate = new Date(nextFY + 1, 6, 0);
            endDate.setHours(23, 59, 59, 999);
          } else {
            // Calendar year (default)
            // January 1st of next year
            startDate = new Date(refYear + 1, 0, 1);
            startDate.setHours(0, 0, 0, 0);
            
            // December 31st of next year at 23:59:59.999
            endDate = new Date(refYear + 1, 11, 31);
            endDate.setHours(23, 59, 59, 999);
          }
          break;
          
        default:
          console.warn(`Unsupported frequency: ${frequency}`);
          return null;
      }
      
      return { startDate, endDate };
    } catch (error) {
      console.error("Error calculating next compliance period:", error);
      return null;
    }
  }
  
  /**
   * Calculate due date (typically end of period or slightly before)
   */
  private calculateDueDate(endDate: Date): Date {
    // Due date is typically a few days before the end of the period
    // This can be customized based on business rules
    return subDays(endDate, 5);
  }
  
  /**
   * Helper to get all tenants from storage
   */
  private async getAllTenants(): Promise<Tenant[]> {
    // This is a simplification - in a real implementation,
    // we would need a method to retrieve all tenants
    const result: Tenant[] = [];
    
    // Start with tenant ID 1 and try incrementing
    // This is a workaround since our storage interface doesn't
    // provide a way to get all tenants
    for (let i = 1; i <= 100; i++) {
      const tenant = await this.storage.getTenant(i);
      if (tenant) {
        result.push(tenant);
      }
    }
    
    return result;
  }
}

// Helper type for Tenant since we're using it internally
interface Tenant {
  id: number;
  name: string;
  createdAt: Date;
}