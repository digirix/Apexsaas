import { IStorage } from "./storage";
import { Task, InsertTask } from "../shared/schema";
import { format, addMonths, startOfMonth, endOfMonth } from "date-fns";

/**
 * Class that handles task scheduling and approval using a single-table approach
 */
export class TaskScheduler {
  private storage: IStorage;
  
  constructor(storage: IStorage) {
    this.storage = storage;
  }
  
  /**
   * Generate upcoming recurring tasks for all tenants (called periodically)
   * This is the main entry point for the task generation process
   */
  public async generateUpcomingRecurringTasks(): Promise<void> {
    try {
      console.log("Starting to generate upcoming recurring tasks for all tenants");
      // Get all tasks with isRecurring=true
      const tasks = await this.storage.getTasks(0); // 0 means all tenants
      const recurringTasks = tasks.filter(task => task.isRecurring === true);
      
      console.log(`Found ${recurringTasks.length} recurring tasks`);
      
      // Process each recurring task
      for (const task of recurringTasks) {
        await this.generateTasksFromTemplate(task);
      }
      
      console.log("Finished generating upcoming recurring tasks");
    } catch (error) {
      console.error("Error generating upcoming recurring tasks:", error);
    }
  }
  
  /**
   * Generate a new task instance from a recurring template
   */
  private async generateTasksFromTemplate(templateTask: Task): Promise<void> {
    try {
      if (!templateTask.complianceFrequency || !templateTask.complianceStartDate) {
        console.log(`Task ${templateTask.id} has no compliance frequency or start date, skipping`);
        return;
      }
      
      // Calculate next period (month, quarter, year, etc.)
      const startDate = new Date(templateTask.complianceStartDate);
      let endDate: Date;
      
      // Default to next month if frequency not recognized
      const nextMonth = addMonths(startDate, 1);
      const newStartDate = startOfMonth(nextMonth);
      endDate = endOfMonth(nextMonth);
      
      // Calculate compliance period string
      const compliancePeriod = this.calculateCompliancePeriod(
        templateTask.complianceFrequency,
        newStartDate
      );
      
      // Check if task already exists for this period
      const existingTasks = await this.storage.getTasks(templateTask.tenantId);
      const duplicateExists = existingTasks.some(task => 
        task.parentTaskId === templateTask.id && 
        task.compliancePeriod === compliancePeriod
      );
      
      if (duplicateExists) {
        console.log(`Task already exists for period ${compliancePeriod}, skipping`);
        return;
      }
      
      // Find "New" status 
      const statuses = await this.storage.getTaskStatuses(templateTask.tenantId);
      const newStatus = statuses.find(status => status.name.toLowerCase() === 'new' || status.rank === 1);
      
      if (!newStatus) {
        console.error(`No "New" status found for tenant ${templateTask.tenantId}`);
        return;
      }
      
      // Create new task from template
      const newTaskData: InsertTask = {
        tenantId: templateTask.tenantId,
        isAdmin: templateTask.isAdmin,
        taskType: templateTask.taskType,
        clientId: templateTask.clientId,
        entityId: templateTask.entityId,
        serviceTypeId: templateTask.serviceTypeId,
        taskCategoryId: templateTask.taskCategoryId,
        assigneeId: templateTask.assigneeId,
        dueDate: endDate,
        statusId: newStatus.id,
        taskDetails: templateTask.taskDetails,
        nextToDo: templateTask.nextToDo || '',
        isRecurring: false,
        complianceFrequency: templateTask.complianceFrequency,
        complianceYear: format(newStartDate, 'yyyy'),
        complianceDuration: templateTask.complianceDuration,
        complianceStartDate: newStartDate,
        complianceEndDate: endDate,
        compliancePeriod: compliancePeriod,
        currency: templateTask.currency,
        serviceRate: templateTask.serviceRate,
        parentTaskId: templateTask.id,
        isAutoGenerated: true,
        needsApproval: true
      };
      
      await this.storage.createTask(newTaskData);
      console.log(`Created new task for period ${compliancePeriod}`);
    } catch (error) {
      console.error(`Error generating task from template ${templateTask.id}:`, error);
    }
  }
  
  /**
   * Calculate compliance period based on frequency and start date
   */
  public calculateCompliancePeriod(frequency: string, startDate: Date): string {
    if (!frequency || !startDate) {
      return "";
    }

    const frequencyLower = frequency.toLowerCase();
    
    // Calculate compliance period based on frequency
    if (frequencyLower.includes('month')) {
      // Monthly format: "May 2025"
      return format(startDate, 'MMMM yyyy');
    } else if (frequencyLower.includes('quarter')) {
      // Quarterly format: "Q2 2025"
      const quarter = Math.floor(startDate.getMonth() / 3) + 1;
      return `Q${quarter} ${startDate.getFullYear()}`;
    } else if (frequencyLower.includes('annual') || frequencyLower.includes('year')) {
      if (frequencyLower.includes('5')) {
        // 5-year format: "2025-2029"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 4}`;
      } else if (frequencyLower.includes('4')) {
        // 4-year format: "2025-2028"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 3}`;
      } else if (frequencyLower.includes('3')) {
        // 3-year format: "2025-2027"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 2}`;
      } else if (frequencyLower.includes('2')) {
        // 2-year format: "2025-2026"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 1}`;
      } else {
        // Standard annual: "2025"
        return `${startDate.getFullYear()}`;
      }
    } else if (frequencyLower.includes('semi') || frequencyLower.includes('bi-annual')) {
      // Semi-annual format: "H1 2025" or "H2 2025"
      const half = startDate.getMonth() < 6 ? 1 : 2;
      return `H${half} ${startDate.getFullYear()}`;
    } else if (frequencyLower.includes('one time') || frequencyLower.includes('once')) {
      // One-time format: "May 2025 (One-time)"
      return `${format(startDate, 'MMMM yyyy')} (One-time)`;
    } else {
      // Default format for unknown frequencies
      return format(startDate, 'MMMM yyyy');
    }
  }
  
  /**
   * Get tasks that need approval (using the single-table approach)
   */
  public async getTasksNeedingApproval(tenantId: number): Promise<Task[]> {
    try {
      // Get all tasks for this tenant
      const allTasks = await this.storage.getTasks(tenantId);
      
      // Filter for auto-generated tasks that need approval
      return allTasks.filter(task => {
        return task.isAutoGenerated === true && task.needsApproval === true;
      });
    } catch (error) {
      console.error('Error getting tasks needing approval:', error);
      return [];
    }
  }
  
  /**
   * Approve a task - sets needsApproval to false and manages isRecurring flag
   */
  public async approveTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      // Get the task to approve
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task) {
        console.error(`Task ${taskId} not found for tenant ${tenantId}`);
        return false;
      }
      
      // Verify this is an auto-generated task that needs approval
      if (task.isAutoGenerated !== true || task.needsApproval !== true) {
        console.error(`Task ${taskId} is not an auto-generated task pending approval`);
        return false;
      }
      
      // Find the parent task and related tasks
      if (task.parentTaskId) {
        const parentTask = await this.storage.getTask(task.parentTaskId, tenantId);
        
        if (parentTask) {
          // Get all child tasks from this parent
          const allTasks = await this.storage.getTasks(tenantId);
          const childTasks = allTasks.filter(t => t.parentTaskId === parentTask.id);
          
          // Find the latest child task by compliance date
          let latestChild = task;
          for (const childTask of childTasks) {
            if (childTask.id !== task.id && childTask.complianceStartDate) {
              if (!latestChild.complianceStartDate || 
                  new Date(childTask.complianceStartDate) > new Date(latestChild.complianceStartDate)) {
                latestChild = childTask;
              }
            }
          }
          
          // Determine if this is the latest child
          const isLatest = latestChild.id === task.id;
          
          // Update this task
          await this.storage.updateTask(task.id, {
            isRecurring: isLatest, // Only the latest should be recurring
            needsApproval: false,  // Approved
            updatedAt: new Date()
          });
          
          // Update other child tasks to ensure only one is recurring
          if (isLatest) {
            for (const childTask of childTasks) {
              if (childTask.id !== task.id && childTask.isRecurring) {
                await this.storage.updateTask(childTask.id, {
                  isRecurring: false,
                  updatedAt: new Date()
                });
              }
            }
          }
          
          return true;
        }
      }
      
      // Fallback if parent not found
      await this.storage.updateTask(task.id, {
        needsApproval: false,
        updatedAt: new Date()
      });
      
      return true;
    } catch (error) {
      console.error(`Error approving task ${taskId}:`, error);
      return false;
    }
  }
  
  /**
   * Reject a task (delete it)
   */
  public async rejectTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task) {
        console.error(`Task ${taskId} not found for tenant ${tenantId}`);
        return false;
      }
      
      if (task.isAutoGenerated !== true || task.needsApproval !== true) {
        console.error(`Task ${taskId} is not an auto-generated task pending approval`);
        return false;
      }
      
      return await this.storage.deleteTask(taskId, tenantId);
    } catch (error) {
      console.error(`Error rejecting task ${taskId}:`, error);
      return false;
    }
  }
}