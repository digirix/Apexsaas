import { IStorage } from "./storage";
import { Task, InsertTask } from "@shared/schema";
import { 
  addMonths, addDays, format, 
  startOfMonth, endOfMonth, 
  subDays, isAfter,
  addYears
} from "date-fns";

const DEFAULT_LEAD_DAYS = 14; // Default lead time for generating recurring tasks

/**
 * TaskScheduler is responsible for generating recurring tasks
 * based on their frequency and compliance periods
 */
export class TaskScheduler {
  private storage: IStorage;
  private leadDaysOverride: number | null;
  
  constructor(storage: IStorage, leadDaysOverride: number | null = null) {
    this.storage = storage;
    this.leadDaysOverride = leadDaysOverride;
  }
  
  /**
   * Generate upcoming recurring tasks for all tenants
   * This should be run periodically (e.g., daily) to create tasks for upcoming periods
   */
  public async generateUpcomingRecurringTasks(): Promise<void> {
    try {
      // Get all tenants
      const tenants = await this.getAllTenants();
      
      for (const tenant of tenants) {
        await this.generateRecurringTasksForTenant(tenant.id);
      }
      
      console.log(`Recurring task generation completed for ${tenants.length} tenants`);
    } catch (error) {
      console.error("Error generating recurring tasks:", error);
    }
  }
  
  /**
   * Generate recurring tasks for a specific tenant
   */
  public async generateRecurringTasksForTenant(tenantId: number): Promise<void> {
    try {
      // Get tenant-specific settings for lead days
      const leadDaysSetting = await this.storage.getTenantSetting(
        tenantId,
        "recurring_task_lead_days"
      );
      
      // Use tenant setting, override, or default
      const leadDays = this.leadDaysOverride !== null
        ? this.leadDaysOverride
        : (leadDaysSetting?.value ? parseInt(leadDaysSetting.value, 10) : DEFAULT_LEAD_DAYS);
      
      console.log(`Using configured lead days: ${leadDays} for tenant ${tenantId}`);
      
      // Find all recurring tasks for this tenant that haven't been canceled
      const allTasks = await this.storage.getTasks(tenantId);
      const recurringTasks = allTasks.filter(task => 
        task.isRecurring && 
        !task.isCanceled && 
        !task.isAutoGenerated
      );
      
      console.log(`Found ${recurringTasks.length} recurring tasks for tenant ${tenantId}`);
      
      // Process each recurring task
      for (const task of recurringTasks) {
        await this.processRecurringTask(task, leadDays);
      }
      
      console.log(`Generated recurring tasks for tenant ${tenantId}`);
    } catch (error) {
      console.error(`Error generating recurring tasks for tenant ${tenantId}:`, error);
    }
  }
  
  /**
   * Process a single recurring task and create new instances if needed
   * This method takes a recurring task from the Tasks module and generates
   * future auto-generated tasks in the Auto Generated Tasks module
   */
  private async processRecurringTask(task: Task, leadDays: number): Promise<void> {
    try {
      // Skip processing if task doesn't have compliance frequency
      if (!task.complianceFrequency) {
        console.log(`Skipping task ${task.id} - Missing frequency. Frequency: ${task.complianceFrequency}, Duration: ${task.complianceDuration}`);
        return;
      }
      
      // Skip one-time tasks - they don't need recurring generation
      if (task.complianceFrequency.toLowerCase().includes('one time') || 
          task.complianceFrequency.toLowerCase() === 'once') {
        console.log(`Skipping one-time task ${task.id} - Not eligible for recurring generation`);
        return;
      }
      
      // Skip auto-generated tasks (they should not generate further tasks)
      if (task.isAutoGenerated) {
        console.log(`Skipping auto-generated task ${task.id} - Auto-generated tasks don't spawn new tasks`);
        return;
      }
      
      // Only process tasks that have the isRecurring flag set to true
      if (!task.isRecurring) {
        console.log(`Skipping non-recurring task ${task.id} - Task is not marked as recurring`);
        return;
      }
      
      // Get original period - require compliance dates
      if (!task.complianceStartDate || !task.complianceEndDate) {
        console.log(`Skipping task ${task.id} - Missing compliance dates`);
        return;
      }
      
      // Initialize duration to empty string if not provided
      const duration = task.complianceDuration || '';
      
      console.log(`Processing recurring task ${task.id}: ${task.taskDetails || 'No details'}`);
      console.log(`Frequency: ${task.complianceFrequency}, Duration: ${duration}`);
      console.log(`Compliance Period: ${format(new Date(task.complianceStartDate), 'yyyy-MM-dd')} to ${format(new Date(task.complianceEndDate), 'yyyy-MM-dd')}`);
      
      // Get the existing tasks for this tenant/client/entity to check for existing periods
      const existingTasks = await this.storage.getTasks(
        task.tenantId,
        task.clientId || undefined,
        task.entityId || undefined,
        task.isAdmin
      );
      
      // IMPORTANT: We need to start from the EXISTING compliance period first
      // to ensure we have the correct sequence of periods
      const originalEndDate = new Date(task.complianceEndDate);
      
      // Current date to calculate lead time
      const now = new Date();
      
      // Add lead days to determine how far in advance we should generate tasks
      const cutoffDate = new Date(now);
      cutoffDate.setDate(cutoffDate.getDate() + leadDays);
      
      console.log(`Using lead days: ${leadDays}, cutoff date for task generation: ${format(cutoffDate, 'yyyy-MM-dd')}`);
      
      // Collection to store all periods that need to be generated
      let periodsToGenerate: { startDate: Date, endDate: Date, dueDate: Date }[] = [];
      
      // We'll use the original compliance period as our starting reference
      // and incrementally calculate the next periods
      let currentReferenceDate = originalEndDate;
      
      // Generate sequence of periods from the original end date
      // up to the cutoff date (current date + lead days)
      console.log(`Generating periods starting after: ${format(currentReferenceDate, 'yyyy-MM-dd')}`);
      
      // Limit to 36 iterations to prevent infinite loops (covers 3 years of monthly tasks)
      for (let i = 0; i < 36; i++) {
        // Calculate the next period after the current reference date
        const nextPeriod = this.calculateNextCompliancePeriod(
          task.complianceFrequency,
          duration,
          currentReferenceDate
        );
        
        if (!nextPeriod) {
          console.log(`Could not calculate period after ${format(currentReferenceDate, 'yyyy-MM-dd')} for task ${task.id}`);
          break;
        }
        
        const { startDate, endDate } = nextPeriod;
        
        // Calculate due date (typically a few days before the end date)
        const dueDate = this.calculateDueDate(endDate);
        
        console.log(`Calculated period: ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}, Due: ${format(dueDate, 'yyyy-MM-dd')}`);
        
        // Stop generating if we've reached our cutoff date
        if (isAfter(startDate, cutoffDate)) {
          console.log(`Stopping at period starting ${format(startDate, 'yyyy-MM-dd')} - beyond cutoff date ${format(cutoffDate, 'yyyy-MM-dd')}`);
          break;
        }
        
        // Check if a task already exists for this period
        const periodExists = this.doesPeriodExist(task, startDate, endDate, existingTasks);
        
        if (!periodExists) {
          // Only add to generation queue if period doesn't already exist
          periodsToGenerate.push({ 
            startDate,
            endDate,
            dueDate 
          });
          console.log(`Added period to generation queue: ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
        } else {
          console.log(`Period already exists - skipping: ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
        }
        
        // Move to the next period using the end date as our new reference
        currentReferenceDate = endDate;
      }
      
      // Generate tasks for all missing periods
      for (const period of periodsToGenerate) {
        const { startDate, endDate, dueDate } = period;
        await this.createRecurringTaskInstance(task, startDate, endDate, dueDate);
      }
      
      console.log(`Generated ${periodsToGenerate.length} tasks for task ${task.id}`);
    } catch (error) {
      console.error(`Error processing recurring task ${task.id}:`, error);
    }
  }
  
  /**
   * Check if a task already exists for a specific compliance period
   */
  private doesPeriodExist(task: Task, startDate: Date, endDate: Date, existingTasks: Task[]): boolean {
    // Convert dates to month/year format for easier comparison (e.g., "2025-05")
    const periodMonthYear = format(startDate, 'yyyy-MM');
    
    // Log the period we're checking
    console.log(`Checking if period ${periodMonthYear} exists for task type: ${task.isAdmin ? 'Admin' : 'Revenue'}, client: ${task.clientId}, entity: ${task.entityId}, service: ${task.serviceTypeId}`);
    
    return existingTasks.some(existingTask => {
      // Skip tasks without compliance dates
      if (!existingTask.complianceStartDate || !existingTask.complianceEndDate) {
        return false;
      }
      
      const existingStartDate = new Date(existingTask.complianceStartDate);
      const existingPeriodMonthYear = format(existingStartDate, 'yyyy-MM');
      
      // Match by month/year rather than exact date
      // This ensures we don't generate multiple tasks for the same month
      const periodMatch = existingPeriodMonthYear === periodMonthYear;
      
      if (!periodMatch) {
        return false;
      }
      
      // Check that other critical fields match to ensure it's truly a duplicate
      // for the same client, entity, service, and category
      const basicFieldsMatch = 
        existingTask.clientId === task.clientId &&
        existingTask.entityId === task.entityId &&
        existingTask.serviceTypeId === task.serviceTypeId &&
        existingTask.taskCategoryId === task.taskCategoryId;
      
      if (!basicFieldsMatch) {
        return false;
      }
      
      // Consider a period to exist if any of these conditions are true:
      const statusMatch = (
        // We no longer check isAutoGenerated since we're querying both tables separately
        existingTask.needsApproval || existingTask.needs_approval ||
        // Or it's a regular task for this period with a parent task ID matching our task
        (existingTask.parentTaskId === task.id || existingTask.parent_task_id === task.id) ||
        // This is a regular task with the same compliance period parameters
        ((existingTask.complianceFrequency === task.complianceFrequency || 
          existingTask.compliance_frequency === task.complianceFrequency || 
          existingTask.complianceFrequency === task.compliance_frequency ||
          existingTask.compliance_frequency === task.compliance_frequency) &&
         (existingTask.clientId === task.clientId || existingTask.client_id === task.clientId || 
          existingTask.clientId === task.client_id || existingTask.client_id === task.client_id) &&
         (existingTask.entityId === task.entityId || existingTask.entity_id === task.entityId ||
          existingTask.entityId === task.entity_id || existingTask.entity_id === task.entity_id) &&
         (existingTask.serviceTypeId === task.serviceTypeId || existingTask.service_type_id === task.serviceTypeId ||
          existingTask.serviceTypeId === task.service_type_id || existingTask.service_type_id === task.service_type_id))
      );
      
      if (statusMatch) {
        const needsApprovalValue = existingTask.needsApproval !== undefined ? 
          existingTask.needsApproval : 
          existingTask.needs_approval;
        console.log(`Task already exists for period ${periodMonthYear} - Task ID: ${existingTask.id}, needsApproval: ${needsApprovalValue}`);
        return true;
      }
      
      return false;
    });
  }
  
  /**
   * Create a new instance of a recurring task for a specific period
   */
  private async createRecurringTaskInstance(
    templateTask: Task, 
    startDate: Date, 
    endDate: Date,
    dueDate: Date
  ): Promise<void> {
    try {
      // Ensure the dates are properly formatted with consistent time components
      // Start date: First day of month at 00:00:00
      const complianceStartDate = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
      complianceStartDate.setHours(0, 0, 0, 0);
      
      // End date: Last day of month at 23:59:59.999
      const complianceEndDate = new Date(endDate.getFullYear(), endDate.getMonth() + 1, 0);
      complianceEndDate.setHours(23, 59, 59, 999);
      
      // Format as month/year for logging and validation
      const periodMonthYear = format(complianceStartDate, 'yyyy-MM');
      console.log(`Formatted compliance period: ${format(complianceStartDate, 'yyyy-MM-dd')} to ${format(complianceEndDate, 'yyyy-MM-dd')}`);
      
      // First, check if a task already exists for this exact month/year to avoid duplication
      const existingTasks = await this.storage.getTasks(
        templateTask.tenantId,
        templateTask.clientId || undefined,
        templateTask.entityId || undefined
      );
      
      console.log(`Found ${existingTasks.length} existing tasks for tenant ${templateTask.tenantId}, client ${templateTask.clientId}, entity ${templateTask.entityId}`);
      
      // We need to check regular tasks to prevent duplicates
      // Auto-generated tasks will be checked separately via getAutoGeneratedTasks
      const duplicateExists = existingTasks.some(task => {
        // Skip tasks without compliance dates
        if (!task.complianceStartDate) {
          return false;
        }
        
        // Get month/year for comparison
        const taskMonthYear = format(new Date(task.complianceStartDate), 'yyyy-MM');
        
        // Check if the months match
        const monthsMatch = taskMonthYear === periodMonthYear;
        if (!monthsMatch) {
          return false;
        }
        
        // Regular task case - check if a regular task already exists for this period
        const regularTaskMatch = 
          task.serviceTypeId === templateTask.serviceTypeId &&
          task.clientId === templateTask.clientId && 
          task.entityId === templateTask.entityId &&
          task.complianceFrequency === templateTask.complianceFrequency;
            
          if (regularTaskMatch) {
            console.log(`Found existing regular task: ${task.id} for period ${taskMonthYear}`);
            return true;
          }
        }
        
        return false;
      });
      
      if (duplicateExists) {
        console.log(`Skipping generation for period ${periodMonthYear} - task already exists`);
        return;
      }
      
      // Find the "New" status for this tenant
      const statuses = await this.storage.getTaskStatuses(templateTask.tenantId);
      const newStatus = statuses.find(status => status.name.toLowerCase() === 'new' || status.rank === 1);
      
      if (!newStatus) {
        console.error(`No "New" status (rank 1) found for tenant ${templateTask.tenantId}`);
        return;
      }
      
      // Check if auto-approval setting is enabled
      const autoApproveTasksSetting = await this.storage.getTenantSetting(
        templateTask.tenantId, 
        "auto_approve_recurring_tasks"
      );
      
      const needsApproval = !autoApproveTasksSetting || 
                            autoApproveTasksSetting.value.toLowerCase() !== "true";
      
      // Set a descriptive task name based on the compliance period
      let taskDetails = templateTask.taskDetails || '';
      
      // If no task details exist, generate a default description
      if (!taskDetails) {
        const serviceName = templateTask.serviceTypeId 
          ? (await this.getServiceName(templateTask.tenantId, templateTask.serviceTypeId)) || 'Service'
          : 'Task';
        
        taskDetails = `${serviceName} - ${templateTask.complianceFrequency} compliance for period ${format(complianceStartDate, 'MMM yyyy')}`;
      }
      
      // Determine if this is a one-time task
      const isOneTime = templateTask.complianceFrequency?.toLowerCase() === 'one time' || 
                       templateTask.complianceFrequency?.toLowerCase() === 'once';
      
      // Prepare the new task data with careful handling of fields, using correct auto_generated_tasks field names
      const newTaskData = {
        tenant_id: templateTask.tenantId,
        is_admin: templateTask.isAdmin,
        task_type: templateTask.taskType,
        // Handle optional foreign key references properly
        client_id: templateTask.clientId === null ? undefined : templateTask.clientId,
        entity_id: templateTask.entityId === null ? undefined : templateTask.entityId,
        service_type_id: templateTask.serviceTypeId === null ? undefined : templateTask.serviceTypeId,
        task_category_id: templateTask.taskCategoryId === null ? undefined : templateTask.taskCategoryId,
        assignee_id: templateTask.assigneeId,
        // Use the calculated due date
        due_date: dueDate,
        status_id: newStatus.id,
        // Use generated task details if original is empty
        task_details: taskDetails,
        next_to_do: templateTask.nextToDo || '',
        // Auto-generated tasks are never recurring themselves
        is_recurring: false,
        // Set compliance metadata with proper formatting
        compliance_frequency: templateTask.complianceFrequency || '',
        compliance_year: format(complianceStartDate, 'yyyy'),
        compliance_duration: templateTask.complianceDuration || '',
        // Use our properly formatted dates with standardized times
        compliance_start_date: complianceStartDate,
        compliance_end_date: complianceEndDate,
        // Calculate and set the compliance period
        compliance_period: `${format(complianceStartDate, 'MMM yyyy')}`,
        // Handle remaining optional fields
        currency: templateTask.currency || '',
        service_rate: templateTask.serviceRate || 0,
        // Important metadata for tracking
        parent_task_id: templateTask.id,
        needs_approval: needsApproval,
        is_canceled: false,
      };
      
      console.log('Creating auto-generated task with data:', JSON.stringify({
        ...newTaskData,
        compliance_start_date: format(complianceStartDate, 'yyyy-MM-dd'),
        compliance_end_date: format(complianceEndDate, 'yyyy-MM-dd'),
        due_date: format(dueDate, 'yyyy-MM-dd'),
      }, null, 2));
      
      // Create the new task in the auto_generated_tasks table
      const newTask = await this.storage.createAutoGeneratedTask(newTaskData);
      console.log(`Created auto-generated task ID ${newTask.id} for period ${format(complianceStartDate, 'yyyy-MM-dd')} to ${format(complianceEndDate, 'yyyy-MM-dd')} ${needsApproval ? '(needs approval)' : '(auto-approved)'}`);
    } catch (error) {
      console.error("Error in createRecurringTaskInstance:", error);
    }
  }
  
  /**
   * Retrieve service name for better task descriptions
   */
  private async getServiceName(tenantId: number, serviceTypeId: number): Promise<string | undefined> {
    try {
      const service = await this.storage.getServiceType(serviceTypeId, tenantId);
      return service?.name;
    } catch (error) {
      console.error("Error fetching service name:", error);
      return undefined;
    }
  }
  
  /**
   * Get all tasks that need approval from the auto_generated_tasks table
   */
  public async getTasksNeedingApproval(tenantId: number): Promise<AutoGeneratedTask[]> {
    try {
      // Use the dedicated method to get auto-generated tasks that need approval
      const tasksNeedingApproval = await this.storage.getAutoGeneratedTasksByApprovalStatus(tenantId, true);
      
      console.log(`Found ${tasksNeedingApproval.length} tasks needing approval`);
      return tasksNeedingApproval;
    } catch (error) {
      console.error("Error fetching tasks needing approval:", error);
      return [];
    }
  }
  
  /**
   * Get task history (previously approved auto-generated tasks)
   */
  public async getTaskHistory(tenantId: number): Promise<Task[]> {
    try {
      const allTasks = await this.storage.getTasks(tenantId);
      
      // We want to show only auto-generated tasks that have already been approved
      // but are still flagged as auto-generated
      const historicalTasks = allTasks.filter(task => {
        // Task must be explicitly flagged as auto-generated
        const isAutoGenerated = task.isAutoGenerated === true;
        
        // Task must NOT need approval anymore (it's been processed)
        const doesNotNeedApproval = task.needsApproval === false;
        
        // Task should have a parent task ID to be part of a recurring series
        const hasParentTask = task.parentTaskId !== null && task.parentTaskId !== undefined;
        
        return isAutoGenerated && doesNotNeedApproval && hasParentTask;
      });
      
      console.log(`Found ${historicalTasks.length} historical tasks out of ${allTasks.length} total tasks`);
      return historicalTasks;
    } catch (error) {
      console.error("Error fetching task history:", error);
      return [];
    }
  }
  
  /**
   * Approve a generated task (remove approval flag)
   * When approved, moves the auto-generated task to the Tasks module by making it a regular task,
   * marks the original parent task as non-recurring, and only
   * sets the most recent task's recurring flag to true
   */
  public async approveTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      // Get the specific task to be approved by its ID from the auto_generated_tasks table
      const task = await this.storage.getAutoGeneratedTask(taskId, tenantId);
      
      if (!task || !task.needs_approval) {
        console.log(`Task ${taskId} not eligible for approval (not found in auto_generated_tasks table or not needing approval)`);
        return false;
      }
      
      console.log(`Approving auto-generated task ${taskId} for tenant ${tenantId}`);
      console.log(`Task details: client: ${task.client_id}, entity: ${task.entity_id}, service: ${task.service_type_id}, frequency: ${task.compliance_frequency}`);
      
      if (task.compliance_start_date && task.compliance_end_date) {
        console.log(`Compliance period: ${format(new Date(task.compliance_start_date), 'yyyy-MM-dd')} to ${format(new Date(task.compliance_end_date), 'yyyy-MM-dd')}`);
      }
      
      // Only get existing tasks for this tenant - we'll use this for the minimum
      // necessary filtering of tasks, being careful not to alter any tasks except the
      // specific one being approved by ID
      const existingTasks = await this.storage.getTasks(tenantId);
      
      console.log(`Found ${existingTasks.length} existing tasks for tenant ${tenantId}`);
      
      // Check if this specific task already exists as a regular task (by parentTaskId)
      // We're only looking for a direct match with the current task ID as parent
      // This ensures we only process the exact task being approved by its ID
      const regularTaskExists = existingTasks.some(existingTask => {
        // IMPORTANT: ONLY match by exact task ID as parent
        // Do not perform any other matching based on periods/client/entity
        // This is to ensure only the specific approved task is converted
        if (existingTask.parentTaskId === task.id) {
          console.log(`Found existing regular task (direct parent link): ${existingTask.id}`);
          return true;
        }
        
        return false;
      });
      
      // Don't create a new task if one already exists for this specific approved task
      if (regularTaskExists) {
        console.log(`Regular task already exists for auto-generated task ${task.id}. Not creating duplicate.`);
        
        // Just update the auto-generated task to no longer need approval
        // Use the correct field names for the auto_generated_tasks table
        const update = {
          needs_approval: false
        };
        
        await this.storage.updateAutoGeneratedTask(taskId, update);
        return true;
      }
      
      console.log(`Converting auto-generated task ${task.id} to a regular task`);
      
      // Check if this is a one-time task
      const isOneTime = task.complianceFrequency?.toLowerCase() === 'one time' || 
                       task.complianceFrequency?.toLowerCase() === 'once';
      
      // IMPORTANT: Determine if this is the latest compliance period for this task
      // We only want to set isRecurring=true on the latest task
      let isLatestCompliancePeriod = true;
      
      if (task.parent_task_id) {
        // Find the original parent task
        const originalParentId = task.parent_task_id;
        
        // Get all other auto-generated tasks with the same parent
        const autoGeneratedTasks = await this.storage.getAutoGeneratedTasks(tenantId);
        
        // Only filter auto-generated tasks that:
        // 1. Share the EXACT SAME parent task ID (important for distinguishing task lineage)
        // 2. Match the same client, entity, and service type (the core identifying attributes)
        // 3. Are not the current task
        // This ensures we're only comparing relevant tasks that came from the same parent
        const siblingTasks = autoGeneratedTasks.filter(siblingTask => 
          siblingTask.parent_task_id === originalParentId && 
          siblingTask.client_id === task.client_id &&
          siblingTask.entity_id === task.entity_id &&
          siblingTask.service_type_id === task.service_type_id &&
          siblingTask.id !== task.id
        );
        
        // Check if any sibling has a later compliance period
        if (task.compliance_end_date) {
          const taskEndDate = new Date(task.compliance_end_date);
          
          for (const sibling of siblingTasks) {
            if (sibling.compliance_end_date) {
              const siblingEndDate = new Date(sibling.compliance_end_date);
              
              if (siblingEndDate > taskEndDate) {
                // Found a sibling with a later compliance period
                isLatestCompliancePeriod = false;
                console.log(`This task (period ending ${format(taskEndDate, 'yyyy-MM-dd')}) is not the latest - found newer period: ${format(siblingEndDate, 'yyyy-MM-dd')}`);
                break;
              }
            }
          }
        }
      } 
      
      console.log(`This task is${isLatestCompliancePeriod ? '' : ' not'} the latest compliance period`);
      
      try {
        // Fix compliance end date to always be last day of month at 23:59:59.999
        // Recalculate to ensure dates are consistent
        let fixedComplianceEndDate: Date | undefined = undefined;
        if (task.compliance_start_date) {
          // Calculate end of month from the start date
          const startDate = new Date(task.compliance_start_date);
          const frequency = task.compliance_frequency?.toLowerCase() || '';
          
          // Calculate the end date based on the frequency
          let endDate: Date;
          if (frequency.includes('quarterly')) {
            // For quarterly, get the last day of the last month in the quarter
            const quarterStartMonth = Math.floor(startDate.getMonth() / 3) * 3;
            endDate = new Date(startDate.getFullYear(), quarterStartMonth + 3, 0);
          } else if (frequency.includes('semi-annual') || frequency.includes('bi-annual')) {
            // For semi-annual/bi-annual, 6 months
            endDate = new Date(startDate.getFullYear(), startDate.getMonth() + 6, 0);
          } else if (frequency.includes('annual') || frequency.includes('yearly')) {
            // For annual/yearly, last day of same month next year
            endDate = new Date(startDate.getFullYear() + 1, startDate.getMonth(), 0);
          } else {
            // Default for monthly and other cases - last day of the month
            endDate = new Date(startDate.getFullYear(), startDate.getMonth() + 1, 0);
          }
          
          // Ensure it's set to end of day
          endDate.setHours(23, 59, 59, 999);
          fixedComplianceEndDate = endDate;
          console.log(`Fixed compliance end date: ${format(fixedComplianceEndDate, 'yyyy-MM-dd HH:mm:ss.SSS')}`);
        }
        
        // CRITICAL FIX: Instead of updating the existing task to set isAutoGenerated=false,
        // we'll create a completely new task that's a copy of this task, but mark it as a regular task
        // This ensures each approval is completely isolated from other tasks
        
        // First, just mark the auto-generated task as no longer needing approval
        // We're now working with the auto_generated_tasks table
        const autoTaskUpdate: any = {
          needs_approval: false // Mark as processed
        };
        
        // Update only the compliance end date if we have it
        if (fixedComplianceEndDate) {
          autoTaskUpdate.compliance_end_date = fixedComplianceEndDate;
        }
        
        console.log(`Updating auto-generated task ${taskId} with data:`, JSON.stringify(autoTaskUpdate, null, 2));
        
        // Update the auto-generated task to mark it as processed in the auto_generated_tasks table
        await this.storage.updateAutoGeneratedTask(taskId, autoTaskUpdate);
        
        // Now create a completely new regular task that's a copy of the auto-generated task
        // This is the task that will appear in the Tasks module
        // Handle null values correctly to prevent type errors
        const newRegularTask: any = {
          tenantId: task.tenant_id,
          isAdmin: task.is_admin || false,
          taskType: task.task_type || 'Regular',
          assigneeId: task.assignee_id,
          dueDate: task.due_date,
          statusId: task.status_id,
          taskDetails: task.task_details || '',
          nextToDo: task.next_to_do || '',
          isRecurring: !isOneTime && isLatestCompliancePeriod, // Only the latest period should be recurring
          parentTaskId: task.id, // Link to the original auto-generated task
          needsApproval: false // Regular tasks don't need approval
        };
        
        // Copy optional fields only if they exist
        if (task.client_id !== null) newRegularTask.clientId = task.client_id;
        if (task.entity_id !== null) newRegularTask.entityId = task.entity_id;
        if (task.service_type_id !== null) newRegularTask.serviceTypeId = task.service_type_id;
        if (task.task_category_id !== null) newRegularTask.taskCategoryId = task.task_category_id;
        if (task.compliance_frequency) newRegularTask.complianceFrequency = task.compliance_frequency;
        if (task.compliance_year) newRegularTask.complianceYear = task.compliance_year;
        if (task.compliance_duration) newRegularTask.complianceDuration = task.compliance_duration;
        
        // Use the fixed compliance dates when available
        if (task.compliance_start_date) {
          newRegularTask.complianceStartDate = task.compliance_start_date;
        }
        if (fixedComplianceEndDate) {
          newRegularTask.complianceEndDate = fixedComplianceEndDate;
        } else if (task.compliance_end_date) {
          newRegularTask.complianceEndDate = task.compliance_end_date;
        }
        
        // Set the compliance period string (new field)
        if (task.compliance_period) {
          newRegularTask.compliance_period = task.compliance_period;
        } else if (task.compliance_start_date) {
          // If no explicit compliance_period is set, generate one from the start date
          newRegularTask.compliance_period = format(new Date(task.compliance_start_date), 'MMM yyyy');
        }
        
        // Add remaining optional fields
        if (task.currency) newRegularTask.currency = task.currency;
        if (task.service_rate) newRegularTask.serviceRate = task.service_rate;
        if (task.invoice_id) newRegularTask.invoiceId = task.invoice_id;
        
        // Add metadata fields
        newRegularTask.createdAt = new Date();
        newRegularTask.isCanceled = false;
        newRegularTask.canceledAt = null;
        newRegularTask.activatedAt = null;
        
        console.log(`Creating new regular task as a copy of auto-generated task ${taskId}`);
        
        // Create the new regular task
        const newTaskId = await this.storage.createTask(newRegularTask);
        
        if (!newTaskId) {
          console.log(`Failed to create new regular task from auto-generated task ${taskId}`);
          return false;
        }
        
        console.log(`Successfully converted auto-generated task ${taskId} to regular task`);
        
        // If this task is the latest for its period, we need to set the original parent task's
        // isRecurring flag to false, as only the newest approved task should be recurring
        if (isLatestCompliancePeriod && task.parent_task_id) {
          console.log(`This is the latest compliance period - setting original parent task ${task.parent_task_id} to non-recurring`);
          
          // First, fetch the specific parent task to ensure it exists and only update that one
          const parentTask = await this.storage.getTask(task.parent_task_id, tenantId);
          
          if (parentTask) {
            console.log(`Found specific parent task with ID: ${parentTask.id}, updating only this task`);
            
            // Update ONLY the original parent task with the exact ID to be non-recurring
            await this.storage.updateTask(task.parent_task_id, {
              isRecurring: false,
              updatedAt: new Date()
            });
          } else {
            console.log(`Parent task with ID ${task.parent_task_id} not found, skipping update`);
          }
        }
        
        return true;
      } catch (error) {
        console.error(`Error converting auto-generated task to regular task: ${error}`);
        return false;
      }
    } catch (error) {
      console.error("Error approving task:", error);
      return false;
    }
  }
  
  /**
   * Approve all pending tasks for a tenant
   */
  public async approveAllPendingTasks(tenantId: number): Promise<number> {
    try {
      // Get initial list of pending tasks
      const pendingTasks = await this.getTasksNeedingApproval(tenantId);
      console.log(`Found ${pendingTasks.length} tasks needing approval for tenant ${tenantId}`);
      
      let approvedCount = 0;
      
      // Process each task individually, one at a time with explicit ID tracking
      // This ensures each task approval is completely isolated from the others
      for (const task of pendingTasks) {
        // Store the specific task ID we're going to approve
        const taskIdToApprove = task.id;
        
        console.log(`Processing task ${taskIdToApprove} individually for approval`);
        
        try {
          // Process this specific task ID only
          const approved = await this.approveTask(taskIdToApprove, tenantId);
          
          if (approved) {
            approvedCount++;
            console.log(`Successfully approved task ${taskIdToApprove}`);
          } else {
            console.log(`Failed to approve task ${taskIdToApprove}`);
          }
          
          // Small delay to ensure database operations are complete before processing next task
          await new Promise(resolve => setTimeout(resolve, 100));
          
        } catch (taskError) {
          console.error(`Error processing task ${taskIdToApprove}:`, taskError);
          // Continue with next task even if this one failed
        }
      }
      
      console.log(`Successfully approved ${approvedCount} out of ${pendingTasks.length} pending tasks`);
      return approvedCount;
    } catch (error) {
      console.error("Error approving all pending tasks:", error);
      return 0;
    }
  }
  
  /**
   * Reject a generated task (delete it)
   */
  public async rejectTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated || !task.needsApproval) {
        return false;
      }
      
      return await this.storage.deleteTask(taskId, tenantId);
    } catch (error) {
      console.error("Error rejecting task:", error);
      return false;
    }
  }
  
  /**
   * Set a task to active (sets activatedAt timestamp)
   */
  public async activateTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      // This method should be used for auto-generated tasks
      const task = await this.storage.getAutoGeneratedTask(taskId, tenantId);
      
      if (!task) {
        return false;
      }
      
      // Get the "In Progress" status for this tenant
      const statuses = await this.storage.getTaskStatuses(tenantId);
      const inProgressStatus = statuses.find(status => status.name.toLowerCase().includes('progress') || status.rank === 2);
      
      if (!inProgressStatus) {
        console.error(`No suitable "In Progress" status found for tenant ${tenantId}`);
        return false;
      }
      
      // Update the auto-generated task to be active with correct field names for the auto_generated_tasks table
      const update = {
        activated_at: new Date(),
        status_id: inProgressStatus.id
      };
      
      const updated = await this.storage.updateAutoGeneratedTask(taskId, update);
      return !!updated;
    } catch (error) {
      console.error("Error activating task:", error);
      return false;
    }
  }
  
  /**
   * Cancel a task (sets isCanceled flag and canceledAt timestamp)
   */
  public async cancelTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      // This method should be used for auto-generated tasks
      const task = await this.storage.getAutoGeneratedTask(taskId, tenantId);
      
      if (!task) {
        return false;
      }
      
      // Update the auto-generated task to be canceled with correct field names for auto_generated_tasks table
      const update = {
        is_canceled: true,
        canceled_at: new Date()
      };
      
      const updated = await this.storage.updateAutoGeneratedTask(taskId, update);
      return !!updated;
    } catch (error) {
      console.error("Error canceling task:", error);
      return false;
    }
  }
  
  /**
   * Resume a previously canceled task
   */
  public async resumeTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      // This method should be used for auto-generated tasks
      const task = await this.storage.getAutoGeneratedTask(taskId, tenantId);
      
      if (!task || !task.is_canceled) {
        return false;
      }
      
      // Get the "In Progress" status for this tenant
      const statuses = await this.storage.getTaskStatuses(tenantId);
      const inProgressStatus = statuses.find(status => status.name.toLowerCase().includes('progress') || status.rank === 2);
      
      if (!inProgressStatus) {
        console.error(`No suitable "In Progress" status found for tenant ${tenantId}`);
        return false;
      }
      
      // Update the auto-generated task to be no longer canceled and change its status
      // Use the correct field names for the auto_generated_tasks table
      const update = {
        is_canceled: false,
        canceled_at: undefined, // Use undefined instead of null for Date field
        activated_at: new Date(),
        status_id: inProgressStatus.id
      };
      
      const updated = await this.storage.updateAutoGeneratedTask(taskId, update);
      return !!updated;
    } catch (error) {
      console.error("Error resuming task:", error);
      return false;
    }
  }
  
  /**
   * Permanently delete a task
   */
  public async deleteTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      // This method should be used for auto-generated tasks
      const task = await this.storage.getAutoGeneratedTask(taskId, tenantId);
      
      if (!task) {
        return false;
      }
      
      // Delete the auto-generated task
      return await this.storage.deleteAutoGeneratedTask(taskId, tenantId);
    } catch (error) {
      console.error("Error deleting task:", error);
      return false;
    }
  }
  
  /**
   * Calculate the next compliance period based on frequency and duration
   * Handles all compliance frequencies including:
   * - Monthly
   * - Bi Monthly
   * - Quarterly
   * - Semi Annual
   * - Annual
   * - 2 Years
   * - 3 Years
   * - 4 Years
   * - 5 Years
   */
  private calculateNextCompliancePeriod(
    frequency?: string, 
    duration?: string,
    referenceDate?: Date
  ): { startDate: Date; endDate: Date } | null {
    if (!frequency || !referenceDate) {
      console.log('Missing required parameters for calculating next period');
      return null;
    }
    
    try {
      // Normalize the frequency string for consistent matching
      const freq = frequency.toLowerCase().trim();
      const refYear = referenceDate.getFullYear();
      const refMonth = referenceDate.getMonth();
      
      console.log(`Calculating next period for frequency: ${frequency}, duration: ${duration || ''}, reference date: ${format(referenceDate, 'yyyy-MM-dd')}`);
      
      let startDate: Date;
      let endDate: Date;
      
      // MONTHLY frequency
      if (freq === 'monthly' || freq.includes('month')) {
        // Get the next month after the reference date
        let nextMonth = refMonth + 1;
        let nextYear = refYear;
        
        // Handle year rollover if needed
        if (nextMonth > 11) {
          nextMonth = 0; // January
          nextYear += 1;
        }
        
        // First day of next month
        startDate = new Date(nextYear, nextMonth, 1);
        startDate.setHours(0, 0, 0, 0);
        
        // Last day of next month
        endDate = new Date(nextYear, nextMonth + 1, 0);
        endDate.setHours(23, 59, 59, 999);
        
        console.log(`Monthly: Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // BI-MONTHLY frequency
      else if ((freq.includes('bi') || freq.includes('bi-')) && freq.includes('month')) {
        // Calculate the next bi-monthly period (2 months)
        let nextMonth = refMonth + 1;
        let nextYear = refYear;
        
        // Handle year rollover
        if (nextMonth > 11) {
          nextMonth = 0;
          nextYear += 1;
        }
        
        // First day of first month in bi-monthly period
        startDate = new Date(nextYear, nextMonth, 1);
        startDate.setHours(0, 0, 0, 0);
        
        // Calculate the end month (1 month after start month)
        let endMonth = nextMonth + 1;
        let endYear = nextYear;
        
        // Handle year rollover
        if (endMonth > 11) {
          endMonth = 0;
          endYear += 1;
        }
        
        // Last day of second month in bi-monthly period
        endDate = new Date(endYear, endMonth + 1, 0);
        endDate.setHours(23, 59, 59, 999);
        
        console.log(`Bi-Monthly: Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // QUARTERLY frequency
      else if (freq.includes('quarter')) {
        // Current quarter (0-3)
        const currQuarter = Math.floor(refMonth / 3);
        
        // Next quarter (0-3)
        const nextQuarter = (currQuarter + 1) % 4;
        
        // Increment year if moving from Q4 to Q1
        const nextYear = (currQuarter === 3) ? refYear + 1 : refYear;
        
        // Calculate start month (0, 3, 6, or 9)
        const startMonth = nextQuarter * 3;
        
        // First day of first month in quarter
        startDate = new Date(nextYear, startMonth, 1);
        startDate.setHours(0, 0, 0, 0);
        
        // Last day of third month in quarter
        endDate = new Date(nextYear, startMonth + 3, 0);
        endDate.setHours(23, 59, 59, 999);
        
        console.log(`Quarterly: Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // SEMI-ANNUAL frequency
      else if ((freq.includes('semi') && freq.includes('annual')) || 
               freq.includes('half') && freq.includes('year')) {
        // Current half (0 = Jan-Jun, 1 = Jul-Dec)
        const currHalf = refMonth < 6 ? 0 : 1;
        
        // Next half (toggle between 0 and 1)
        const nextHalf = (currHalf + 1) % 2;
        
        // Increment year if moving from second half to first half
        const nextYear = (nextHalf === 0) ? refYear + 1 : refYear;
        
        // Start month is January (0) or July (6)
        const startMonth = nextHalf * 6;
        
        // First day of first month in half-year
        startDate = new Date(nextYear, startMonth, 1);
        startDate.setHours(0, 0, 0, 0);
        
        // Last day of sixth month in half-year
        endDate = new Date(nextYear, startMonth + 6, 0);
        endDate.setHours(23, 59, 59, 999);
        
        console.log(`Semi-Annual: Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // ANNUAL frequency
      else if (freq.includes('annual') || freq.includes('year') && 
               !freq.includes('2') && !freq.includes('3') && 
               !freq.includes('4') && !freq.includes('5')) {
        // For annual periods, add one year to the reference year
        
        // Check for fiscal year (if specified in duration)
        if (duration && (duration.toLowerCase() === 'fy' || 
                         duration.toLowerCase().includes('fiscal'))) {
          // Assuming fiscal year starts in July (month 6)
          // This can be customized based on requirements
          
          // Determine current fiscal year
          const currFiscalYear = (refMonth >= 6) ? refYear : refYear - 1;
          
          // Next fiscal year
          const nextFiscalYear = currFiscalYear + 1;
          
          // First day of fiscal year (July 1)
          startDate = new Date(nextFiscalYear, 6, 1);
          startDate.setHours(0, 0, 0, 0);
          
          // Last day of fiscal year (June 30)
          endDate = new Date(nextFiscalYear + 1, 5, 30);
          endDate.setHours(23, 59, 59, 999);
          
          console.log(`Annual (Fiscal Year): Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
        } else {
          // Standard calendar year
          
          // First day of next year
          startDate = new Date(refYear + 1, 0, 1);
          startDate.setHours(0, 0, 0, 0);
          
          // Last day of next year
          endDate = new Date(refYear + 1, 11, 31);
          endDate.setHours(23, 59, 59, 999);
          
          console.log(`Annual (Calendar Year): Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
        }
      }
      
      // 2 YEARS frequency
      else if (freq.includes('2') && freq.includes('year')) {
        // First day of next 2-year period
        startDate = new Date(refYear + 1, 0, 1);
        startDate.setHours(0, 0, 0, 0);
        
        // Last day of next 2-year period
        endDate = new Date(refYear + 2, 11, 31);
        endDate.setHours(23, 59, 59, 999);
        
        console.log(`2 Years: Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // 3 YEARS frequency
      else if (freq.includes('3') && freq.includes('year')) {
        // First day of next 3-year period
        startDate = new Date(refYear + 1, 0, 1);
        startDate.setHours(0, 0, 0, 0);
        
        // Last day of next 3-year period
        endDate = new Date(refYear + 3, 11, 31);
        endDate.setHours(23, 59, 59, 999);
        
        console.log(`3 Years: Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // 4 YEARS frequency
      else if (freq.includes('4') && freq.includes('year')) {
        // First day of next 4-year period
        startDate = new Date(refYear + 1, 0, 1);
        startDate.setHours(0, 0, 0, 0);
        
        // Last day of next 4-year period
        endDate = new Date(refYear + 4, 11, 31);
        endDate.setHours(23, 59, 59, 999);
        
        console.log(`4 Years: Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // 5 YEARS frequency
      else if (freq.includes('5') && freq.includes('year')) {
        // First day of next 5-year period
        startDate = new Date(refYear + 1, 0, 1);
        startDate.setHours(0, 0, 0, 0);
        
        // Last day of next 5-year period
        endDate = new Date(refYear + 5, 11, 31);
        endDate.setHours(23, 59, 59, 999);
        
        console.log(`5 Years: Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // Unsupported frequency
      else {
        console.warn(`Unsupported frequency: ${frequency}`);
        return null;
      }
      
      // Make sure our resulting period is after the reference date
      if (startDate <= referenceDate) {
        console.warn(`Calculated start date (${format(startDate, 'yyyy-MM-dd')}) is not after reference date (${format(referenceDate, 'yyyy-MM-dd')})`);
        
        // Force to the next appropriate period
        if (freq === 'monthly' || freq.includes('month')) {
          startDate = addMonths(startOfMonth(referenceDate), 1);
          endDate = endOfMonth(startDate);
          endDate.setHours(23, 59, 59, 999);
        } else {
          // For other frequencies, add one day to reference date as fallback
          startDate = addDays(referenceDate, 1);
          startDate.setHours(0, 0, 0, 0);
          endDate = addMonths(startDate, 1);
          endDate.setHours(23, 59, 59, 999);
        }
        
        console.log(`Corrected period: ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      return { startDate, endDate };
    } catch (error) {
      console.error(`Error calculating next compliance period: ${error}`);
      return null;
    }
  }
  
  /**
   * Calculate due date (typically end of period or slightly before)
   */
  private calculateDueDate(endDate: Date): Date {
    // Due date is typically a few days before the end of the period
    // This can be customized based on business rules
    return subDays(endDate, 5);
  }
  
  /**
   * Helper to get all tenants from storage
   */
  private async getAllTenants(): Promise<Tenant[]> {
    // This is a simplification - in a real implementation,
    // we would need a method to retrieve all tenants
    const result: Tenant[] = [];
    
    // Start with tenant ID 1 and try incrementing
    // This is a workaround since our storage interface doesn't
    // provide a way to get all tenants
    for (let i = 1; i <= 100; i++) {
      try {
        const tenant = await this.storage.getTenant(i);
        if (tenant) {
          result.push(tenant);
        }
      } catch (error) {
        // Ignore errors, just try the next tenant ID
      }
    }
    
    return result;
  }
}

// Helper type for Tenant since we're using it internally
interface Tenant {
  id: number;
  name: string;
  createdAt: Date;
}