import { IStorage } from "./storage";
import { Task, InsertTask } from "../shared/schema";
import { format, addMonths, startOfMonth, endOfMonth } from "date-fns";

/**
 * Class that handles task scheduling and approval using a single-table approach
 * All tasks (regular and auto-generated) are stored in a single tasks table
 * with flags to differentiate them
 */
export class TaskScheduler {
  private storage: IStorage;
  
  constructor(storage: IStorage) {
    this.storage = storage;
  }
  
  /**
   * Generate upcoming recurring tasks for all tenants (called periodically)
   * This is the main entry point for the task generation process
   */
  public async generateUpcomingRecurringTasks(): Promise<void> {
    try {
      console.log("Starting to generate upcoming recurring tasks for all tenants");
      // Get all tasks with isRecurring=true
      const tasks = await this.storage.getTasks(0); // 0 means all tenants
      const recurringTasks = tasks.filter(task => task.isRecurring === true);
      
      console.log(`Found ${recurringTasks.length} recurring tasks`);
      
      // Process each recurring task
      for (const task of recurringTasks) {
        await this.generateTasksFromTemplate(task);
      }
      
      console.log("Finished generating upcoming recurring tasks");
    } catch (error) {
      console.error("Error generating upcoming recurring tasks:", error);
    }
  }
  
  /**
   * Generate a new task instance from a recurring template
   */
  private async generateTasksFromTemplate(templateTask: Task): Promise<void> {
    try {
      if (!templateTask.complianceFrequency || !templateTask.complianceStartDate) {
        console.log(`Task ${templateTask.id} has no compliance frequency or start date, skipping`);
        return;
      }
      
      // Calculate next period (month, quarter, year, etc.)
      const startDate = new Date(templateTask.complianceStartDate);
      let endDate: Date;
      
      // Default to next month if frequency not recognized
      const nextMonth = addMonths(startDate, 1);
      const newStartDate = startOfMonth(nextMonth);
      endDate = endOfMonth(nextMonth);
      
      // Calculate compliance period string
      const compliancePeriod = this.calculateCompliancePeriod(
        templateTask.complianceFrequency,
        newStartDate
      );
      
      // Check if task already exists for this period
      const existingTasks = await this.storage.getTasks(templateTask.tenantId);
      const duplicateExists = existingTasks.some(task => 
        task.parentTaskId === templateTask.id && 
        task.compliancePeriod === compliancePeriod
      );
      
      if (duplicateExists) {
        console.log(`Task already exists for period ${compliancePeriod}, skipping`);
        return;
      }
      
      // Find "New" status 
      const statuses = await this.storage.getTaskStatuses(templateTask.tenantId);
      const newStatus = statuses.find(status => status.name.toLowerCase() === 'new' || status.rank === 1);
      
      if (!newStatus) {
        console.error(`No "New" status found for tenant ${templateTask.tenantId}`);
        return;
      }
      
      // Create new task from template
      const newTaskData: InsertTask = {
        tenantId: templateTask.tenantId,
        isAdmin: templateTask.isAdmin,
        taskType: templateTask.taskType,
        clientId: templateTask.clientId,
        entityId: templateTask.entityId,
        serviceTypeId: templateTask.serviceTypeId,
        taskCategoryId: templateTask.taskCategoryId,
        assigneeId: templateTask.assigneeId,
        dueDate: endDate,
        statusId: newStatus.id,
        taskDetails: templateTask.taskDetails,
        nextToDo: templateTask.nextToDo || '',
        isRecurring: false,
        complianceFrequency: templateTask.complianceFrequency,
        complianceYear: format(newStartDate, 'yyyy'),
        complianceDuration: templateTask.complianceDuration,
        complianceStartDate: newStartDate,
        complianceEndDate: endDate,
        compliancePeriod: compliancePeriod,
        currency: templateTask.currency,
        serviceRate: templateTask.serviceRate,
        parentTaskId: templateTask.id,
        isAutoGenerated: true,
        needsApproval: true
      };
      
      await this.storage.createTask(newTaskData);
      console.log(`Created new task for period ${compliancePeriod}`);
    } catch (error) {
      console.error(`Error generating task from template ${templateTask.id}:`, error);
    }
  }
  
  /**
   * Calculate compliance period based on frequency and start date
   */
  public calculateCompliancePeriod(frequency: string, startDate: Date): string {
    if (!frequency || !startDate) {
      return "";
    }

    const frequencyLower = frequency.toLowerCase();
    
    // Calculate compliance period based on frequency
    if (frequencyLower.includes('month')) {
      // Monthly format: "May 2025"
      return format(startDate, 'MMMM yyyy');
    } else if (frequencyLower.includes('quarter')) {
      // Quarterly format: "Q2 2025"
      const quarter = Math.floor(startDate.getMonth() / 3) + 1;
      return `Q${quarter} ${startDate.getFullYear()}`;
    } else if (frequencyLower.includes('annual') || frequencyLower.includes('year')) {
      if (frequencyLower.includes('5')) {
        // 5-year format: "2025-2029"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 4}`;
      } else if (frequencyLower.includes('4')) {
        // 4-year format: "2025-2028"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 3}`;
      } else if (frequencyLower.includes('3')) {
        // 3-year format: "2025-2027"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 2}`;
      } else if (frequencyLower.includes('2')) {
        // 2-year format: "2025-2026"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 1}`;
      } else {
        // Standard annual: "2025"
        return `${startDate.getFullYear()}`;
      }
    } else if (frequencyLower.includes('semi') || frequencyLower.includes('bi-annual')) {
      // Semi-annual format: "H1 2025" or "H2 2025"
      const half = startDate.getMonth() < 6 ? 1 : 2;
      return `H${half} ${startDate.getFullYear()}`;
    } else if (frequencyLower.includes('one time') || frequencyLower.includes('once')) {
      // One-time format: "May 2025 (One-time)"
      return `${format(startDate, 'MMMM yyyy')} (One-time)`;
    } else {
      // Default format for unknown frequencies
      return format(startDate, 'MMMM yyyy');
    }
  }
  
  /**
   * Get tasks that need approval (using the single-table approach)
   */
  public async getTasksNeedingApproval(tenantId: number): Promise<Task[]> {
    try {
      // Get all tasks for this tenant
      const allTasks = await this.storage.getTasks(tenantId);
      
      // Filter for auto-generated tasks that need approval
      return allTasks.filter(task => {
        return task.isAutoGenerated === true && task.needsApproval === true;
      });
    } catch (error) {
      console.error('Error getting tasks needing approval:', error);
      return [];
    }
  }
  
  /**
   * Approve a task - sets needsApproval to false and manages isRecurring flag
   * This is the main method for approving auto-generated tasks in the single-table approach
   * @param taskId The ID of the task to approve
   * @param tenantId The tenant ID for security checks
   * @returns true if approval is successful, false otherwise
   */
  public async approveTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      console.log(`Attempting to approve task ${taskId} for tenant ${tenantId}`);
      
      // Get the task to approve
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task) {
        console.error(`Task ${taskId} not found for tenant ${tenantId}`);
        return false;
      }
      
      // Verify this is an auto-generated task that needs approval
      if (task.isAutoGenerated !== true || task.needsApproval !== true) {
        console.error(`Task ${taskId} is not an auto-generated task pending approval`);
        return false;
      }
      
      console.log(`Processing approval for auto-generated task ${taskId}`);
      
      if (task.clientId && task.entityId && task.serviceTypeId && task.complianceFrequency) {
        console.log(`Task details: client: ${task.clientId}, entity: ${task.entityId}, service: ${task.serviceTypeId}, frequency: ${task.complianceFrequency}`);
      }
      
      if (task.complianceStartDate && task.complianceEndDate) {
        console.log(`Compliance period: ${new Date(task.complianceStartDate).toISOString().split('T')[0]} to ${new Date(task.complianceEndDate).toISOString().split('T')[0]}`);
      }

      // Find the parent task
      if (!task.parentTaskId) {
        console.error(`Task ${taskId} has no parent task ID`);
        return false;
      }
      
      const parentTask = await this.storage.getTask(task.parentTaskId, tenantId);
      if (!parentTask) {
        console.error(`Parent task ${task.parentTaskId} not found`);
        return false;
      }
      
      // Get all tasks in this series (siblings and the task itself)
      const allTasks = await this.storage.getTasks(tenantId);
      const siblingTasks = allTasks.filter(t => t.parentTaskId === parentTask.id);
      
      // Find the latest task by compliance date
      let latestTask = task;
      for (const siblingTask of siblingTasks) {
        if (siblingTask.complianceStartDate && latestTask.complianceStartDate) {
          const siblingDate = new Date(siblingTask.complianceStartDate);
          const latestDate = new Date(latestTask.complianceStartDate);
          
          if (siblingDate > latestDate) {
            latestTask = siblingTask;
          }
        }
      }
      
      // Determine if this task is the latest
      const isLatest = latestTask.id === task.id;
      
      if (isLatest) {
        console.log(`This task (period ending ${task.complianceEndDate}) is the latest compliance period`);
      } else if (latestTask.complianceEndDate) {
        console.log(`This task (period ending ${task.complianceEndDate}) is not the latest - found newer period: ${latestTask.complianceEndDate}`);
        console.log("This task is not the latest compliance period");
      }
      
      // Ensure proper end date format (YYYY-MM-DDT23:59:59.999Z)
      let fixedEndDate = task.complianceEndDate;
      if (fixedEndDate && !fixedEndDate.toString().includes("23:59:59")) {
        const endDate = new Date(fixedEndDate);
        endDate.setHours(23, 59, 59, 999);
        fixedEndDate = endDate;
        console.log(`Fixed compliance end date: ${endDate.toISOString().split('T')[0]} 23:59:59.999`);
      }
      
      // CRITICAL CHANGE: When approving, modify the auto-generated task itself
      // 1. Update the auto-generated task being approved
      const updateData: any = {
        // If this is the latest task in the series, make it the new recurring source
        isRecurring: isLatest,
        // No longer auto-generated once approved
        isAutoGenerated: false,
        // No longer needs approval
        needsApproval: false,
        // Update timestamp
        updatedAt: new Date()
      };
      
      // Only set the compliance end date if it's not null
      if (fixedEndDate) {
        updateData.complianceEndDate = fixedEndDate;
      }
      
      console.log(`Updating auto-generated task ${taskId} with data:`, updateData);
      
      // Update the task
      await this.storage.updateTask(taskId, updateData);
      
      // 2. If this is the latest task, set the parent's isRecurring to false
      if (isLatest && parentTask.isRecurring) {
        console.log(`Setting parent task ${parentTask.id} isRecurring to false (passing the baton)`);
        await this.storage.updateTask(parentTask.id, {
          isRecurring: false,
          updatedAt: new Date()
        });
      }
      
      console.log(`Task ${taskId} has been approved successfully`);
      return true;
    } catch (error) {
      console.error(`Error approving task ${taskId}:`, error);
      return false;
    }
  }
  
  /**
   * Reject a task - mark it as canceled
   * This implements the reject functionality for auto-generated tasks
   * @param taskId The ID of the task to reject
   * @param tenantId The tenant ID for security checks
   * @returns true if rejection is successful, false otherwise
   */
  public async rejectTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      console.log(`Attempting to reject task ${taskId} for tenant ${tenantId}`);
      
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task) {
        console.error(`Task ${taskId} not found for tenant ${tenantId}`);
        return false;
      }
      
      if (task.isAutoGenerated !== true || task.needsApproval !== true) {
        console.error(`Task ${taskId} is not an auto-generated task pending approval`);
        return false;
      }
      
      console.log(`Processing rejection for auto-generated task ${taskId}`);
      
      // Simply mark as canceled and update flags
      // We're not creating any new tasks when rejecting
      await this.storage.updateTask(taskId, {
        isCanceled: true,
        canceledAt: new Date(),
        needsApproval: false, // No longer needs approval since it's rejected
        updatedAt: new Date()
      });
      
      console.log(`Task ${taskId} has been rejected successfully`);
      return true;
    } catch (error) {
      console.error(`Error rejecting task ${taskId}:`, error);
      return false;
    }
  }
}