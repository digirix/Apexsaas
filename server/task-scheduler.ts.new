import { IStorage } from "./storage";
import { Task } from "../shared/schema";
import { format, addMonths, addDays, startOfMonth, endOfMonth } from "date-fns";

/**
 * Class that handles the generation of recurring tasks
 * and approval of auto-generated tasks
 */
export class TaskScheduler {
  private storage: IStorage;
  
  constructor(storage: IStorage) {
    this.storage = storage;
  }
  
  /**
   * Generate upcoming recurring tasks for all tenants
   */
  public async generateUpcomingRecurringTasks(): Promise<void> {
    try {
      const tenants = await this.storage.getTenants();
      
      for (const tenant of tenants) {
        await this.generateRecurringTasksForTenant(tenant.id);
      }
    } catch (error) {
      console.error("Error generating recurring tasks:", error);
    }
  }
  
  /**
   * Generate recurring tasks for a specific tenant
   */
  public async generateRecurringTasksForTenant(tenantId: number): Promise<void> {
    try {
      // Find all recurring tasks
      const recurringTasks = await this.storage.getRecurringTasks(tenantId);
      
      for (const task of recurringTasks) {
        await this.processRecurringTask(task);
      }
    } catch (error) {
      console.error(`Error generating tasks for tenant ${tenantId}:`, error);
    }
  }
  
  /**
   * Process a single recurring task and create a new instance if needed
   */
  private async processRecurringTask(task: Task): Promise<void> {
    if (!task.complianceFrequency || !task.complianceStartDate) {
      return;
    }
    
    // Calculate next compliance period based on frequency
    const nextPeriod = this.calculateNextCompliancePeriod(
      task.complianceFrequency, 
      new Date(task.complianceStartDate)
    );
    
    if (!nextPeriod) {
      return;
    }
    
    const { startDate, endDate } = nextPeriod;
    
    // Check if a task already exists for this period
    const existingTasks = await this.storage.getTasks(task.tenantId);
    const periodExists = this.doesPeriodExist(task, startDate, endDate, existingTasks);
    
    if (periodExists) {
      return;
    }
    
    // Calculate due date (typically end of period)
    const dueDate = this.calculateDueDate(endDate);
    
    // Create new instance of recurring task
    await this.createRecurringTaskInstance(task, startDate, endDate, dueDate);
  }
  
  /**
   * Check if a task already exists for a specific compliance period
   */
  private doesPeriodExist(task: Task, startDate: Date, endDate: Date, existingTasks: Task[]): boolean {
    const startMonthYear = format(startDate, 'yyyy-MM');
    
    // Check if any existing task matches this compliance period
    return existingTasks.some(existingTask => {
      if (!existingTask.complianceStartDate) return false;
      
      const taskMonthYear = format(new Date(existingTask.complianceStartDate), 'yyyy-MM');
      
      // Check if months match
      if (taskMonthYear !== startMonthYear) {
        return false;
      }
      
      // Check if this is a task for the same client/entity/service
      const isMatch = 
        existingTask.serviceTypeId === task.serviceTypeId &&
        existingTask.clientId === task.clientId && 
        existingTask.entityId === task.entityId &&
        existingTask.complianceFrequency === task.complianceFrequency;
      
      return isMatch;
    });
  }
  
  /**
   * Create a new instance of a recurring task
   */
  private async createRecurringTaskInstance(
    templateTask: Task, 
    startDate: Date, 
    endDate: Date,
    dueDate: Date
  ): Promise<void> {
    try {
      // Find the "New" status for this tenant
      const statuses = await this.storage.getTaskStatuses(templateTask.tenantId);
      const newStatus = statuses.find(status => status.name.toLowerCase() === 'new' || status.rank === 1);
      
      if (!newStatus) {
        console.error(`No "New" status found for tenant ${templateTask.tenantId}`);
        return;
      }

      // Calculate compliance period string representation
      const compliancePeriod = this.calculateCompliancePeriod(
        templateTask.complianceFrequency || "", 
        startDate
      );
      
      // Create a task description if needed
      let taskDetails = templateTask.taskDetails;
      
      if (!taskDetails) {
        const serviceName = templateTask.serviceTypeId 
          ? (await this.getServiceName(templateTask.tenantId, templateTask.serviceTypeId)) || 'Service'
          : 'Task';
        
        taskDetails = `${serviceName} - ${templateTask.complianceFrequency} for period ${format(startDate, 'MMM yyyy')}`;
      }
      
      // Create new task
      const newTaskData = {
        tenantId: templateTask.tenantId,
        isAdmin: templateTask.isAdmin,
        taskType: templateTask.taskType,
        clientId: templateTask.clientId,
        entityId: templateTask.entityId,
        serviceTypeId: templateTask.serviceTypeId,
        taskCategoryId: templateTask.taskCategoryId,
        assigneeId: templateTask.assigneeId,
        dueDate: dueDate,
        statusId: newStatus.id,
        taskDetails: taskDetails,
        nextToDo: templateTask.nextToDo || '',
        isRecurring: false, // Auto-generated tasks are not recurring themselves
        complianceFrequency: templateTask.complianceFrequency,
        complianceYear: format(startDate, 'yyyy'),
        complianceDuration: templateTask.complianceDuration,
        complianceStartDate: startDate,
        complianceEndDate: endDate,
        compliancePeriod: compliancePeriod, // Important! Save the calculated compliance period
        currency: templateTask.currency,
        serviceRate: templateTask.serviceRate,
        parentTaskId: templateTask.id, // Link to template task
        needsApproval: true,
        isAutoGenerated: true
      };
      
      await this.storage.createTask(newTaskData);
    } catch (error) {
      console.error("Error creating recurring task instance:", error);
    }
  }
  
  /**
   * Get all tasks that need approval
   */
  public async getTasksNeedingApproval(tenantId: number): Promise<Task[]> {
    const tasks = await this.storage.getTasks(tenantId);
    return tasks.filter(task => task.isAutoGenerated && task.needsApproval);
  }
  
  /**
   * Get task history (previously approved tasks)
   */
  public async getTaskHistory(tenantId: number): Promise<Task[]> {
    const tasks = await this.storage.getTasks(tenantId);
    return tasks.filter(task => 
      task.isAutoGenerated === true && 
      task.needsApproval === false
    );
  }
  
  /**
   * Approve a generated task
   * When approved, sets needsApproval to false and handles isRecurring flag
   * to maintain a proper one-to-one relationship between approved tasks
   */
  public async approveTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      // Get the auto-generated task
      const task = await this.storage.getTaskById(taskId);
      
      if (!task || task.tenantId !== tenantId) {
        console.error(`Task ${taskId} not found or doesn't belong to tenant ${tenantId}`);
        return false;
      }
      
      if (task.isAutoGenerated !== true || task.needsApproval !== true) {
        console.error(`Task ${taskId} is not an auto-generated task pending approval`);
        return false;
      }
      
      // For the parent (template) task, find if this is the latest approval
      if (task.parentTaskId) {
        const templateTask = await this.storage.getTaskById(task.parentTaskId);
        
        if (templateTask) {
          // Find all generated tasks from this template
          const allTasks = await this.storage.getTasks(tenantId);
          const childTasks = allTasks.filter(t => t.parentTaskId === templateTask.id);
          
          // Find the latest child task by compliance period
          let latestChild = task;
          for (const childTask of childTasks) {
            if (childTask.id !== task.id && childTask.complianceStartDate) {
              if (!latestChild.complianceStartDate || 
                  new Date(childTask.complianceStartDate) > new Date(latestChild.complianceStartDate)) {
                latestChild = childTask;
              }
            }
          }
          
          // If this is the latest child, set isRecurring to true
          const isLatest = latestChild.id === task.id;
          
          // Update this task
          await this.storage.updateTask(task.id, {
            isRecurring: isLatest, // Only the latest task should be recurring
            needsApproval: false,  // Approved
            updatedAt: new Date()
          });
          
          // Update other child tasks to ensure only one is recurring
          if (isLatest) {
            for (const childTask of childTasks) {
              if (childTask.id !== task.id && childTask.isRecurring) {
                await this.storage.updateTask(childTask.id, {
                  isRecurring: false,
                  updatedAt: new Date()
                });
              }
            }
          }
          
          console.log(`Approved auto-generated task ${taskId}, set as ${isLatest ? '' : 'non-'}recurring`);
          return true;
        }
      }
      
      // Fallback if parent task not found
      await this.storage.updateTask(task.id, {
        needsApproval: false,
        updatedAt: new Date()
      });
      
      return true;
    } catch (error) {
      console.error(`Error approving task ${taskId}:`, error);
      return false;
    }
  }
  
  /**
   * Approve all pending tasks for a tenant
   */
  public async approveAllPendingTasks(tenantId: number): Promise<number> {
    try {
      const pendingTasks = await this.getTasksNeedingApproval(tenantId);
      let approvedCount = 0;
      
      for (const task of pendingTasks) {
        const approved = await this.approveTask(task.id, tenantId);
        if (approved) {
          approvedCount++;
        }
      }
      
      return approvedCount;
    } catch (error) {
      console.error(`Error approving all pending tasks for tenant ${tenantId}:`, error);
      return 0;
    }
  }
  
  /**
   * Reject a generated task (delete it)
   */
  public async rejectTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTaskById(taskId);
      
      if (!task || task.tenantId !== tenantId) {
        console.error(`Task ${taskId} not found or doesn't belong to tenant ${tenantId}`);
        return false;
      }
      
      if (task.isAutoGenerated !== true || task.needsApproval !== true) {
        console.error(`Task ${taskId} is not an auto-generated task pending approval`);
        return false;
      }
      
      await this.storage.deleteTask(taskId);
      return true;
    } catch (error) {
      console.error(`Error rejecting task ${taskId}:`, error);
      return false;
    }
  }
  
  /**
   * Calculate compliance period based on frequency and start date
   */
  private calculateCompliancePeriod(frequency: string, startDate: Date): string {
    if (!frequency || !startDate) {
      return "";
    }

    const frequencyLower = frequency.toLowerCase();
    
    // Calculate compliance period based on frequency
    if (frequencyLower.includes('month')) {
      // Monthly format: "May 2025"
      return format(startDate, 'MMMM yyyy');
    } else if (frequencyLower.includes('quarter')) {
      // Quarterly format: "Q2 2025"
      const quarter = Math.floor(startDate.getMonth() / 3) + 1;
      return `Q${quarter} ${startDate.getFullYear()}`;
    } else if (frequencyLower.includes('annual') || frequencyLower.includes('year')) {
      if (frequencyLower.includes('5')) {
        // 5-year format: "2025-2029"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 4}`;
      } else if (frequencyLower.includes('4')) {
        // 4-year format: "2025-2028"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 3}`;
      } else if (frequencyLower.includes('3')) {
        // 3-year format: "2025-2027"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 2}`;
      } else if (frequencyLower.includes('2')) {
        // 2-year format: "2025-2026"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 1}`;
      } else {
        // Standard annual: "2025"
        return `${startDate.getFullYear()}`;
      }
    } else if (frequencyLower.includes('semi') || frequencyLower.includes('bi-annual')) {
      // Semi-annual format: "H1 2025" or "H2 2025"
      const half = startDate.getMonth() < 6 ? 1 : 2;
      return `H${half} ${startDate.getFullYear()}`;
    } else if (frequencyLower.includes('one time') || frequencyLower.includes('once')) {
      // One-time format: "May 2025 (One-time)"
      return `${format(startDate, 'MMMM yyyy')} (One-time)`;
    } else {
      // Default format for unknown frequencies
      return format(startDate, 'MMMM yyyy');
    }
  }
  
  /**
   * Calculate the next compliance period based on frequency
   */
  private calculateNextCompliancePeriod(
    frequency: string, 
    referenceDate: Date
  ): { startDate: Date; endDate: Date } | null {
    try {
      const freq = frequency.toLowerCase();
      
      // Monthly frequency
      if (freq.includes('month')) {
        // Next month after reference date
        const nextMonth = addMonths(referenceDate, 1);
        const startDate = startOfMonth(nextMonth);
        startDate.setHours(0, 0, 0, 1);
        
        const endDate = endOfMonth(nextMonth);
        endDate.setHours(23, 59, 59, 999);
        
        return { startDate, endDate };
      }
      
      // Quarterly frequency
      else if (freq.includes('quarter')) {
        // Current quarter
        const currentQuarter = Math.floor(referenceDate.getMonth() / 3);
        
        // Start of next quarter (add 3 months to start of current quarter)
        const nextQuarterMonth = (currentQuarter + 1) * 3;
        const nextYear = referenceDate.getFullYear() + (nextQuarterMonth >= 12 ? 1 : 0);
        const adjustedMonth = nextQuarterMonth % 12;
        
        const startDate = new Date(nextYear, adjustedMonth, 1);
        startDate.setHours(0, 0, 0, 1);
        
        // End of next quarter
        const endDate = new Date(nextYear, adjustedMonth + 3, 0);
        endDate.setHours(23, 59, 59, 999);
        
        return { startDate, endDate };
      }
      
      // Annual frequency
      else if (freq.includes('annual') || freq.includes('year')) {
        // If multi-year frequency
        let years = 1;
        
        if (freq.includes('2 year') || freq.includes('2-year')) years = 2;
        else if (freq.includes('3 year') || freq.includes('3-year')) years = 3;
        else if (freq.includes('4 year') || freq.includes('4-year')) years = 4;
        else if (freq.includes('5 year') || freq.includes('5-year')) years = 5;
        
        // Next year after reference date
        const startDate = new Date(referenceDate.getFullYear() + 1, 0, 1);
        startDate.setHours(0, 0, 0, 1);
        
        // End date based on number of years
        const endDate = new Date(startDate.getFullYear() + (years - 1), 11, 31);
        endDate.setHours(23, 59, 59, 999);
        
        return { startDate, endDate };
      }
      
      // Semi-annual frequency
      else if (freq.includes('semi') || freq.includes('bi-annual')) {
        const currentMonth = referenceDate.getMonth();
        const currentYear = referenceDate.getFullYear();
        
        // Current half (0-5 = first half, 6-11 = second half)
        const currentHalf = currentMonth < 6 ? 0 : 1;
        
        // Next half
        let nextHalfStartMonth, nextHalfYear;
        
        if (currentHalf === 0) {
          // Current is first half, next is second half of same year
          nextHalfStartMonth = 6;
          nextHalfYear = currentYear;
        } else {
          // Current is second half, next is first half of next year
          nextHalfStartMonth = 0;
          nextHalfYear = currentYear + 1;
        }
        
        const startDate = new Date(nextHalfYear, nextHalfStartMonth, 1);
        startDate.setHours(0, 0, 0, 1);
        
        const endMonth = nextHalfStartMonth + 5;
        const endDate = new Date(nextHalfYear, endMonth, 
                               new Date(nextHalfYear, endMonth + 1, 0).getDate());
        endDate.setHours(23, 59, 59, 999);
        
        return { startDate, endDate };
      }
      
      // One-time tasks don't generate new instances
      else if (freq.includes('one time') || freq.includes('once')) {
        return null;
      }
      
      // Default to monthly if not recognized
      else {
        console.warn(`Unknown frequency: ${frequency}, defaulting to monthly`);
        
        // Next month after reference date
        const nextMonth = addMonths(referenceDate, 1);
        const startDate = startOfMonth(nextMonth);
        startDate.setHours(0, 0, 0, 1);
        
        const endDate = endOfMonth(nextMonth);
        endDate.setHours(23, 59, 59, 999);
        
        return { startDate, endDate };
      }
    } catch (error) {
      console.error(`Error calculating next compliance period:`, error);
      return null;
    }
  }
  
  /**
   * Calculate due date based on compliance end date
   */
  private calculateDueDate(endDate: Date): Date {
    // By default, due date is the end of the compliance period
    return new Date(endDate);
  }
  
  /**
   * Helper to get service name for task details template
   */
  private async getServiceName(tenantId: number, serviceTypeId: number): Promise<string | null> {
    try {
      const service = await this.storage.getServiceType(tenantId, serviceTypeId);
      return service?.name || null;
    } catch (error) {
      console.error(`Error getting service name:`, error);
      return null;
    }
  }
}