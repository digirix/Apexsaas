import { IStorage } from "./storage";
import { Task, InsertTask } from "@shared/schema";
import { 
  addMonths, addDays, format, 
  startOfMonth, endOfMonth, 
  subDays, isAfter,
  addYears
} from "date-fns";

const DEFAULT_LEAD_DAYS = 14; // Default lead time for generating recurring tasks

/**
 * TaskScheduler is responsible for generating recurring tasks
 * based on their frequency and compliance periods
 */
export class TaskScheduler {
  private storage: IStorage;
  private leadDaysOverride: number | null;
  
  constructor(storage: IStorage, leadDaysOverride: number | null = null) {
    this.storage = storage;
    this.leadDaysOverride = leadDaysOverride;
  }
  
  /**
   * Generate upcoming recurring tasks for all tenants
   * This should be run periodically (e.g., daily) to create tasks for upcoming periods
   */
  public async generateUpcomingRecurringTasks(): Promise<void> {
    try {
      // Get all tenants
      const tenants = await this.getAllTenants();
      
      for (const tenant of tenants) {
        await this.generateRecurringTasksForTenant(tenant.id);
      }
      
      console.log(`Recurring task generation completed for ${tenants.length} tenants`);
    } catch (error) {
      console.error("Error generating recurring tasks:", error);
    }
  }
  
  /**
   * Generate recurring tasks for a specific tenant
   */
  public async generateRecurringTasksForTenant(tenantId: number): Promise<void> {
    try {
      // Get tenant-specific settings for lead days
      const leadDaysSetting = await this.storage.getTenantSetting(
        tenantId,
        "recurring_task_lead_days"
      );
      
      // Use tenant setting, override, or default
      const leadDays = this.leadDaysOverride !== null
        ? this.leadDaysOverride
        : (leadDaysSetting?.value ? parseInt(leadDaysSetting.value, 10) : DEFAULT_LEAD_DAYS);
      
      console.log(`Using configured lead days: ${leadDays} for tenant ${tenantId}`);
      
      // Find all recurring tasks for this tenant that haven't been canceled
      const allTasks = await this.storage.getTasks(tenantId);
      const recurringTasks = allTasks.filter(task => 
        task.isRecurring && 
        !task.isCanceled && 
        !task.isAutoGenerated
      );
      
      console.log(`Found ${recurringTasks.length} recurring tasks for tenant ${tenantId}`);
      
      // Process each recurring task
      for (const task of recurringTasks) {
        await this.processRecurringTask(task, leadDays);
      }
      
      console.log(`Generated recurring tasks for tenant ${tenantId}`);
    } catch (error) {
      console.error(`Error generating recurring tasks for tenant ${tenantId}:`, error);
    }
  }
  
  /**
   * Process a single recurring task and create new instances if needed
   * This method takes a recurring task from the Tasks module and generates
   * future auto-generated tasks in the Auto Generated Tasks module
   */
  private async processRecurringTask(task: Task, leadDays: number): Promise<void> {
    try {
      // Skip processing if task doesn't have compliance frequency
      if (!task.complianceFrequency) {
        console.log(`Skipping task ${task.id} - Missing frequency. Frequency: ${task.complianceFrequency}, Duration: ${task.complianceDuration}`);
        return;
      }
      
      // Skip one-time tasks - they don't need recurring generation
      if (task.complianceFrequency.toLowerCase().includes('one time') || 
          task.complianceFrequency.toLowerCase() === 'once') {
        console.log(`Skipping one-time task ${task.id} - Not eligible for recurring generation`);
        return;
      }
      
      // Skip auto-generated tasks (they should not generate further tasks)
      if (task.isAutoGenerated) {
        console.log(`Skipping auto-generated task ${task.id} - Auto-generated tasks don't spawn new tasks`);
        return;
      }
      
      // Only process tasks that have the isRecurring flag set to true
      if (!task.isRecurring) {
        console.log(`Skipping non-recurring task ${task.id} - Task is not marked as recurring`);
        return;
      }
      
      // Get original period - require compliance dates
      if (!task.complianceStartDate || !task.complianceEndDate) {
        console.log(`Skipping task ${task.id} - Missing compliance dates`);
        return;
      }
      
      // Initialize duration to empty string if not provided
      const duration = task.complianceDuration || '';
      
      console.log(`Processing recurring task ${task.id}: ${task.taskDetails || 'No details'}`);
      console.log(`Frequency: ${task.complianceFrequency}, Duration: ${duration}`);
      console.log(`Compliance Period: ${format(new Date(task.complianceStartDate), 'yyyy-MM-dd')} to ${format(new Date(task.complianceEndDate), 'yyyy-MM-dd')}`);
      
      // Get the existing tasks for this tenant/client/entity to check for existing periods
      const existingTasks = await this.storage.getTasks(
        task.tenantId,
        task.clientId || undefined,
        task.entityId || undefined,
        task.isAdmin
      );
      
      // IMPORTANT: We need to start from the EXISTING compliance period first
      // to ensure we have the correct sequence of periods
      const originalEndDate = new Date(task.complianceEndDate);
      
      // Current date to calculate lead time
      const now = new Date();
      
      // Add lead days to determine how far in advance we should generate tasks
      const cutoffDate = new Date(now);
      cutoffDate.setDate(cutoffDate.getDate() + leadDays);
      
      console.log(`Using lead days: ${leadDays}, cutoff date for task generation: ${format(cutoffDate, 'yyyy-MM-dd')}`);
      
      // Collection to store all periods that need to be generated
      let periodsToGenerate: { startDate: Date, endDate: Date, dueDate: Date, compliancePeriod: string }[] = [];
      
      // We'll use the original compliance period as our starting reference
      // and incrementally calculate the next periods
      let currentReferenceDate = originalEndDate;
      
      // Generate sequence of periods from the original end date
      // up to the cutoff date (current date + lead days)
      console.log(`Generating periods starting after: ${format(currentReferenceDate, 'yyyy-MM-dd')}`);
      
      // Limit to 36 iterations to prevent infinite loops (covers 3 years of monthly tasks)
      for (let i = 0; i < 36; i++) {
        // Calculate the next period after the current reference date
        const nextPeriod = this.calculateNextCompliancePeriod(
          task.complianceFrequency,
          duration,
          currentReferenceDate
        );
        
        if (!nextPeriod) {
          console.log(`Could not calculate period after ${format(currentReferenceDate, 'yyyy-MM-dd')} for task ${task.id}`);
          break;
        }
        
        const { startDate, endDate, compliancePeriod } = nextPeriod;
        
        // Calculate due date (typically a few days before the end date)
        const dueDate = this.calculateDueDate(endDate);
        
        console.log(`Calculated period: ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}, Due: ${format(dueDate, 'yyyy-MM-dd')}`);
        
        // Stop generating if we've reached our cutoff date
        if (isAfter(startDate, cutoffDate)) {
          console.log(`Stopping at period starting ${format(startDate, 'yyyy-MM-dd')} - beyond cutoff date ${format(cutoffDate, 'yyyy-MM-dd')}`);
          break;
        }
        
        // Check if a task already exists for this period
        const periodExists = this.doesPeriodExist(task, startDate, endDate, existingTasks);
        
        if (!periodExists) {
          // Only add to generation queue if period doesn't already exist
          periodsToGenerate.push({ 
            startDate,
            endDate,
            dueDate,
            compliancePeriod
          });
          console.log(`Added period to generation queue: ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
        } else {
          console.log(`Period already exists - skipping: ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
        }
        
        // Move to the next period using the end date as our new reference
        currentReferenceDate = endDate;
      }
      
      // Generate tasks for all missing periods
      for (const period of periodsToGenerate) {
        const { startDate, endDate, dueDate, compliancePeriod } = period;
        await this.createRecurringTaskInstance(task, startDate, endDate, dueDate, compliancePeriod);
      }
      
      console.log(`Generated ${periodsToGenerate.length} tasks for task ${task.id}`);
    } catch (error) {
      console.error(`Error processing recurring task ${task.id}:`, error);
    }
  }
  
  /**
   * Check if a task already exists for a specific compliance period
   */
  private doesPeriodExist(task: Task, startDate: Date, endDate: Date, existingTasks: Task[]): boolean {
    // Convert dates to month/year format for easier comparison (e.g., "2025-05")
    const periodMonthYear = format(startDate, 'yyyy-MM');
    
    // Log the period we're checking
    console.log(`Checking if period ${periodMonthYear} exists for task type: ${task.isAdmin ? 'Admin' : 'Revenue'}, client: ${task.clientId}, entity: ${task.entityId}, service: ${task.serviceTypeId}`);
    
    return existingTasks.some(existingTask => {
      // Skip tasks without compliance dates
      if (!existingTask.complianceStartDate || !existingTask.complianceEndDate) {
        return false;
      }
      
      const existingStartDate = new Date(existingTask.complianceStartDate);
      const existingPeriodMonthYear = format(existingStartDate, 'yyyy-MM');
      
      // Match by month/year rather than exact date
      // This ensures we don't generate multiple tasks for the same month
      const periodMatch = existingPeriodMonthYear === periodMonthYear;
      
      if (!periodMatch) {
        return false;
      }
      
      // Check that other critical fields match to ensure it's truly a duplicate
      // for the same client, entity, service, and category
      const basicFieldsMatch = 
        existingTask.clientId === task.clientId &&
        existingTask.entityId === task.entityId &&
        existingTask.serviceTypeId === task.serviceTypeId &&
        existingTask.taskCategoryId === task.taskCategoryId;
      
      if (!basicFieldsMatch) {
        return false;
      }
      
      // Consider a period to exist if any of these conditions are true:
      const statusMatch = (
        // It's an auto-generated task waiting for approval
        (existingTask.isAutoGenerated && existingTask.needsApproval) ||
        // Or it's an approved auto-generated task (in history)
        (existingTask.isAutoGenerated && !existingTask.needsApproval) ||
        // Or it's a regular task for this period with a parent task ID matching our task
        (!existingTask.isAutoGenerated && existingTask.parentTaskId === task.id) ||
        // Or it's a regular task for this period with the same client, entity, service
        (!existingTask.isAutoGenerated && 
         existingTask.complianceFrequency === task.complianceFrequency &&
         existingTask.clientId === task.clientId &&
         existingTask.entityId === task.entityId &&
         existingTask.serviceTypeId === task.serviceTypeId)
      );
      
      if (statusMatch) {
        console.log(`Task already exists for period ${periodMonthYear} - Task ID: ${existingTask.id}, isAutoGenerated: ${existingTask.isAutoGenerated}, needsApproval: ${existingTask.needsApproval}`);
        return true;
      }
      
      return false;
    });
  }
  
  /**
   * Create a new instance of a recurring task for a specific period
   */
  private async createRecurringTaskInstance(
    templateTask: Task, 
    startDate: Date, 
    endDate: Date,
    dueDate: Date,
    compliancePeriod: string
  ): Promise<void> {
    try {
      // Ensure the dates are properly formatted with consistent time components
      // Start date: First day of month at 00:00:00
      const complianceStartDate = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
      complianceStartDate.setHours(0, 0, 0, 0);
      
      // End date: Last day of month at 23:59:59.999
      const complianceEndDate = new Date(endDate.getFullYear(), endDate.getMonth() + 1, 0);
      complianceEndDate.setHours(23, 59, 59, 999);
      
      // Format as month/year for logging and validation
      const periodMonthYear = format(complianceStartDate, 'yyyy-MM');
      console.log(`Formatted compliance period: ${format(complianceStartDate, 'yyyy-MM-dd')} to ${format(complianceEndDate, 'yyyy-MM-dd')}`);
      
      // First, check if a task already exists for this exact month/year to avoid duplication
      const existingTasks = await this.storage.getTasks(
        templateTask.tenantId,
        templateTask.clientId || undefined,
        templateTask.entityId || undefined
      );
      
      console.log(`Found ${existingTasks.length} existing tasks for tenant ${templateTask.tenantId}, client ${templateTask.clientId}, entity ${templateTask.entityId}`);
      
      // We need to check both auto-generated AND regular tasks to prevent duplicates
      const duplicateExists = existingTasks.some(task => {
        // Skip tasks without compliance dates
        if (!task.complianceStartDate) {
          return false;
        }
        
        // Get month/year for comparison
        const taskMonthYear = format(new Date(task.complianceStartDate), 'yyyy-MM');
        
        // Check if the months match
        const monthsMatch = taskMonthYear === periodMonthYear;
        if (!monthsMatch) {
          return false;
        }
        
        // Auto-generated task case - check for duplicate auto-generated tasks
        if (task.isAutoGenerated) {
          const autoGenMatch = 
            task.parentTaskId === templateTask.id && 
            task.serviceTypeId === templateTask.serviceTypeId &&
            task.clientId === templateTask.clientId && 
            task.entityId === templateTask.entityId;
            
          if (autoGenMatch) {
            console.log(`Found duplicate auto-generated task: ${task.id} for period ${taskMonthYear}`);
            return true;
          }
        }
        
        // Regular task case - check if a regular task already exists for this period
        if (!task.isAutoGenerated) {
          const regularTaskMatch = 
            task.serviceTypeId === templateTask.serviceTypeId &&
            task.clientId === templateTask.clientId && 
            task.entityId === templateTask.entityId &&
            task.complianceFrequency === templateTask.complianceFrequency;
            
          if (regularTaskMatch) {
            console.log(`Found existing regular task: ${task.id} for period ${taskMonthYear}`);
            return true;
          }
        }
        
        return false;
      });
      
      if (duplicateExists) {
        console.log(`Skipping generation for period ${periodMonthYear} - task already exists`);
        return;
      }
      
      // Find the "New" status for this tenant
      const statuses = await this.storage.getTaskStatuses(templateTask.tenantId);
      const newStatus = statuses.find(status => status.name.toLowerCase() === 'new' || status.rank === 1);
      
      if (!newStatus) {
        console.error(`No "New" status (rank 1) found for tenant ${templateTask.tenantId}`);
        return;
      }
      
      // Check if auto-approval setting is enabled
      const autoApproveTasksSetting = await this.storage.getTenantSetting(
        templateTask.tenantId, 
        "auto_approve_recurring_tasks"
      );
      
      const needsApproval = !autoApproveTasksSetting || 
                            autoApproveTasksSetting.value.toLowerCase() !== "true";
      
      // Set a descriptive task name based on the compliance period
      let taskDetails = templateTask.taskDetails || '';
      
      // If no task details exist, generate a default description
      if (!taskDetails) {
        const serviceName = templateTask.serviceTypeId 
          ? (await this.getServiceName(templateTask.tenantId, templateTask.serviceTypeId)) || 'Service'
          : 'Task';
        
        taskDetails = `${serviceName} - ${templateTask.complianceFrequency} compliance for period ${format(complianceStartDate, 'MMM yyyy')}`;
      }
      
      // Determine if this is a one-time task
      const isOneTime = templateTask.complianceFrequency?.toLowerCase() === 'one time' || 
                       templateTask.complianceFrequency?.toLowerCase() === 'once';
      
      // Prepare the new task data with careful handling of fields
      const newTaskData: InsertTask = {
        tenantId: templateTask.tenantId,
        isAdmin: templateTask.isAdmin,
        taskType: templateTask.taskType,
        // Handle optional foreign key references properly
        clientId: templateTask.clientId === null ? undefined : templateTask.clientId,
        entityId: templateTask.entityId === null ? undefined : templateTask.entityId,
        serviceTypeId: templateTask.serviceTypeId === null ? undefined : templateTask.serviceTypeId,
        taskCategoryId: templateTask.taskCategoryId === null ? undefined : templateTask.taskCategoryId,
        assigneeId: templateTask.assigneeId,
        // Use the calculated due date
        dueDate: dueDate,
        statusId: newStatus.id,
        // Use generated task details if original is empty
        taskDetails: taskDetails,
        nextToDo: templateTask.nextToDo || '',
        // Auto-generated tasks are never recurring themselves
        isRecurring: false,
        // Set compliance metadata with proper formatting
        complianceFrequency: templateTask.complianceFrequency || '',
        complianceYear: format(complianceStartDate, 'yyyy'),
        complianceDuration: templateTask.complianceDuration || '',
        // Use our properly formatted dates with standardized times
        complianceStartDate: complianceStartDate,
        complianceEndDate: complianceEndDate,
        // Use the formatted compliance period
        compliancePeriod: compliancePeriod,
        // Handle remaining optional fields
        currency: templateTask.currency || '',
        serviceRate: templateTask.serviceRate || 0,
        // Important metadata for tracking
        isAutoGenerated: true,
        parentTaskId: templateTask.id,
        needsApproval: needsApproval,
      };
      
      console.log('Creating auto-generated task with data:', JSON.stringify({
        ...newTaskData,
        complianceStartDate: format(complianceStartDate, 'yyyy-MM-dd'),
        complianceEndDate: format(complianceEndDate, 'yyyy-MM-dd'),
        dueDate: format(dueDate, 'yyyy-MM-dd'),
      }, null, 2));
      
      // Create the new task
      const newTaskId = await this.storage.createTask(newTaskData);
      console.log(`Created recurring task instance ID ${newTaskId} for period ${format(complianceStartDate, 'yyyy-MM-dd')} to ${format(complianceEndDate, 'yyyy-MM-dd')} ${needsApproval ? '(needs approval)' : '(auto-approved)'}`);
    } catch (error) {
      console.error("Error in createRecurringTaskInstance:", error);
    }
  }
  
  /**
   * Retrieve service name for better task descriptions
   */
  private async getServiceName(tenantId: number, serviceTypeId: number): Promise<string | undefined> {
    try {
      const service = await this.storage.getServiceType(serviceTypeId, tenantId);
      return service?.name;
    } catch (error) {
      console.error("Error fetching service name:", error);
      return undefined;
    }
  }
  
  /**
   * Get all tasks that need approval (generated tasks marked as needing approval)
   */
  public async getTasksNeedingApproval(tenantId: number): Promise<Task[]> {
    try {
      const allTasks = await this.storage.getTasks(tenantId);
      return allTasks.filter(task => task.isAutoGenerated && task.needsApproval);
    } catch (error) {
      console.error("Error fetching tasks needing approval:", error);
      return [];
    }
  }
  
  /**
   * Get task history (previously approved auto-generated tasks)
   */
  public async getTaskHistory(tenantId: number): Promise<Task[]> {
    try {
      const allTasks = await this.storage.getTasks(tenantId);
      return allTasks.filter(task => 
        task.isAutoGenerated && 
        !task.needsApproval && 
        task.parentTaskId !== null
      );
    } catch (error) {
      console.error("Error fetching task history:", error);
      return [];
    }
  }
  
  /**
   * Approve a generated task (remove approval flag)
   * When approved, creates a regular task in the Tasks module,
   * marks the original parent task as non-recurring, and only
   * sets the most recent task's recurring flag to true
   */
  public async approveTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated || !task.needsApproval) {
        console.log(`Task ${taskId} not eligible for approval (Not auto-generated or not needing approval)`);
        return false;
      }
      
      console.log(`Approving auto-generated task ${taskId} for tenant ${tenantId}`);
      console.log(`Task details: client: ${task.clientId}, entity: ${task.entityId}, service: ${task.serviceTypeId}, frequency: ${task.complianceFrequency}`);
      
      if (task.complianceStartDate && task.complianceEndDate) {
        console.log(`Compliance period: ${format(new Date(task.complianceStartDate), 'yyyy-MM-dd')} to ${format(new Date(task.complianceEndDate), 'yyyy-MM-dd')}`);
      }
      
      // First, update the auto-generated task to no longer need approval
      const update = {
        needsApproval: false,
        updatedAt: new Date() // Set updatedAt to track when the task was approved
      };
      
      const updated = await this.storage.updateTask(taskId, update);
      
      if (!updated) {
        console.log(`Failed to update task ${taskId} approval status`);
        return false;
      }
      
      // Check if a task for this period already exists in the main Tasks module
      // Do a thorough check to really prevent duplicate tasks
      const existingTasks = await this.storage.getTasks(
        task.tenantId,
        task.clientId || undefined,
        task.entityId || undefined
      );
      
      console.log(`Found ${existingTasks.length} existing tasks for client ${task.clientId}, entity ${task.entityId}`);
      
      // Get the month/year for the current task's compliance period (for comparison)
      const taskPeriodMonthYear = task.complianceStartDate 
        ? format(new Date(task.complianceStartDate), 'yyyy-MM') 
        : null;
        
      if (taskPeriodMonthYear) {
        console.log(`Task period is ${taskPeriodMonthYear}`);
      }
      
      // Check for any regular tasks with this task as parent OR with matching period/details
      const regularTaskExists = existingTasks.some(existingTask => {
        // Skip auto-generated tasks in comparison
        if (existingTask.isAutoGenerated) {
          return false;
        }
        
        // Log existing task details for debugging
        console.log(`Checking existing task ${existingTask.id}: parentTaskId: ${existingTask.parentTaskId}, isAutoGenerated: ${existingTask.isAutoGenerated}`);
        
        // If there's a direct parent relationship (task being approved is the parent)
        if (existingTask.parentTaskId === task.id) {
          console.log(`Found existing regular task (parent link): ${existingTask.id}`);
          return true;
        }
        
        // Only compare tasks with compliance dates
        if (!existingTask.complianceStartDate || !task.complianceStartDate) {
          return false;
        }
        
        // Check if it has the same compliance period and other key details
        const fieldsMatch = 
            existingTask.clientId === task.clientId &&
            existingTask.entityId === task.entityId &&
            existingTask.serviceTypeId === task.serviceTypeId &&
            existingTask.taskCategoryId === task.taskCategoryId;
            
        if (!fieldsMatch) {
          return false;
        }
        
        // Compare the month/year for the compliance periods
        const existingPeriodMonthYear = format(new Date(existingTask.complianceStartDate), 'yyyy-MM');
        
        if (existingPeriodMonthYear === taskPeriodMonthYear) {
          console.log(`Found existing regular task (matching period ${existingPeriodMonthYear}): ${existingTask.id}`);
          return true;
        }
        
        return false;
      });
      
      // Don't create a new task if one already exists for this approved task
      if (regularTaskExists) {
        console.log(`Regular task already exists for auto-generated task ${task.id}. Not creating duplicate.`);
        return true;
      }
      
      console.log(`Creating new regular task for approved auto-generated task ${task.id}`);
      
      // Properly format compliance dates for the regular task with proper month end date
      // This is critical to ensure consistency between auto-generated and regular tasks
      let startDate: Date | undefined;
      let endDate: Date | undefined;
      
      if (task.complianceStartDate) {
        try {
          // Get year and month from the start date
          const startObj = new Date(task.complianceStartDate);
          const year = startObj.getFullYear();
          const month = startObj.getMonth();
          
          // First day of month at 00:00:00
          startDate = new Date(year, month, 1);
          startDate.setHours(0, 0, 0, 0);
          
          console.log(`Original start date: ${new Date(task.complianceStartDate).toISOString()}`);
          console.log(`Formatted start date: ${startDate.toISOString()}`);
        } catch (error) {
          console.error(`Error formatting start date: ${error}`);
          // Fallback to original date if there's an error
          startDate = new Date(task.complianceStartDate);
        }
      }
      
      if (task.complianceEndDate) {
        try {
          // Get year and month from the end date
          const endObj = new Date(task.complianceEndDate);
          const year = endObj.getFullYear();
          const month = endObj.getMonth();
          
          // Last day of month: new Date(year, month + 1, 0)
          endDate = new Date(year, month + 1, 0);
          endDate.setHours(23, 59, 59, 999);
          
          console.log(`Original end date: ${new Date(task.complianceEndDate).toISOString()}`);
          console.log(`Formatted end date: ${endDate.toISOString()} (last day of month)`);
        } catch (error) {
          console.error(`Error formatting end date: ${error}`);
          // Fallback to original date if there's an error
          endDate = new Date(task.complianceEndDate);
        }
      }
      
      // Check if this is a one-time task
      const isOneTime = task.complianceFrequency?.toLowerCase() === 'one time' || 
                       task.complianceFrequency?.toLowerCase() === 'once';
      
      // IMPORTANT: Determine if this is the latest compliance period for this task
      // We should gather all auto-generated tasks for the same parent and compare dates
      // Only the latest period should have isRecurring set to true
      let isLatestCompliancePeriod = true;
      
      if (task.parentTaskId) {
        // Find the original parent task
        const originalParentId = task.parentTaskId;
        
        // Find all auto-generated tasks for the same original parent
        const siblingTasks = existingTasks.filter(existingTask => 
          existingTask.isAutoGenerated && 
          existingTask.parentTaskId === originalParentId && 
          existingTask.id !== task.id
        );
        
        // Check if any sibling has a later compliance period
        if (task.complianceEndDate) {
          const taskEndDate = new Date(task.complianceEndDate);
          
          for (const sibling of siblingTasks) {
            if (sibling.complianceEndDate) {
              const siblingEndDate = new Date(sibling.complianceEndDate);
              
              if (siblingEndDate > taskEndDate) {
                // Found a sibling with a later compliance period
                isLatestCompliancePeriod = false;
                console.log(`This task (period ending ${format(taskEndDate, 'yyyy-MM-dd')}) is not the latest - found newer period: ${format(siblingEndDate, 'yyyy-MM-dd')}`);
                break;
              }
            }
          }
        }
      } 
      
      console.log(`This task is${isLatestCompliancePeriod ? '' : ' not'} the latest compliance period`);
      
      // Prepare data for the regular task with careful handling of optional fields
      // This ensures all fields are properly transferred from auto-generated to regular task
      const regularTaskData: InsertTask = {
        tenantId: task.tenantId,
        isAdmin: task.isAdmin,
        taskType: task.taskType,
        // Handle optional foreign key references properly
        clientId: task.clientId === null ? undefined : task.clientId,
        entityId: task.entityId === null ? undefined : task.entityId,
        serviceTypeId: task.serviceTypeId === null ? undefined : task.serviceTypeId,
        taskCategoryId: task.taskCategoryId === null ? undefined : task.taskCategoryId,
        assigneeId: task.assigneeId,
        // Ensure dates are properly handled as Date objects
        dueDate: new Date(task.dueDate), 
        statusId: task.statusId,
        // Handle text fields with empty string fallbacks
        taskDetails: task.taskDetails || '',
        nextToDo: task.nextToDo || '',
        // IMPORTANT: Only the latest period should be recurring
        // This is a key change to meet the requirements
        isRecurring: !isOneTime && isLatestCompliancePeriod,
        // Handle compliance fields
        complianceFrequency: task.complianceFrequency || '',
        complianceYear: task.complianceYear || '',
        complianceDuration: task.complianceDuration || '',
        // Use our properly formatted dates with standardized month start/end
        complianceStartDate: startDate,
        complianceEndDate: endDate,
        // Transfer the compliance period for consistent representation
        compliancePeriod: task.compliancePeriod || '',
        // Handle remaining fields
        currency: task.currency || '',
        serviceRate: task.serviceRate || 0,
        // Important metadata for tracking
        isAutoGenerated: false, // This is now a regular task
        parentTaskId: task.parentTaskId, // Link to the ORIGINAL parent
        needsApproval: false, // Regular tasks don't need approval
        // Set creation metadata
        updatedAt: new Date(), // Set initial updatedAt timestamp
      };
      
      console.log('Creating regular task with data:', JSON.stringify(regularTaskData, null, 2));
      
      try {
        const newTaskId = await this.storage.createTask(regularTaskData);
        console.log(`Created regular task ID ${newTaskId} for approved auto-generated task ${task.id}`);
        
        // If this task is the latest for its period, we need to set the original parent task's
        // isRecurring flag to false, as only the newest approved task should be recurring
        if (isLatestCompliancePeriod && task.parentTaskId) {
          console.log(`This is the latest compliance period - setting original parent task ${task.parentTaskId} to non-recurring`);
          
          // Update the original parent task to be non-recurring
          await this.storage.updateTask(task.parentTaskId, {
            isRecurring: false,
            updatedAt: new Date()
          });
        }
      } catch (error) {
        console.error(`Error creating regular task: ${error}`);
        return false;
      }
      
      return true;
    } catch (error) {
      console.error("Error approving task:", error);
      return false;
    }
  }
  
  /**
   * Approve all pending tasks for a tenant
   */
  public async approveAllPendingTasks(tenantId: number): Promise<number> {
    try {
      const pendingTasks = await this.getTasksNeedingApproval(tenantId);
      let approvedCount = 0;
      
      for (const task of pendingTasks) {
        const approved = await this.approveTask(task.id, tenantId);
        if (approved) {
          approvedCount++;
        }
      }
      
      return approvedCount;
    } catch (error) {
      console.error("Error approving all pending tasks:", error);
      return 0;
    }
  }
  
  /**
   * Reject a generated task (delete it)
   */
  public async rejectTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated || !task.needsApproval) {
        return false;
      }
      
      return await this.storage.deleteTask(taskId, tenantId);
    } catch (error) {
      console.error("Error rejecting task:", error);
      return false;
    }
  }
  
  /**
   * Set a task to active (sets activatedAt timestamp)
   */
  public async activateTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated) {
        return false;
      }
      
      // Get the "In Progress" status for this tenant
      const statuses = await this.storage.getTaskStatuses(tenantId);
      const inProgressStatus = statuses.find(status => status.name.toLowerCase().includes('progress') || status.rank === 2);
      
      if (!inProgressStatus) {
        console.error(`No suitable "In Progress" status found for tenant ${tenantId}`);
        return false;
      }
      
      // Update the task to be active
      const update = {
        activatedAt: new Date(),
        statusId: inProgressStatus.id,
        updatedAt: new Date() // Set updatedAt to track status change
      };
      
      const updated = await this.storage.updateTask(taskId, update);
      return !!updated;
    } catch (error) {
      console.error("Error activating task:", error);
      return false;
    }
  }
  
  /**
   * Cancel a task (sets isCanceled flag and canceledAt timestamp)
   */
  public async cancelTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated) {
        return false;
      }
      
      // Update the task to be canceled
      const update = {
        isCanceled: true,
        canceledAt: new Date(),
        updatedAt: new Date() // Set updatedAt to track when the task was canceled
      };
      
      const updated = await this.storage.updateTask(taskId, update);
      return !!updated;
    } catch (error) {
      console.error("Error canceling task:", error);
      return false;
    }
  }
  
  /**
   * Resume a previously canceled task
   */
  public async resumeTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated || !task.isCanceled) {
        return false;
      }
      
      // Get the "In Progress" status for this tenant
      const statuses = await this.storage.getTaskStatuses(tenantId);
      const inProgressStatus = statuses.find(status => status.name.toLowerCase().includes('progress') || status.rank === 2);
      
      if (!inProgressStatus) {
        console.error(`No suitable "In Progress" status found for tenant ${tenantId}`);
        return false;
      }
      
      // Update the task to be no longer canceled and change its status
      const update = {
        isCanceled: false,
        canceledAt: undefined, // Use undefined instead of null for Date field
        activatedAt: new Date(),
        statusId: inProgressStatus.id,
        updatedAt: new Date() // Set updatedAt to track status change
      };
      
      const updated = await this.storage.updateTask(taskId, update);
      return !!updated;
    } catch (error) {
      console.error("Error resuming task:", error);
      return false;
    }
  }
  
  /**
   * Permanently delete a task
   */
  public async deleteTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated) {
        return false;
      }
      
      // Delete the task
      return await this.storage.deleteTask(taskId, tenantId);
    } catch (error) {
      console.error("Error deleting task:", error);
      return false;
    }
  }
  
  /**
   * Calculate the next compliance period based on frequency and duration
   * Handles all compliance frequencies including:
   * - Monthly
   * - Bi Monthly
   * - Quarterly
   * - Semi Annual
   * - Annual
   * - 2 Years
   * - 3 Years
   * - 4 Years
   * - 5 Years
   */
  private calculateNextCompliancePeriod(
    frequency?: string, 
    duration?: string,
    referenceDate?: Date
  ): { startDate: Date; endDate: Date; compliancePeriod: string } | null {
    if (!frequency || !referenceDate) {
      console.log('Missing required parameters for calculating next period');
      return null;
    }
    
    try {
      // Normalize the frequency string for consistent matching
      const freq = frequency.toLowerCase().trim();
      const refYear = referenceDate.getFullYear();
      const refMonth = referenceDate.getMonth();
      
      console.log(`Calculating next period for frequency: ${frequency}, duration: ${duration || ''}, reference date: ${format(referenceDate, 'yyyy-MM-dd')}`);
      
      let startDate: Date;
      let endDate: Date;
      let compliancePeriod: string = '';
      
      // MONTHLY frequency
      if (freq === 'monthly' || freq.includes('month')) {
        // Get the next month after the reference date
        let nextMonth = refMonth + 1;
        let nextYear = refYear;
        
        // Handle year rollover if needed
        if (nextMonth > 11) {
          nextMonth = 0; // January
          nextYear += 1;
        }
        
        // First day of next month
        startDate = new Date(nextYear, nextMonth, 1);
        startDate.setHours(0, 0, 0, 0);
        
        // Last day of next month
        endDate = new Date(nextYear, nextMonth + 1, 0);
        endDate.setHours(23, 59, 59, 999);
        
        // Format as "May 2025" for monthly period
        compliancePeriod = format(startDate, 'MMMM yyyy');
        
        console.log(`Monthly: Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // BI-MONTHLY frequency
      else if ((freq.includes('bi') || freq.includes('bi-')) && freq.includes('month')) {
        // Calculate the next bi-monthly period (2 months)
        let nextMonth = refMonth + 1;
        let nextYear = refYear;
        
        // Handle year rollover
        if (nextMonth > 11) {
          nextMonth = 0;
          nextYear += 1;
        }
        
        // First day of first month in bi-monthly period
        startDate = new Date(nextYear, nextMonth, 1);
        startDate.setHours(0, 0, 0, 0);
        
        // Calculate the end month (1 month after start month)
        let endMonth = nextMonth + 1;
        let endYear = nextYear;
        
        // Handle year rollover
        if (endMonth > 11) {
          endMonth = 0;
          endYear += 1;
        }
        
        // Last day of second month in bi-monthly period
        endDate = new Date(endYear, endMonth + 1, 0);
        endDate.setHours(23, 59, 59, 999);
        
        console.log(`Bi-Monthly: Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // QUARTERLY frequency
      else if (freq.includes('quarter')) {
        // Current quarter (0-3)
        const currQuarter = Math.floor(refMonth / 3);
        
        // Next quarter (0-3)
        const nextQuarter = (currQuarter + 1) % 4;
        
        // Increment year if moving from Q4 to Q1
        const nextYear = (currQuarter === 3) ? refYear + 1 : refYear;
        
        // Calculate start month (0, 3, 6, or 9)
        const startMonth = nextQuarter * 3;
        
        // First day of first month in quarter
        startDate = new Date(nextYear, startMonth, 1);
        startDate.setHours(0, 0, 0, 0);
        
        // Last day of third month in quarter
        endDate = new Date(nextYear, startMonth + 3, 0);
        endDate.setHours(23, 59, 59, 999);
        
        console.log(`Quarterly: Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // SEMI-ANNUAL frequency
      else if ((freq.includes('semi') && freq.includes('annual')) || 
               freq.includes('half') && freq.includes('year')) {
        // Current half (0 = Jan-Jun, 1 = Jul-Dec)
        const currHalf = refMonth < 6 ? 0 : 1;
        
        // Next half (toggle between 0 and 1)
        const nextHalf = (currHalf + 1) % 2;
        
        // Increment year if moving from second half to first half
        const nextYear = (nextHalf === 0) ? refYear + 1 : refYear;
        
        // Start month is January (0) or July (6)
        const startMonth = nextHalf * 6;
        
        // First day of first month in half-year
        startDate = new Date(nextYear, startMonth, 1);
        startDate.setHours(0, 0, 0, 0);
        
        // Last day of sixth month in half-year
        endDate = new Date(nextYear, startMonth + 6, 0);
        endDate.setHours(23, 59, 59, 999);
        
        console.log(`Semi-Annual: Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // ANNUAL frequency
      else if (freq.includes('annual') || freq.includes('year') && 
               !freq.includes('2') && !freq.includes('3') && 
               !freq.includes('4') && !freq.includes('5')) {
        // For annual periods, add one year to the reference year
        
        // Check for fiscal year (if specified in duration)
        if (duration && (duration.toLowerCase() === 'fy' || 
                         duration.toLowerCase().includes('fiscal'))) {
          // Assuming fiscal year starts in July (month 6)
          // This can be customized based on requirements
          
          // Determine current fiscal year
          const currFiscalYear = (refMonth >= 6) ? refYear : refYear - 1;
          
          // Next fiscal year
          const nextFiscalYear = currFiscalYear + 1;
          
          // First day of fiscal year (July 1)
          startDate = new Date(nextFiscalYear, 6, 1);
          startDate.setHours(0, 0, 0, 0);
          
          // Last day of fiscal year (June 30)
          endDate = new Date(nextFiscalYear + 1, 5, 30);
          endDate.setHours(23, 59, 59, 999);
          
          console.log(`Annual (Fiscal Year): Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
        } else {
          // Standard calendar year
          
          // First day of next year
          startDate = new Date(refYear + 1, 0, 1);
          startDate.setHours(0, 0, 0, 0);
          
          // Last day of next year
          endDate = new Date(refYear + 1, 11, 31);
          endDate.setHours(23, 59, 59, 999);
          
          console.log(`Annual (Calendar Year): Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
        }
      }
      
      // 2 YEARS frequency
      else if (freq.includes('2') && freq.includes('year')) {
        // First day of next 2-year period
        startDate = new Date(refYear + 1, 0, 1);
        startDate.setHours(0, 0, 0, 0);
        
        // Last day of next 2-year period
        endDate = new Date(refYear + 2, 11, 31);
        endDate.setHours(23, 59, 59, 999);
        
        console.log(`2 Years: Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // 3 YEARS frequency
      else if (freq.includes('3') && freq.includes('year')) {
        // First day of next 3-year period
        startDate = new Date(refYear + 1, 0, 1);
        startDate.setHours(0, 0, 0, 0);
        
        // Last day of next 3-year period
        endDate = new Date(refYear + 3, 11, 31);
        endDate.setHours(23, 59, 59, 999);
        
        console.log(`3 Years: Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // 4 YEARS frequency
      else if (freq.includes('4') && freq.includes('year')) {
        // First day of next 4-year period
        startDate = new Date(refYear + 1, 0, 1);
        startDate.setHours(0, 0, 0, 0);
        
        // Last day of next 4-year period
        endDate = new Date(refYear + 4, 11, 31);
        endDate.setHours(23, 59, 59, 999);
        
        console.log(`4 Years: Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // 5 YEARS frequency
      else if (freq.includes('5') && freq.includes('year')) {
        // First day of next 5-year period
        startDate = new Date(refYear + 1, 0, 1);
        startDate.setHours(0, 0, 0, 0);
        
        // Last day of next 5-year period
        endDate = new Date(refYear + 5, 11, 31);
        endDate.setHours(23, 59, 59, 999);
        
        console.log(`5 Years: Next period is ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // Unsupported frequency
      else {
        console.warn(`Unsupported frequency: ${frequency}`);
        return null;
      }
      
      // Make sure our resulting period is after the reference date
      if (startDate <= referenceDate) {
        console.warn(`Calculated start date (${format(startDate, 'yyyy-MM-dd')}) is not after reference date (${format(referenceDate, 'yyyy-MM-dd')})`);
        
        // Force to the next appropriate period
        if (freq === 'monthly' || freq.includes('month')) {
          startDate = addMonths(startOfMonth(referenceDate), 1);
          endDate = endOfMonth(startDate);
          endDate.setHours(23, 59, 59, 999);
        } else {
          // For other frequencies, add one day to reference date as fallback
          startDate = addDays(referenceDate, 1);
          startDate.setHours(0, 0, 0, 0);
          endDate = addMonths(startDate, 1);
          endDate.setHours(23, 59, 59, 999);
        }
        
        console.log(`Corrected period: ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
      }
      
      // If compliancePeriod wasn't set in any of the specific frequency cases,
      // create a default format based on the startDate
      if (!compliancePeriod && startDate) {
        compliancePeriod = format(startDate, 'MMMM yyyy');
      }
      
      return { startDate, endDate, compliancePeriod };
    } catch (error) {
      console.error(`Error calculating next compliance period: ${error}`);
      return null;
    }
  }
  
  /**
   * Calculate due date (typically end of period or slightly before)
   */
  private calculateDueDate(endDate: Date): Date {
    // Due date is typically a few days before the end of the period
    // This can be customized based on business rules
    return subDays(endDate, 5);
  }
  
  /**
   * Helper to get all tenants from storage
   */
  private async getAllTenants(): Promise<Tenant[]> {
    // This is a simplification - in a real implementation,
    // we would need a method to retrieve all tenants
    const result: Tenant[] = [];
    
    // Start with tenant ID 1 and try incrementing
    // This is a workaround since our storage interface doesn't
    // provide a way to get all tenants
    for (let i = 1; i <= 100; i++) {
      try {
        const tenant = await this.storage.getTenant(i);
        if (tenant) {
          result.push(tenant);
        }
      } catch (error) {
        // Ignore errors, just try the next tenant ID
      }
    }
    
    return result;
  }
}

// Helper type for Tenant since we're using it internally
interface Tenant {
  id: number;
  name: string;
  createdAt: Date;
}