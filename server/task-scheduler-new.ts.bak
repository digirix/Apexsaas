import { IStorage } from "./storage";
import { Task, InsertTask } from "@shared/schema";
import { 
  addMonths, addDays, format, 
  startOfMonth, endOfMonth, 
  subDays, isAfter,
  addYears
} from "date-fns";

const DEFAULT_LEAD_DAYS = 14; // Default lead time for generating recurring tasks

/**
 * Improved TaskScheduler is responsible for generating recurring tasks
 * based on their frequency and compliance periods
 * 
 * This version includes a completely rewritten approach to handling
 * task approvals to ensure only the specific approved task instance
 * is converted to a regular task.
 */
export class TaskScheduler {
  private storage: IStorage;
  private leadDaysOverride: number | null;
  
  constructor(storage: IStorage, leadDaysOverride: number | null = null) {
    this.storage = storage;
    this.leadDaysOverride = leadDaysOverride;
  }
  
  /**
   * Generate upcoming recurring tasks for all tenants
   * This should be run periodically (e.g., daily) to create tasks for upcoming periods
   */
  public async generateUpcomingRecurringTasks(): Promise<void> {
    try {
      // Get all tenants
      const tenants = await this.storage.getTenants();
      
      for (const tenant of tenants) {
        await this.generateRecurringTasksForTenant(tenant.id);
      }
      
      console.log(`Recurring task generation completed for ${tenants.length} tenants`);
    } catch (error) {
      console.error("Error generating recurring tasks:", error);
    }
  }
  
  /**
   * Generate recurring tasks for a specific tenant
   */
  public async generateRecurringTasksForTenant(tenantId: number): Promise<void> {
    try {
      // Get tenant-specific settings for lead days
      const leadDaysSetting = await this.storage.getTenantSetting(
        tenantId,
        "recurring_task_lead_days"
      );
      
      // Use tenant setting, override, or default
      const leadDays = this.leadDaysOverride !== null
        ? this.leadDaysOverride
        : (leadDaysSetting?.value ? parseInt(leadDaysSetting.value, 10) : DEFAULT_LEAD_DAYS);
      
      console.log(`Using configured lead days: ${leadDays} for tenant ${tenantId}`);
      
      // Find all recurring tasks for this tenant that haven't been canceled
      const allTasks = await this.storage.getTasks(tenantId);
      const recurringTasks = allTasks.filter(task => 
        task.isRecurring && 
        !task.isCanceled && 
        !task.isAutoGenerated
      );
      
      console.log(`Found ${recurringTasks.length} recurring tasks for tenant ${tenantId}`);
      
      // Process each recurring task
      for (const task of recurringTasks) {
        await this.processRecurringTask(task, leadDays);
      }
      
      console.log(`Generated recurring tasks for tenant ${tenantId}`);
    } catch (error) {
      console.error(`Error generating recurring tasks for tenant ${tenantId}:`, error);
    }
  }
  
  /**
   * Get tasks that need approval
   */
  public async getTasksNeedingApproval(tenantId: number): Promise<Task[]> {
    try {
      const allTasks = await this.storage.getTasks(tenantId);
      
      // We want to show only auto-generated tasks that still need approval (needsApproval flag)
      // and are flagged as auto-generated
      const tasksNeedingApproval = allTasks.filter(task => {
        // We must have an explicit check for both flags to be true
        const isAutoGenerated = task.isAutoGenerated === true;
        const needsApproval = task.needsApproval === true;
        
        if (isAutoGenerated && needsApproval) {
          return true;
        }
        return false;
      });
      
      console.log(`Found ${tasksNeedingApproval.length} tasks needing approval out of ${allTasks.length} total tasks`);
      return tasksNeedingApproval;
    } catch (error) {
      console.error("Error fetching tasks needing approval:", error);
      return [];
    }
  }
  
  /**
   * Get task history (previously approved auto-generated tasks)
   */
  public async getTaskHistory(tenantId: number): Promise<Task[]> {
    try {
      const allTasks = await this.storage.getTasks(tenantId);
      
      // We want to show only auto-generated tasks that have already been approved
      // but are still flagged as auto-generated
      const historicalTasks = allTasks.filter(task => {
        // Task must be explicitly flagged as auto-generated
        const isAutoGenerated = task.isAutoGenerated === true;
        
        // Task must NOT need approval anymore (it's been processed)
        const doesNotNeedApproval = task.needsApproval === false;
        
        // Task should have a parent task ID to be part of a recurring series
        const hasParentTask = task.parentTaskId !== null && task.parentTaskId !== undefined;
        
        return isAutoGenerated && doesNotNeedApproval && hasParentTask;
      });
      
      console.log(`Found ${historicalTasks.length} historical tasks out of ${allTasks.length} total tasks`);
      return historicalTasks;
    } catch (error) {
      console.error("Error fetching task history:", error);
      return [];
    }
  }
  
  /**
   * Approve a specific auto-generated task and convert it to a regular task
   * 
   * This is a completely rewritten implementation that ensures:
   * 1. Only the specific approved task (by ID) is moved to the Tasks Module
   * 2. Multiple instances of the same template task are handled correctly
   * 3. The approved task is properly tracked in the database
   */
  public async approveTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      // Step 1: Get the specific auto-generated task by its ID
      const task = await this.storage.getTask(taskId, tenantId);
      
      // Basic validation
      if (!task) {
        console.log(`Task ${taskId} not found for tenant ${tenantId}`);
        return false;
      }
      
      if (!task.isAutoGenerated) {
        console.log(`Task ${taskId} is not an auto-generated task`);
        return false;
      }
      
      if (!task.needsApproval) {
        console.log(`Task ${taskId} does not need approval (already processed)`);
        return false;
      }
      
      console.log(`Processing approval for auto-generated task ${taskId}`);
      console.log(`Task details: client: ${task.clientId}, entity: ${task.entityId}, service: ${task.serviceTypeId}, frequency: ${task.complianceFrequency}`);
      
      if (task.complianceStartDate && task.complianceEndDate) {
        console.log(`Compliance period: ${format(new Date(task.complianceStartDate), 'yyyy-MM-dd')} to ${format(new Date(task.complianceEndDate), 'yyyy-MM-dd')}`);
      }
      
      // Step 2: Check if a regular task already exists for this specific auto-generated task
      // We only match by the exact auto-generated task ID to ensure we only process this specific task
      const existingTasks = await this.storage.getTasks(tenantId);
      const regularTaskExists = existingTasks.some(existingTask => 
        !existingTask.isAutoGenerated && existingTask.parentTaskId === task.id
      );
      
      if (regularTaskExists) {
        console.log(`Regular task already exists for auto-generated task ${task.id}. Not creating duplicate.`);
        
        // Just update the auto-generated task to no longer need approval
        await this.storage.updateTask(taskId, {
          needsApproval: false,
          updatedAt: new Date()
        });
        
        return true;
      }
      
      // Step 3: Determine if this is the latest compliance period
      // This is important for setting the isRecurring flag correctly
      let isLatestCompliancePeriod = true;
      
      if (task.parentTaskId && task.complianceEndDate) {
        const currentTaskEndDate = new Date(task.complianceEndDate);
        
        // Find all sibling auto-generated tasks that share the same parent
        const siblingTasks = existingTasks.filter(existingTask => 
          existingTask.isAutoGenerated && 
          existingTask.parentTaskId === task.parentTaskId &&
          existingTask.clientId === task.clientId &&
          existingTask.entityId === task.entityId &&
          existingTask.serviceTypeId === task.serviceTypeId &&
          existingTask.id !== task.id // Exclude the current task
        );
        
        // Check if any sibling has a later compliance period
        for (const sibling of siblingTasks) {
          if (sibling.complianceEndDate) {
            const siblingEndDate = new Date(sibling.complianceEndDate);
            
            if (siblingEndDate > currentTaskEndDate) {
              isLatestCompliancePeriod = false;
              console.log(`This task (period ending ${format(currentTaskEndDate, 'yyyy-MM-dd')}) is not the latest - found newer period: ${format(siblingEndDate, 'yyyy-MM-dd')}`);
              break;
            }
          }
        }
      }
      
      console.log(`This task is${isLatestCompliancePeriod ? '' : ' not'} the latest compliance period`);
      
      // Step 4: Fix compliance end date to always be last day of month at 23:59:59.999
      let fixedComplianceEndDate: Date | undefined = undefined;
      
      if (task.complianceStartDate) {
        const startDate = new Date(task.complianceStartDate);
        const frequency = task.complianceFrequency?.toLowerCase() || '';
        
        // Calculate the end date based on the frequency
        let endDate: Date;
        
        if (frequency.includes('quarterly')) {
          // For quarterly, get the last day of the last month in the quarter
          const quarterStartMonth = Math.floor(startDate.getMonth() / 3) * 3;
          const lastMonthInQuarter = quarterStartMonth + 2;
          endDate = new Date(startDate.getFullYear(), lastMonthInQuarter + 1, 0);
        } else if (frequency.includes('annual') || frequency.includes('yearly')) {
          // For annual, get December 31st of the year
          endDate = new Date(startDate.getFullYear(), 11, 31);
        } else {
          // For monthly or others, get the last day of the month
          endDate = endOfMonth(startDate);
        }
        
        // Set the time to 23:59:59.999
        endDate.setHours(23, 59, 59, 999);
        fixedComplianceEndDate = endDate;
        
        console.log(`Fixed compliance end date: ${format(fixedComplianceEndDate, 'yyyy-MM-dd HH:mm:ss.SSS')}`);
      }
      
      // Step 5: Update the auto-generated task to mark it as processed but KEEP it as auto-generated
      // This is critical - we're just changing needsApproval flag, NOT converting it to a regular task
      const updateData: any = {
        needsApproval: false,
        updatedAt: new Date()
      };
      
      if (fixedComplianceEndDate) {
        updateData.complianceEndDate = fixedComplianceEndDate;
      }
      
      console.log(`Updating auto-generated task ${taskId} with data:`, JSON.stringify(updateData, null, 2));
      await this.storage.updateTask(taskId, updateData);
      
      // Step 6: Create a NEW regular task as a copy of the auto-generated task
      // Check if this is a one-time task first
      const isOneTime = task.complianceFrequency?.toLowerCase() === 'one time' || 
                       task.complianceFrequency?.toLowerCase() === 'once';
      
      // Create the new task with all required fields
      const newTaskData: any = {
        tenantId: task.tenantId,
        isAdmin: task.isAdmin || false,
        taskType: task.taskType || 'Regular',
        assigneeId: task.assigneeId,
        dueDate: task.dueDate,
        statusId: task.statusId,
        taskDetails: task.taskDetails || '',
        nextToDo: task.nextToDo || '',
        isRecurring: !isOneTime && isLatestCompliancePeriod, // Only the latest task should be recurring
        isAutoGenerated: false, // This makes it a regular task
        parentTaskId: task.id, // Link to the specific auto-generated task that was approved
        needsApproval: false // Regular tasks never need approval
      };
      
      // Copy optional fields only if they exist
      if (task.clientId !== undefined) newTaskData.clientId = task.clientId;
      if (task.entityId !== undefined) newTaskData.entityId = task.entityId;
      if (task.serviceTypeId !== undefined) newTaskData.serviceTypeId = task.serviceTypeId;
      if (task.taskCategoryId !== undefined) newTaskData.taskCategoryId = task.taskCategoryId;
      if (task.complianceFrequency) newTaskData.complianceFrequency = task.complianceFrequency;
      if (task.complianceYear) newTaskData.complianceYear = task.complianceYear;
      if (task.complianceDuration) newTaskData.complianceDuration = task.complianceDuration;
      if (task.compliancePeriod) newTaskData.compliancePeriod = task.compliancePeriod;
      
      // Use the fixed compliance dates when available
      if (task.complianceStartDate) {
        newTaskData.complianceStartDate = task.complianceStartDate;
      }
      if (fixedComplianceEndDate) {
        newTaskData.complianceEndDate = fixedComplianceEndDate;
      } else if (task.complianceEndDate) {
        newTaskData.complianceEndDate = task.complianceEndDate;
      }
      
      // Add remaining optional fields
      if (task.currency) newTaskData.currency = task.currency;
      if (task.serviceRate) newTaskData.serviceRate = task.serviceRate;
      if (task.invoiceId) newTaskData.invoiceId = task.invoiceId;
      
      console.log(`Creating new regular task as a copy of auto-generated task ${taskId}`);
      console.log(`Creating task with data:`, JSON.stringify(newTaskData, null, 2));
      
      // Create the new regular task
      const newTask = await this.storage.createTask(newTaskData);
      
      if (!newTask) {
        console.error(`Failed to create new regular task from auto-generated task ${taskId}`);
        return false;
      }
      
      console.log(`Successfully converted auto-generated task ${taskId} to regular task`);
      
      // Step 7: If this task is the latest for its period, update the original template task's 
      // recurring status - only the newest regular task should be recurring
      if (isLatestCompliancePeriod && task.parentTaskId) {
        console.log(`This is the latest compliance period - setting original template task ${task.parentTaskId} to non-recurring`);
        
        // Fetch the specific template task to ensure it exists
        const templateTask = await this.storage.getTask(task.parentTaskId, tenantId);
        
        if (templateTask) {
          console.log(`Found template task with ID: ${templateTask.id}, updating its recurring status`);
          
          // Update ONLY the template task to be non-recurring since its latest instance is now handled
          await this.storage.updateTask(task.parentTaskId, {
            isRecurring: false,
            updatedAt: new Date()
          });
        } else {
          console.log(`Template task with ID ${task.parentTaskId} not found, skipping update`);
        }
      }
      
      return true;
    } catch (error) {
      console.error(`Error in approveTask for task ${taskId}:`, error);
      return false;
    }
  }
  
  /**
   * Reject a pending auto-generated task
   */
  public async rejectTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated || !task.needsApproval) {
        console.log(`Task ${taskId} not eligible for rejection (Not auto-generated or not needing approval)`);
        return false;
      }
      
      console.log(`Rejecting auto-generated task ${taskId}`);
      
      // Update the task to be canceled
      const update = {
        needsApproval: false, // No longer needs approval (it's been rejected)
        isCanceled: true,
        canceledAt: new Date(),
        updatedAt: new Date()
      };
      
      await this.storage.updateTask(taskId, update);
      return true;
    } catch (error) {
      console.error(`Error rejecting task ${taskId}:`, error);
      return false;
    }
  }
  
  /**
   * Approve all pending tasks for a tenant
   */
  public async approveAllPendingTasks(tenantId: number): Promise<number> {
    try {
      const pendingTasks = await this.getTasksNeedingApproval(tenantId);
      let approvedCount = 0;
      
      for (const task of pendingTasks) {
        const taskIdToApprove = task.id;
        console.log(`Approving task ${taskIdToApprove} as part of batch approval`);
        
        try {
          const approved = await this.approveTask(taskIdToApprove, tenantId);
          if (approved) {
            approvedCount++;
          }
        } catch (error) {
          console.error(`Error approving task ${taskIdToApprove} in batch:`, error);
        }
      }
      
      console.log(`Approved ${approvedCount} tasks out of ${pendingTasks.length} pending tasks`);
      return approvedCount;
    } catch (error) {
      console.error("Error approving all pending tasks:", error);
      return 0;
    }
  }
  
  /**
   * Set a task to active (sets activatedAt timestamp)
   */
  public async activateTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated) {
        return false;
      }
      
      // Get the "In Progress" status for this tenant
      const statuses = await this.storage.getTaskStatuses(tenantId);
      const inProgressStatus = statuses.find(status => status.name.toLowerCase().includes('progress') || status.rank === 2);
      
      if (!inProgressStatus) {
        console.error(`No suitable "In Progress" status found for tenant ${tenantId}`);
        return false;
      }
      
      // Update the task to be active
      const update = {
        activatedAt: new Date(),
        statusId: inProgressStatus.id,
        updatedAt: new Date() // Set updatedAt to track status change
      };
      
      const updated = await this.storage.updateTask(taskId, update);
      return !!updated;
    } catch (error) {
      console.error("Error activating task:", error);
      return false;
    }
  }
  
  /**
   * Cancel a task (sets isCanceled flag and canceledAt timestamp)
   */
  public async cancelTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTask(taskId, tenantId);
      
      if (!task || !task.isAutoGenerated) {
        return false;
      }
      
      // Update the task to be canceled
      const update = {
        isCanceled: true,
        canceledAt: new Date(),
        updatedAt: new Date() // Set updatedAt to track status change
      };
      
      const updated = await this.storage.updateTask(taskId, update);
      return !!updated;
    } catch (error) {
      console.error("Error canceling task:", error);
      return false;
    }
  }
  
  /**
   * Process a single recurring task and create new instances if needed
   * This method takes a recurring task from the Tasks module and generates
   * future auto-generated tasks in the Auto Generated Tasks module
   */
  private async processRecurringTask(task: Task, leadDays: number): Promise<void> {
    try {
      // Skip processing if task doesn't have compliance frequency
      if (!task.complianceFrequency) {
        console.log(`Skipping task ${task.id} - Missing frequency. Frequency: ${task.complianceFrequency}, Duration: ${task.complianceDuration}`);
        return;
      }
      
      // Skip one-time tasks - they don't need recurring generation
      if (task.complianceFrequency.toLowerCase().includes('one time') || 
          task.complianceFrequency.toLowerCase() === 'once') {
        console.log(`Skipping one-time task ${task.id} - Not eligible for recurring generation`);
        return;
      }
      
      // Skip auto-generated tasks (they should not generate further tasks)
      if (task.isAutoGenerated) {
        console.log(`Skipping auto-generated task ${task.id} - Auto-generated tasks don't spawn new tasks`);
        return;
      }
      
      // Only process tasks that have the isRecurring flag set to true
      if (!task.isRecurring) {
        console.log(`Skipping non-recurring task ${task.id} - Task is not marked as recurring`);
        return;
      }
      
      // Get original period - require compliance dates
      if (!task.complianceStartDate || !task.complianceEndDate) {
        console.log(`Skipping task ${task.id} - Missing compliance dates`);
        return;
      }
      
      // Initialize duration to empty string if not provided
      const duration = task.complianceDuration || '';
      
      console.log(`Processing recurring task ${task.id}: ${task.taskDetails || 'No details'}`);
      console.log(`Frequency: ${task.complianceFrequency}, Duration: ${duration}`);
      console.log(`Compliance Period: ${format(new Date(task.complianceStartDate), 'yyyy-MM-dd')} to ${format(new Date(task.complianceEndDate), 'yyyy-MM-dd')}`);
      
      // Get the existing tasks for this tenant/client/entity to check for existing periods
      const existingTasks = await this.storage.getTasks(
        task.tenantId,
        task.clientId || undefined,
        task.entityId || undefined
      );
      
      // IMPORTANT: We need to start from the EXISTING compliance period first
      // to ensure we have the correct sequence of periods
      const originalEndDate = new Date(task.complianceEndDate);
      
      // Current date to calculate lead time
      const now = new Date();
      
      // Add lead days to determine how far in advance we should generate tasks
      const cutoffDate = new Date(now);
      cutoffDate.setDate(cutoffDate.getDate() + leadDays);
      
      console.log(`Using lead days: ${leadDays}, cutoff date for task generation: ${format(cutoffDate, 'yyyy-MM-dd')}`);
      
      // Collection to store all periods that need to be generated
      let periodsToGenerate: { startDate: Date, endDate: Date, dueDate: Date }[] = [];
      
      // We'll use the original compliance period as our starting reference
      // and incrementally calculate the next periods
      let currentReferenceDate = originalEndDate;
      
      // Generate sequence of periods from the original end date
      // up to the cutoff date (current date + lead days)
      console.log(`Generating periods starting after: ${format(currentReferenceDate, 'yyyy-MM-dd')}`);
      
      // Limit to 36 iterations to prevent infinite loops (covers 3 years of monthly tasks)
      for (let i = 0; i < 36; i++) {
        // Calculate the next period after the current reference date
        const nextPeriod = this.calculateNextCompliancePeriod(
          task.complianceFrequency,
          duration,
          currentReferenceDate
        );
        
        if (!nextPeriod) {
          console.log(`Could not calculate period after ${format(currentReferenceDate, 'yyyy-MM-dd')} for task ${task.id}`);
          break;
        }
        
        const { startDate, endDate } = nextPeriod;
        
        // Calculate due date (typically a few days before the end date)
        const dueDate = this.calculateDueDate(endDate);
        
        console.log(`Calculated period: ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}, Due: ${format(dueDate, 'yyyy-MM-dd')}`);
        
        // Stop generating if we've reached our cutoff date
        if (isAfter(startDate, cutoffDate)) {
          console.log(`Stopping at period starting ${format(startDate, 'yyyy-MM-dd')} - beyond cutoff date ${format(cutoffDate, 'yyyy-MM-dd')}`);
          break;
        }
        
        // Check if a task already exists for this period
        const periodExists = this.doesPeriodExist(task, startDate, endDate, existingTasks);
        
        if (!periodExists) {
          // Only add to generation queue if period doesn't already exist
          periodsToGenerate.push({ 
            startDate,
            endDate,
            dueDate 
          });
          console.log(`Added period to generation queue: ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
        } else {
          console.log(`Period already exists - skipping: ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);
        }
        
        // Move to the next period using the end date as our new reference
        currentReferenceDate = endDate;
      }
      
      // Generate tasks for all missing periods
      for (const period of periodsToGenerate) {
        const { startDate, endDate, dueDate } = period;
        await this.createRecurringTaskInstance(task, startDate, endDate, dueDate);
      }
      
      console.log(`Generated ${periodsToGenerate.length} tasks for task ${task.id}`);
    } catch (error) {
      console.error(`Error processing recurring task ${task.id}:`, error);
    }
  }
  
  /**
   * Check if a task already exists for a specific compliance period
   */
  private doesPeriodExist(task: Task, startDate: Date, endDate: Date, existingTasks: Task[]): boolean {
    // Convert dates to month/year format for easier comparison (e.g., "2025-05")
    const periodMonthYear = format(startDate, 'yyyy-MM');
    
    // Log the period we're checking
    console.log(`Checking if period ${periodMonthYear} exists for task type: ${task.isAdmin ? 'Admin' : 'Revenue'}, client: ${task.clientId}, entity: ${task.entityId}, service: ${task.serviceTypeId}`);
    
    return existingTasks.some(existingTask => {
      // Skip tasks without compliance dates
      if (!existingTask.complianceStartDate || !existingTask.complianceEndDate) {
        return false;
      }
      
      const existingStartDate = new Date(existingTask.complianceStartDate);
      const existingPeriodMonthYear = format(existingStartDate, 'yyyy-MM');
      
      // Match by month/year rather than exact date
      // This ensures we don't generate multiple tasks for the same month
      const periodMatch = existingPeriodMonthYear === periodMonthYear;
      
      if (!periodMatch) {
        return false;
      }
      
      // Check that other critical fields match to ensure it's truly a duplicate
      // for the same client, entity, service, and category
      const basicFieldsMatch = 
        existingTask.clientId === task.clientId &&
        existingTask.entityId === task.entityId &&
        existingTask.serviceTypeId === task.serviceTypeId &&
        existingTask.taskCategoryId === task.taskCategoryId;
      
      if (!basicFieldsMatch) {
        return false;
      }
      
      // Consider a period to exist if any of these conditions are true:
      const statusMatch = (
        // It's an auto-generated task waiting for approval
        (existingTask.isAutoGenerated && existingTask.needsApproval) ||
        // Or it's an approved auto-generated task (in history)
        (existingTask.isAutoGenerated && !existingTask.needsApproval) ||
        // Or it's a regular task for this period with a parent task ID matching our task
        (!existingTask.isAutoGenerated && existingTask.parentTaskId === task.id) ||
        // Or it's a regular task for this period with the same client, entity, service
        (!existingTask.isAutoGenerated && 
         existingTask.complianceFrequency === task.complianceFrequency &&
         existingTask.clientId === task.clientId &&
         existingTask.entityId === task.entityId &&
         existingTask.serviceTypeId === task.serviceTypeId)
      );
      
      if (statusMatch) {
        console.log(`Task already exists for period ${periodMonthYear} - Task ID: ${existingTask.id}, isAutoGenerated: ${existingTask.isAutoGenerated}, needsApproval: ${existingTask.needsApproval}`);
        return true;
      }
      
      return false;
    });
  }
  
  /**
   * Helper method to calculate a due date based on the end date
   */
  private calculateDueDate(endDate: Date): Date {
    // Calculate a due date that is a few days before the end date
    // Default to 5 days before end of period unless it's a short period
    const daysBeforeEnd = 5;
    return subDays(endDate, daysBeforeEnd);
  }
  
  /**
   * Calculate the next compliance period based on frequency and duration
   */
  private calculateNextCompliancePeriod(
    frequency: string, 
    duration: string,
    referenceDate: Date
  ): { startDate: Date, endDate: Date } | null {
    try {
      const freq = frequency.toLowerCase();
      
      // Start date is the day after the reference date
      // This ensures we don't overlap periods
      const startDate = new Date(referenceDate);
      startDate.setDate(startDate.getDate() + 1);
      
      // For monthly, set to the 1st of the next month
      startDate.setDate(1);
      
      let endDate: Date;
      
      if (freq.includes('monthly')) {
        // For monthly, add 1 month to the start month
        const nextMonth = addMonths(startDate, 1);
        // End date is the last day of that month
        endDate = new Date(nextMonth.getFullYear(), nextMonth.getMonth(), 0);
      } else if (freq.includes('quarterly')) {
        // For quarterly, add 3 months to the start month
        const nextQuarter = addMonths(startDate, 3);
        // End date is the last day of that month
        endDate = new Date(nextQuarter.getFullYear(), nextQuarter.getMonth(), 0);
      } else if (freq.includes('yearly') || freq.includes('annual')) {
        // For yearly, add 12 months to the start month
        const nextYear = addMonths(startDate, 12);
        // End date is the last day of that month
        endDate = new Date(nextYear.getFullYear(), nextYear.getMonth(), 0);
      } else {
        console.log(`Unknown frequency: ${frequency}`);
        return null;
      }
      
      // Ensure start date is always the 1st of the month
      startDate.setDate(1);
      startDate.setHours(0, 0, 0, 0);
      
      // Ensure end date is always the end of the day
      endDate.setHours(23, 59, 59, 999);
      
      return { startDate, endDate };
    } catch (error) {
      console.error(`Error calculating next compliance period for frequency ${frequency}:`, error);
      return null;
    }
  }
  
  /**
   * Create a new instance of a recurring task for a specific period
   */
  private async createRecurringTaskInstance(
    templateTask: Task, 
    startDate: Date, 
    endDate: Date,
    dueDate: Date
  ): Promise<void> {
    try {
      // Ensure the dates are properly formatted with consistent time components
      // Start date: First day of month at 00:00:00
      const complianceStartDate = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
      complianceStartDate.setHours(0, 0, 0, 0);
      
      // End date: Last day of month at 23:59:59.999
      const complianceEndDate = new Date(endDate.getFullYear(), endDate.getMonth() + 1, 0);
      complianceEndDate.setHours(23, 59, 59, 999);
      
      // Format as month/year for logging and validation
      const periodMonthYear = format(complianceStartDate, 'yyyy-MM');
      console.log(`Formatted compliance period: ${format(complianceStartDate, 'yyyy-MM-dd')} to ${format(complianceEndDate, 'yyyy-MM-dd')}`);
      
      // Create a formatted period string for display
      // This will be shown in the UI as "May 2025" for Monthly, "Q2 2025" for Quarterly, etc.
      let compliancePeriod = '';
      const freq = templateTask.complianceFrequency?.toLowerCase() || '';
      
      if (freq.includes('monthly')) {
        // Format as "Month YYYY" (e.g., "May 2025")
        compliancePeriod = format(complianceStartDate, 'MMMM yyyy');
      } else if (freq.includes('quarterly')) {
        // Calculate the quarter number (1-4)
        const quarter = Math.floor(complianceStartDate.getMonth() / 3) + 1;
        compliancePeriod = `Q${quarter} ${complianceStartDate.getFullYear()}`;
      } else if (freq.includes('yearly') || freq.includes('annual')) {
        // Format as just the year
        compliancePeriod = format(complianceStartDate, 'yyyy');
      } else {
        // Default to Month YYYY for other frequencies
        compliancePeriod = format(complianceStartDate, 'MMMM yyyy');
      }
      
      // Check if auto-approval setting is enabled
      const autoApproveTasksSetting = await this.storage.getTenantSetting(
        templateTask.tenantId, 
        "auto_approve_recurring_tasks"
      );
      
      const needsApproval = !autoApproveTasksSetting || 
                            autoApproveTasksSetting.value?.toLowerCase() !== "true";
      
      // Create a new task based on the template task with the new compliance period
      const newTask: any = {
        tenantId: templateTask.tenantId,
        isAdmin: templateTask.isAdmin,
        taskType: templateTask.taskType,
        clientId: templateTask.clientId,
        entityId: templateTask.entityId,
        serviceTypeId: templateTask.serviceTypeId,
        taskCategoryId: templateTask.taskCategoryId,
        assigneeId: templateTask.assigneeId,
        dueDate: dueDate,
        statusId: templateTask.statusId,
        taskDetails: templateTask.taskDetails,
        nextToDo: templateTask.nextToDo,
        isRecurring: false, // Auto-generated tasks are never recurring themselves
        complianceFrequency: templateTask.complianceFrequency,
        complianceYear: complianceStartDate.getFullYear().toString(),
        complianceDuration: templateTask.complianceDuration,
        complianceStartDate: complianceStartDate,
        complianceEndDate: complianceEndDate,
        compliancePeriod: compliancePeriod,
        currency: templateTask.currency,
        serviceRate: templateTask.serviceRate,
        isAutoGenerated: true, // Flag as auto-generated
        parentTaskId: templateTask.id, // Link to the original template task
        needsApproval: needsApproval, // Set based on tenant setting
      };
      
      // Create the new task
      await this.storage.createTask(newTask);
      
      console.log(`Created new auto-generated task for ${compliancePeriod} based on template task ${templateTask.id}`);
    } catch (error) {
      console.error(`Error creating recurring task instance:`, error);
    }
  }
}