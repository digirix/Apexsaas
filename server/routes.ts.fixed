import express, { Express, Request, Response, NextFunction } from "express";
import { createServer } from "http";
import { setupAuth } from "./auth";
import { IStorage } from "./storage";
import { DatabaseStorage } from "./database-storage";
import { createAIClient } from "./utils/ai-client-factory";
import { OpenRouterClient } from "./utils/openrouter-client";
import { createWebSocketServer } from "./ws-server";

export function createRouter(app: Express, storage: IStorage) {
  // Set up authentication
  setupAuth(app);

  // Register routes
  console.log("Starting to register routes...");

  // API routes
  app.get("/api/v1/users", async (req, res) => {
    try {
      const users = await storage.getUsers();
      res.json(users);
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });

  // ... [REST OF EXISTING ROUTES] ...

  // AI Configuration Routes
  
  // Get AI configuration
  app.get("/api/v1/setup/ai-configuration", async (req, res) => {
    try {
      const tenantId = (req.user as any).tenantId;
      
      // Get provider configuration
      const selectedProviderSetting = await storage.getTenantSetting(tenantId, "ai_selected_provider");
      const selectedModelSetting = await storage.getTenantSetting(tenantId, "ai_selected_model");
      
      // Build provider status map
      const providers = {
        openrouter: { apiKeyConfigured: false },
        openai: { apiKeyConfigured: false }, 
        anthropic: { apiKeyConfigured: false },
        google: { apiKeyConfigured: false },
        deepseek: { apiKeyConfigured: false }
      };
      
      // Check which providers have API keys configured
      for (const provider of Object.keys(providers)) {
        const apiKey = await storage.getTenantSetting(tenantId, `${provider}_api_key`);
        if (apiKey) {
          providers[provider].apiKeyConfigured = true;
        }
      }
      
      res.json({
        selectedProvider: selectedProviderSetting ? selectedProviderSetting.value : "openrouter",
        providers,
        selectedModel: selectedModelSetting ? selectedModelSetting.value : null
      });
    } catch (error) {
      console.error("Error getting AI configuration:", error);
      res.status(500).json({ message: "Failed to get AI configuration" });
    }
  });
  
  // Set provider
  app.post("/api/v1/setup/ai-configuration/provider", async (req, res) => {
    try {
      const tenantId = (req.user as any).tenantId;
      const { provider } = req.body;
      
      if (!provider) {
        return res.status(400).json({ message: "Provider is required" });
      }
      
      await storage.setTenantSetting(tenantId, "ai_selected_provider", provider);
      
      res.status(200).json({ success: true });
    } catch (error) {
      console.error("Error setting provider:", error);
      res.status(500).json({ message: "Failed to set provider" });
    }
  });
  
  // Set provider API key
  app.post("/api/v1/setup/ai-configuration/:provider/api-key", async (req, res) => {
    try {
      const tenantId = (req.user as any).tenantId;
      const { provider } = req.params;
      const { apiKey } = req.body;
      
      if (!apiKey) {
        return res.status(400).json({ message: "API key is required" });
      }
      
      // Save the API key for this provider
      await storage.setTenantSetting(tenantId, `${provider}_api_key`, apiKey);
      
      // Set this as the selected provider
      await storage.setTenantSetting(tenantId, "ai_selected_provider", provider);
      
      res.status(200).json({ success: true });
    } catch (error) {
      console.error("Error saving API key:", error);
      res.status(500).json({ message: "Failed to save API key" });
    }
  });
  
  // Delete provider API key
  app.delete("/api/v1/setup/ai-configuration/:provider/api-key", async (req, res) => {
    try {
      const tenantId = (req.user as any).tenantId;
      const { provider } = req.params;
      
      // Delete the API key setting
      await storage.deleteTenantSetting(tenantId, `${provider}_api_key`);
      
      // If this was the selected provider, clear the selected provider and model settings
      const selectedProviderSetting = await storage.getTenantSetting(tenantId, "ai_selected_provider");
      if (selectedProviderSetting && selectedProviderSetting.value === provider) {
        await storage.deleteTenantSetting(tenantId, "ai_selected_provider");
        await storage.deleteTenantSetting(tenantId, "ai_selected_model");
      }
      
      res.status(200).json({ success: true });
    } catch (error) {
      console.error("Error deleting API key:", error);
      res.status(500).json({ message: "Failed to delete API key" });
    }
  });
  
  // Test provider connection
  app.post("/api/v1/setup/ai-configuration/:provider/test-connection", async (req, res) => {
    try {
      const tenantId = (req.user as any).tenantId;
      const { provider } = req.params;
      
      // Get the API key
      const apiKeyConfig = await storage.getTenantSetting(tenantId, `${provider}_api_key`);
      
      if (!apiKeyConfig) {
        return res.status(400).json({ success: false, message: "API key not configured" });
      }
      
      // Create client and test connection
      const aiClient = await createAIClient(provider, apiKeyConfig.value);
      const result = await aiClient.testConnection();
      
      res.json(result);
    } catch (error) {
      console.error("Error testing connection:", error);
      res.status(500).json({ 
        success: false, 
        message: error instanceof Error ? error.message : "Failed to test connection" 
      });
    }
  });
  
  // Get models for a provider
  app.get("/api/v1/setup/ai-models/:provider", async (req, res) => {
    try {
      const tenantId = (req.user as any).tenantId;
      const { provider } = req.params;
      
      // Get the API key
      const apiKeyConfig = await storage.getTenantSetting(tenantId, `${provider}_api_key`);
      
      if (!apiKeyConfig) {
        return res.status(400).json({ message: "API key not configured" });
      }
      
      // Create client and get models
      try {
        const aiClient = await createAIClient(provider, apiKeyConfig.value);
        
        // If client has a getModels method, use it
        if (aiClient.getModels) {
          const modelsData = await aiClient.getModels();
          
          // Return the models in a standardized format
          return res.json({
            models: modelsData.data || modelsData.models || [],
            source: 'api'
          });
        } else {
          // Return predefined models based on provider
          const predefinedModels = getPredefinedModels(provider);
          return res.json({
            models: predefinedModels,
            source: 'predefined'
          });
        }
      } catch (error) {
        console.error(`Error fetching models from API for ${provider}:`, error);
        
        // Fall back to predefined models
        const predefinedModels = getPredefinedModels(provider);
        return res.json({
          models: predefinedModels,
          source: 'predefined'
        });
      }
    } catch (error) {
      console.error("Error fetching models:", error);
      res.status(500).json({ message: "Failed to fetch models" });
    }
  });
  
  // Predefined models for fallback
  function getPredefinedModels(provider: string) {
    switch (provider) {
      case 'openrouter':
        return [
          { id: "openai/gpt-3.5-turbo", name: "GPT-3.5 Turbo", provider: "openai" },
          { id: "openai/gpt-4", name: "GPT-4", provider: "openai" },
          { id: "openai/gpt-4o", name: "GPT-4o", provider: "openai" },
          { id: "anthropic/claude-3-opus-20240229", name: "Claude 3 Opus", provider: "anthropic" },
          { id: "anthropic/claude-3-sonnet-20240229", name: "Claude 3 Sonnet", provider: "anthropic" },
          { id: "anthropic/claude-3-haiku-20240307", name: "Claude 3 Haiku", provider: "anthropic" },
          { id: "google/gemini-1.5-pro", name: "Gemini 1.5 Pro", provider: "google" },
          { id: "google/gemini-1.5-flash", name: "Gemini 1.5 Flash", provider: "google" },
          { id: "meta/llama-3-8b-instruct", name: "Llama 3 8B", provider: "meta" },
          { id: "meta/llama-3-70b-instruct", name: "Llama 3 70B", provider: "meta" },
        ];
      case 'openai':
        return [
          { id: "gpt-3.5-turbo", name: "GPT-3.5 Turbo", provider: "openai" },
          { id: "gpt-4", name: "GPT-4", provider: "openai" },
          { id: "gpt-4o", name: "GPT-4o", provider: "openai" },
        ];
      case 'anthropic':
        return [
          { id: "claude-3-opus-20240229", name: "Claude 3 Opus", provider: "anthropic" },
          { id: "claude-3-sonnet-20240229", name: "Claude 3 Sonnet", provider: "anthropic" },
          { id: "claude-3-haiku-20240307", name: "Claude 3 Haiku", provider: "anthropic" },
          { id: "claude-3-7-sonnet-20250219", name: "Claude 3.7 Sonnet", provider: "anthropic" }
        ];
      case 'google':
        return [
          { id: "gemini-1.5-pro", name: "Gemini 1.5 Pro", provider: "google" },
          { id: "gemini-1.5-flash", name: "Gemini 1.5 Flash", provider: "google" },
        ];
      case 'deepseek':
        return [
          { id: "deepseek-coder", name: "DeepSeek Coder", provider: "deepseek" },
          { id: "deepseek-chat", name: "DeepSeek Chat", provider: "deepseek" },
        ];
      default:
        return [];
    }
  }
  
  // Set selected model
  app.post("/api/v1/setup/ai-configuration/:provider/selected-model", async (req, res) => {
    try {
      const tenantId = (req.user as any).tenantId;
      const { provider } = req.params;
      const { selectedModel } = req.body;
      
      if (!selectedModel) {
        return res.status(400).json({ message: "Selected model is required" });
      }
      
      // For older clients supporting only OpenRouter
      if (provider === "openrouter") {
        // Store the selected model in old format
        await storage.setTenantSetting(tenantId, "openrouter_selected_model", selectedModel);
        
        // Also store in new format
        await storage.setTenantSetting(tenantId, "ai_selected_model", selectedModel);
      } else {
        // Store in new format only for other providers
        await storage.setTenantSetting(tenantId, "ai_selected_model", selectedModel);
      }
      
      res.status(200).json({ success: true });
    } catch (error) {
      console.error("Error saving selected model:", error);
      res.status(500).json({ message: "Failed to save selected model" });
    }
  });
  
  // AI Chat endpoint
  app.post("/api/v1/ai/chat", async (req: Request, res: Response) => {
    try {
      const tenantId = (req.user as any).tenantId;
      const { messages } = req.body;
      
      if (!messages || !Array.isArray(messages)) {
        return res.status(400).json({ message: "Valid messages array is required" });
      }
      
      // Get the selected provider and model in the new format
      const selectedProviderSetting = await storage.getTenantSetting(tenantId, "ai_selected_provider");
      const selectedModelSetting = await storage.getTenantSetting(tenantId, "ai_selected_model");
      
      // For backward compatibility
      if (!selectedProviderSetting || !selectedModelSetting) {
        // Try the old format (OpenRouter only)
        const apiKeyConfig = await storage.getTenantSetting(tenantId, "openrouter_api_key");
        const selectedModelConfig = await storage.getTenantSetting(tenantId, "openrouter_selected_model");
        
        if (!apiKeyConfig) {
          return res.status(400).json({ message: "AI not configured. Please set up an AI provider in the Configuration." });
        }
        
        if (!selectedModelConfig) {
          return res.status(400).json({ message: "No AI model selected. Please select a model in AI Configuration." });
        }
        
        // Initialize the OpenRouter client
        const openRouterClient = new OpenRouterClient(apiKeyConfig.value);
        
        // Get the chat completion
        const completion = await openRouterClient.createChatCompletion(
          selectedModelConfig.value,
          messages
        );
        
        return res.json(completion);
      }
      
      // New multi-provider format
      const provider = selectedProviderSetting.value;
      const selectedModel = selectedModelSetting.value;
      
      // Get the API key for the selected provider
      const apiKeyConfig = await storage.getTenantSetting(tenantId, `${provider}_api_key`);
      
      if (!apiKeyConfig) {
        return res.status(400).json({ 
          message: `No API key configured for ${provider}. Please set up the API key in AI Configuration.` 
        });
      }
      
      // Create the appropriate AI client
      const aiClient = await createAIClient(provider, apiKeyConfig.value);
      
      // Get model ID
      let modelId = selectedModel;
      
      console.log(`Original model selection: provider=${provider}, model=${selectedModel}`);
      
      // Handle model ID formats based on provider
      if (provider === "openrouter") {
        // For OpenRouter, models need provider prefix format (e.g. "openai/gpt-4")
        if (!selectedModel.includes("/")) {
          // If no provider is specified, default to openai/ prefix for OpenRouter
          modelId = `openai/${selectedModel}`;
          console.log(`OpenRouter model ID adjusted: ${selectedModel} -> ${modelId}`);
        } else {
          // Extract provider from model ID
          const providerPrefix = selectedModel.split("/")[0];
          
          // Validate the provider is supported by OpenRouter
          const supportedProviders = ["openai", "anthropic", "google", "meta", "mistral", "cohere"];
          
          if (!supportedProviders.includes(providerPrefix)) {
            // Invalid provider, use a default model
            modelId = "openai/gpt-3.5-turbo";
            console.log(`Invalid OpenRouter model (${selectedModel}), using default: ${modelId}`);
          }
        }
      } else {
        // For direct providers, remove provider prefix if present
        if (selectedModel.includes("/")) {
          if (selectedModel.startsWith(`${provider}/`)) {
            // Remove provider prefix
            modelId = selectedModel.substring(provider.length + 1);
          } else {
            // Different provider in prefix, take just the model part
            modelId = selectedModel.split("/").pop() || selectedModel;
          }
          console.log(`Direct provider model ID adjusted: ${selectedModel} -> ${modelId}`);
        }
      }
      
      console.log(`Using model ID: ${modelId} for provider: ${provider}`);
        
      // Get the chat completion
      const completion = await aiClient.createChatCompletion(
        modelId,
        messages
      );
      
      res.json(completion);
    } catch (error) {
      console.error("Error in AI chat:", error);
      res.status(500).json({ 
        message: error instanceof Error ? error.message : "Failed to generate AI response" 
      });
    }
  });

  // AI Financial Analysis endpoint
  app.post("/api/v1/ai/analyze-finance", async (req, res) => {
    try {
      const tenantId = (req.user as any).tenantId;
      const { data, query } = req.body;
      
      if (!data || !query) {
        return res.status(400).json({ message: "Data and query are required" });
      }
      
      // Get the selected provider and model in the new format
      const selectedProviderSetting = await storage.getTenantSetting(tenantId, "ai_selected_provider");
      const selectedModelSetting = await storage.getTenantSetting(tenantId, "ai_selected_model");
      
      // For backward compatibility
      if (!selectedProviderSetting || !selectedModelSetting) {
        // Try the old format (OpenRouter only)
        const apiKeyConfig = await storage.getTenantSetting(tenantId, "openrouter_api_key");
        const selectedModelConfig = await storage.getTenantSetting(tenantId, "openrouter_selected_model");
        
        if (!apiKeyConfig) {
          return res.status(400).json({ message: "AI not configured. Please set up an AI provider in the Configuration." });
        }
        
        if (!selectedModelConfig) {
          return res.status(400).json({ message: "No AI model selected. Please select a model in AI Configuration." });
        }
        
        // Initialize the OpenRouter client
        const openRouterClient = new OpenRouterClient(apiKeyConfig.value);
        
        // Analyze the data
        const analysis = await openRouterClient.analyzeData(
          selectedModelConfig.value,
          data,
          query
        );
        
        return res.json({ analysis });
      }
      
      // New multi-provider format
      const provider = selectedProviderSetting.value;
      const selectedModel = selectedModelSetting.value;
      
      // Get the API key for the selected provider
      const apiKeyConfig = await storage.getTenantSetting(tenantId, `${provider}_api_key`);
      
      if (!apiKeyConfig) {
        return res.status(400).json({ 
          message: `No API key configured for ${provider}. Please set up the API key in AI Configuration.` 
        });
      }
      
      // Create the appropriate AI client
      const aiClient = await createAIClient(provider, apiKeyConfig.value);
      
      // Get model ID
      let modelId = selectedModel;
      
      // For OpenRouter, keep the full model ID (e.g. "openai/gpt-4o")
      // For direct providers, remove provider prefix if present
      if (provider !== 'openrouter' && selectedModel.includes('/')) {
        modelId = selectedModel.includes(`${provider}/`) 
          ? selectedModel.substring(provider.length + 1) 
          : selectedModel;
      }
      
      let analysis;
      
      // Check if client has specific analyzeData method
      if (aiClient.analyzeData) {
        analysis = await aiClient.analyzeData(modelId, data, query);
      } else {
        // Fall back to chat completion with formatted prompt
        const systemPrompt = `You are an expert accounting and financial analysis AI assistant. 
        Analyze the provided accounting data and respond to the user's query with insights, patterns, and recommendations.
        Focus on accuracy, clarity, and actionable insights. Use accounting terminology appropriately.`;
        
        const userPrompt = `Here is the accounting data to analyze:
        ${JSON.stringify(data, null, 2)}
        
        My question/request is: ${query}`;
        
        const messages = [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt }
        ];
        
        const completion = await aiClient.createChatCompletion(modelId, messages);
        analysis = completion.choices[0].message.content;
      }
      
      res.json({ analysis });
    } catch (error) {
      console.error("Error in AI financial analysis:", error);
      res.status(500).json({ 
        message: error instanceof Error ? error.message : "Failed to analyze financial data" 
      });
    }
  });
  
  // Create an HTTP server
  const httpServer = createServer(app);

  return httpServer;
}