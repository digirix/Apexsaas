import { IStorage } from "./storage";
import { Task, InsertTask } from "@shared/schema";
import { 
  addMonths, addDays, format, 
  startOfMonth, endOfMonth, 
  subDays, isAfter,
  addYears
} from "date-fns";

/**
 * Approve a specific auto-generated task and convert it to a regular task
 * 
 * This is a completely rewritten implementation that ensures:
 * 1. Only the specific approved task (by ID) is moved to the Tasks Module
 * 2. Multiple instances of the same template task are handled correctly
 * 3. The approved task is properly tracked in the database
 * 
 * @param storage - The data storage implementation
 * @param taskId - The ID of the specific auto-generated task to approve
 * @param tenantId - The tenant ID for security validation
 * @returns A boolean indicating success or failure
 */
export async function approveTask(
  storage: IStorage, 
  taskId: number, 
  tenantId: number
): Promise<boolean> {
  try {
    // Step 1: Get the specific auto-generated task by its ID
    const task = await storage.getTask(taskId, tenantId);
    
    // Validate the task is eligible for approval
    if (!task) {
      console.log(`Task ${taskId} not found for tenant ${tenantId}`);
      return false;
    }
    
    if (!task.isAutoGenerated) {
      console.log(`Task ${taskId} is not an auto-generated task`);
      return false;
    }
    
    if (!task.needsApproval) {
      console.log(`Task ${taskId} does not need approval (already processed)`);
      return false;
    }
    
    console.log(`Processing approval for auto-generated task ${taskId}`);
    console.log(`Task details: client: ${task.clientId}, entity: ${task.entityId}, service: ${task.serviceTypeId}`);
    
    if (task.complianceStartDate && task.complianceEndDate) {
      console.log(`Compliance period: ${format(new Date(task.complianceStartDate), 'yyyy-MM-dd')} to ${format(new Date(task.complianceEndDate), 'yyyy-MM-dd')}`);
    }
    
    // Step 2: Check if a regular task already exists for this specific auto-generated task
    // We only match by the exact auto-generated task ID to ensure we only process this specific task
    const existingTasks = await storage.getTasks(tenantId);
    const regularTaskExists = existingTasks.some(existingTask => {
      // We're looking for a non-auto-generated task with a parent ID matching our current task ID
      return !existingTask.isAutoGenerated && existingTask.parentTaskId === task.id;
    });
    
    if (regularTaskExists) {
      console.log(`Regular task already exists for auto-generated task ${task.id}. Not creating duplicate.`);
      
      // Just update the auto-generated task to no longer need approval and store the update time
      await storage.updateTask(taskId, {
        needsApproval: false,
        updatedAt: new Date()
      });
      
      return true;
    }
    
    // Step 3: Determine if this is the latest compliance period
    // This is important for setting the isRecurring flag correctly
    let isLatestCompliancePeriod = true;
    
    if (task.parentTaskId && task.complianceEndDate) {
      const currentTaskEndDate = new Date(task.complianceEndDate);
      
      // Find all sibling auto-generated tasks that share the same parent template
      const siblingTasks = existingTasks.filter(existingTask => 
        existingTask.isAutoGenerated && 
        existingTask.parentTaskId === task.parentTaskId &&
        existingTask.clientId === task.clientId &&
        existingTask.entityId === task.entityId &&
        existingTask.serviceTypeId === task.serviceTypeId &&
        existingTask.id !== task.id // Exclude the current task
      );
      
      // Check if any sibling has a later compliance period
      for (const sibling of siblingTasks) {
        if (sibling.complianceEndDate) {
          const siblingEndDate = new Date(sibling.complianceEndDate);
          
          if (siblingEndDate > currentTaskEndDate) {
            isLatestCompliancePeriod = false;
            console.log(`This task (period ending ${format(currentTaskEndDate, 'yyyy-MM-dd')}) is not the latest - found newer period: ${format(siblingEndDate, 'yyyy-MM-dd')}`);
            break;
          }
        }
      }
    }
    
    console.log(`This task is${isLatestCompliancePeriod ? '' : ' not'} the latest compliance period`);
    
    // Step 4: Fix compliance end date to always be last day of month at 23:59:59.999
    let fixedComplianceEndDate: Date | undefined = undefined;
    
    if (task.complianceStartDate) {
      const startDate = new Date(task.complianceStartDate);
      const frequency = task.complianceFrequency?.toLowerCase() || '';
      
      // Calculate the end date based on the frequency
      let endDate: Date;
      
      if (frequency.includes('quarterly')) {
        // For quarterly, get the last day of the last month in the quarter
        const quarterStartMonth = Math.floor(startDate.getMonth() / 3) * 3;
        const lastMonthInQuarter = quarterStartMonth + 2;
        endDate = new Date(startDate.getFullYear(), lastMonthInQuarter + 1, 0);
      } else if (frequency.includes('annual') || frequency.includes('yearly')) {
        // For annual, get December 31st of the year
        endDate = new Date(startDate.getFullYear(), 11, 31);
      } else {
        // For monthly or others, get the last day of the month
        endDate = endOfMonth(startDate);
      }
      
      // Set the time to 23:59:59.999
      endDate.setHours(23, 59, 59, 999);
      fixedComplianceEndDate = endDate;
      
      console.log(`Fixed compliance end date: ${format(fixedComplianceEndDate, 'yyyy-MM-dd HH:mm:ss.SSS')}`);
    }
    
    // Step 5: Update the auto-generated task to mark it as processed
    const updateData: Partial<InsertTask> = {
      needsApproval: false,
      updatedAt: new Date()
    };
    
    if (fixedComplianceEndDate) {
      updateData.complianceEndDate = fixedComplianceEndDate;
    }
    
    console.log(`Updating auto-generated task ${taskId} with data:`, JSON.stringify(updateData, null, 2));
    await storage.updateTask(taskId, updateData);
    
    // Step 6: Create a new regular task based on this auto-generated task
    // Check if this is a one-time task
    const isOneTime = task.complianceFrequency?.toLowerCase() === 'one time' || 
                     task.complianceFrequency?.toLowerCase() === 'once';
    
    // Prepare the data for the new regular task
    const newTaskData = {
      tenantId: task.tenantId,
      isAdmin: task.isAdmin,
      taskType: task.taskType,
      assigneeId: task.assigneeId,
      dueDate: task.dueDate,
      statusId: task.statusId,
      taskDetails: task.taskDetails || "",
      nextToDo: task.nextToDo || "",
      isRecurring: isLatestCompliancePeriod && !isOneTime, // Only latest is recurring if not one-time
      isAutoGenerated: false, // This is now a regular task
      parentTaskId: taskId, // Reference to the specific auto-generated task that was approved
      needsApproval: false, // Regular tasks never need approval
    };
    
    // Add optional fields only if they exist in the auto-generated task
    if (task.clientId !== undefined) newTaskData.clientId = task.clientId;
    if (task.entityId !== undefined) newTaskData.entityId = task.entityId;
    if (task.serviceTypeId !== undefined) newTaskData.serviceTypeId = task.serviceTypeId;
    if (task.taskCategoryId !== undefined) newTaskData.taskCategoryId = task.taskCategoryId;
    if (task.complianceFrequency) newTaskData.complianceFrequency = task.complianceFrequency;
    if (task.complianceYear) newTaskData.complianceYear = task.complianceYear;
    if (task.complianceDuration) newTaskData.complianceDuration = task.complianceDuration;
    if (task.complianceStartDate) newTaskData.complianceStartDate = task.complianceStartDate;
    if (fixedComplianceEndDate) {
      newTaskData.complianceEndDate = fixedComplianceEndDate;
    } else if (task.complianceEndDate) {
      newTaskData.complianceEndDate = task.complianceEndDate;
    }
    if (task.compliancePeriod) newTaskData.compliancePeriod = task.compliancePeriod;
    
    // Add remaining optional fields
    if (task.currency) newTaskData.currency = task.currency;
    if (task.serviceRate) newTaskData.serviceRate = task.serviceRate;
    if (task.invoiceId) newTaskData.invoiceId = task.invoiceId;
    
    console.log(`Creating new regular task as a copy of auto-generated task ${taskId}`);
    console.log(`Creating task with data:`, JSON.stringify(newTaskData, null, 2));
    
    // Create the new regular task - ensure it has all required fields
    const newTask = await storage.createTask(newTaskData as InsertTask);
    
    if (!newTask) {
      console.error(`Failed to create new regular task from auto-generated task ${taskId}`);
      return false;
    }
    
    console.log(`Successfully converted auto-generated task ${taskId} to regular task`);
    
    // Step 7: If this task is the latest for its period, update the original template task's 
    // recurring status - only the newest regular task should be recurring
    if (isLatestCompliancePeriod && task.parentTaskId) {
      console.log(`This is the latest compliance period - setting original template task ${task.parentTaskId} to non-recurring`);
      
      // Fetch the specific template task to ensure it exists
      const templateTask = await storage.getTask(task.parentTaskId, tenantId);
      
      if (templateTask) {
        console.log(`Found template task with ID: ${templateTask.id}, updating its recurring status`);
        
        // Update ONLY the template task to be non-recurring since its latest instance is now handled
        await storage.updateTask(task.parentTaskId, {
          isRecurring: false,
          updatedAt: new Date()
        });
      } else {
        console.log(`Template task with ID ${task.parentTaskId} not found, skipping update`);
      }
    }
    
    return true;
  } catch (error) {
    console.error(`Error in approveTask for task ${taskId}:`, error);
    return false;
  }
}