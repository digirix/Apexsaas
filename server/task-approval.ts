/**
 * task-approval.ts
 * 
 * This module provides an improved implementation for approving auto-generated tasks
 * and converting them to regular tasks in the task management system.
 * 
 * The key improvement is that when an auto-generated task is approved, only that specific
 * task instance is moved to the Tasks module while other instances remain in the 
 * Auto Generated Tasks module.
 */

import { IStorage } from "./storage";
import { format } from "date-fns";
import { Task, InsertTask } from "@shared/schema";

/**
 * Approve a specific auto-generated task and convert it to a regular task
 * 
 * This is a completely rewritten implementation that ensures:
 * 1. Only the specific approved task (by ID) is moved to the Tasks Module
 * 2. Multiple instances of the same template task are handled correctly
 * 3. The approved task is properly tracked in the database
 * 
 * @param storage - The data storage implementation
 * @param taskId - The ID of the specific auto-generated task to approve
 * @param tenantId - The tenant ID for security validation
 * @returns A boolean indicating success or failure
 */
export async function approveTask(
  storage: IStorage, 
  taskId: number, 
  tenantId: number
): Promise<boolean> {
  try {
    // Step 1: Get the specific auto-generated task by ID
    const task = await storage.getTask(taskId, tenantId);
    
    // Basic validation
    if (!task) {
      console.log(`Task ${taskId} not found for tenant ${tenantId}`);
      return false;
    }
    
    if (!task.isAutoGenerated) {
      console.log(`Task ${taskId} is not an auto-generated task`);
      return false;
    }
    
    if (!task.needsApproval) {
      console.log(`Task ${taskId} does not need approval (already processed)`);
      return false;
    }
    
    console.log(`[APPROVAL] Processing auto-generated task ${taskId} for tenant ${tenantId}`);
    
    // Log task details with checks to avoid undefined references
    const clientId = task.clientId !== undefined ? task.clientId : 'none';
    const entityId = task.entityId !== undefined ? task.entityId : 'none';
    const serviceId = task.serviceTypeId !== undefined ? task.serviceTypeId : 'none';
    
    console.log(`[APPROVAL] Task details: client: ${clientId}, entity: ${entityId}, service: ${serviceId}`);
    
    // Step 2: Check if a regular task already exists with this specific auto-generated task as parent
    // This is critical to prevent creating multiple regular tasks for the same auto-generated task
    console.log(`[APPROVAL] Checking if a regular task already exists with parentTaskId = ${task.id}`);
    
    const existingTasks = await storage.getTasks(tenantId);
    const regularTasksWithThisParent = existingTasks.filter(existingTask => 
      !existingTask.isAutoGenerated && existingTask.parentTaskId === task.id
    );
    
    if (regularTasksWithThisParent.length > 0) {
      console.log(`[APPROVAL] ${regularTasksWithThisParent.length} regular task(s) already exist for auto-generated task ${task.id}. Not creating duplicate.`);
      
      // Just mark the auto-generated task as processed
      await storage.updateTask(taskId, {
        needsApproval: false,
        updatedAt: new Date()
      });
      
      return true;
    }
    
    // Step 3: Mark the auto-generated task as processed (no longer needs approval)
    // but KEEP it as auto-generated (don't change isAutoGenerated flag)
    console.log(`[APPROVAL] Marking auto-generated task ${taskId} as processed`);
    
    await storage.updateTask(taskId, {
      needsApproval: false,
      updatedAt: new Date()
    });
    
    // Step 4: Determine if this is the latest compliance period (for setting isRecurring flag)
    const isOneTime = task.complianceFrequency?.toLowerCase() === 'one time' || 
                      task.complianceFrequency?.toLowerCase() === 'once';
    
    let isLatestCompliancePeriod = true;
    
    if (!isOneTime && task.parentTaskId && task.complianceEndDate) {
      const currentTaskEndDate = new Date(task.complianceEndDate);
      
      // Find other auto-generated tasks with the same template parent
      const siblingTasks = existingTasks.filter(existingTask => 
        existingTask.isAutoGenerated && 
        existingTask.parentTaskId === task.parentTaskId &&
        existingTask.id !== task.id
      );
      
      // Check if any sibling has a later compliance period
      for (const sibling of siblingTasks) {
        if (sibling.complianceEndDate) {
          const siblingEndDate = new Date(sibling.complianceEndDate);
          
          if (siblingEndDate > currentTaskEndDate) {
            isLatestCompliancePeriod = false;
            console.log(`[APPROVAL] This task is not the latest period - found newer period: ${format(siblingEndDate, 'yyyy-MM-dd')}`);
            break;
          }
        }
      }
    }
    
    // Step 5: Create a NEW regular task as a copy of the auto-generated task
    // Build up the task data with only the required fields first
    console.log(`[APPROVAL] Creating new regular task as a copy of auto-generated task ${taskId}`);
    
    // Create a task data object with proper typing
    const newTaskData: Partial<Task> = {
      tenantId: task.tenantId,
      isAdmin: task.isAdmin || false,
      taskType: task.taskType || 'Regular',
      assigneeId: task.assigneeId,
      dueDate: task.dueDate,
      statusId: task.statusId,
      taskDetails: task.taskDetails || '',
      nextToDo: task.nextToDo || '',
      isRecurring: !isOneTime && isLatestCompliancePeriod, 
      isAutoGenerated: false, // Critical: make it a regular task
      parentTaskId: task.id,   // Critical: link to this specific auto-generated task
      needsApproval: false,    // Regular tasks don't need approval
      createdAt: new Date(),
      isCanceled: false
    };
    
    // Type-safe copy of optional fields from the original task
    if ('clientId' in task && task.clientId !== undefined && task.clientId !== null) {
      newTaskData.clientId = task.clientId;
    }
    
    if ('entityId' in task && task.entityId !== undefined && task.entityId !== null) {
      newTaskData.entityId = task.entityId;
    }
    
    if ('serviceTypeId' in task && task.serviceTypeId !== undefined && task.serviceTypeId !== null) {
      newTaskData.serviceTypeId = task.serviceTypeId;
    }
    
    if ('taskCategoryId' in task && task.taskCategoryId !== undefined && task.taskCategoryId !== null) {
      newTaskData.taskCategoryId = task.taskCategoryId;
    }
    
    // Copy compliance fields if they exist in task
    if ('complianceFrequency' in task && task.complianceFrequency) {
      newTaskData.complianceFrequency = task.complianceFrequency;
    }
    
    if ('complianceYear' in task && task.complianceYear) {
      newTaskData.complianceYear = task.complianceYear;
    }
    
    if ('complianceDuration' in task && task.complianceDuration) {
      newTaskData.complianceDuration = task.complianceDuration;
    }
    
    if ('complianceStartDate' in task && task.complianceStartDate) {
      newTaskData.complianceStartDate = task.complianceStartDate;
    }
    
    if ('complianceEndDate' in task && task.complianceEndDate) {
      newTaskData.complianceEndDate = task.complianceEndDate;
    }
    
    if ('compliancePeriod' in task && task.compliancePeriod) {
      newTaskData.compliancePeriod = task.compliancePeriod;
    }
    
    // Copy financial fields if they exist in task
    if ('currency' in task && task.currency) {
      newTaskData.currency = task.currency;
    }
    
    if ('serviceRate' in task && task.serviceRate) {
      newTaskData.serviceRate = task.serviceRate;
    }
    
    if ('invoiceId' in task && task.invoiceId !== undefined && task.invoiceId !== null) {
      newTaskData.invoiceId = task.invoiceId;
    }
    
    // Create the new regular task
    // First, ensure we have all required fields to avoid type errors
    if (!newTaskData.tenantId || !newTaskData.assigneeId || !newTaskData.dueDate || !newTaskData.statusId) {
      console.error(`[APPROVAL] Missing required fields for creating regular task from auto-generated task ${taskId}`);
      return false;
    }
    
    // Make explicit cast to ensure type safety when creating the task
    const taskToCreate = {
      tenantId: newTaskData.tenantId,
      isAdmin: newTaskData.isAdmin || false,
      taskType: newTaskData.taskType || 'Regular',
      assigneeId: newTaskData.assigneeId,
      dueDate: newTaskData.dueDate,
      statusId: newTaskData.statusId,
      taskDetails: newTaskData.taskDetails || '',
      nextToDo: newTaskData.nextToDo || '',
      isRecurring: newTaskData.isRecurring || false,
      isAutoGenerated: false,
      parentTaskId: task.id,
      needsApproval: false,
      createdAt: new Date(),
      isCanceled: false
    };
    
    // Add optional fields if they exist in the original task
    if (task.clientId !== undefined && task.clientId !== null) {
      taskToCreate.clientId = task.clientId;
    }
    
    if (task.entityId !== undefined && task.entityId !== null) {
      taskToCreate.entityId = task.entityId;
    }
    
    // Create the task with proper type safety
    console.log(`[APPROVAL] Creating regular task with parentTaskId = ${task.id}`);
    const newTask = await storage.createTask(taskToCreate);
    
    if (!newTask) {
      console.error(`[APPROVAL] Failed to create regular task from auto-generated task ${taskId}`);
      return false;
    }
    
    console.log(`[APPROVAL] Successfully created regular task with ID ${newTask}`);
    
    // Step 6: If this task is the latest for its period, update the original template task
    if (isLatestCompliancePeriod && task.parentTaskId) {
      console.log(`[APPROVAL] This is the latest compliance period - updating template task ${task.parentTaskId}`);
      
      // Fetch the original template task
      const templateTask = await storage.getTask(task.parentTaskId, tenantId);
      
      if (templateTask) {
        console.log(`[APPROVAL] Setting template task ${templateTask.id} to non-recurring`);
        
        // Update the template task to be non-recurring since we have a regular task handling recurrence now
        await storage.updateTask(task.parentTaskId, {
          isRecurring: false,
          updatedAt: new Date()
        });
      }
    }
    
    return true;
  } catch (error) {
    console.error(`[APPROVAL] Error in approveTask for task ${taskId}:`, error);
    return false;
  }
}