/**
 * Task Approval Handler
 * 
 * This module handles the approval of auto-generated tasks and their conversion
 * to regular tasks with proper compliance period handling and parent-child relationships.
 */

import { IStorage } from "./storage";
import { format } from "date-fns";

/**
 * Calculates compliance period text based on frequency and dates
 * @param frequency The compliance frequency type (monthly, quarterly, etc.)
 * @param startDate The compliance start date
 */
export function calculateCompliancePeriod(frequency: string, startDate: Date): string {
  if (!frequency || !startDate) {
    return "";
  }

  const frequencyLower = frequency.toLowerCase();
  
  // Calculate compliance period based on frequency
  if (frequencyLower.includes('month')) {
    // Monthly format: "May 2025"
    return format(startDate, 'MMMM yyyy');
  } else if (frequencyLower.includes('quarter')) {
    // Quarterly format: "Q2 2025"
    const quarter = Math.floor(startDate.getMonth() / 3) + 1;
    return `Q${quarter} ${startDate.getFullYear()}`;
  } else if (frequencyLower.includes('annual') || frequencyLower.includes('year')) {
    if (frequencyLower.includes('5')) {
      // 5-year format: "2025-2029"
      const startYear = startDate.getFullYear();
      return `${startYear}-${startYear + 4}`;
    } else if (frequencyLower.includes('4')) {
      // 4-year format: "2025-2028"
      const startYear = startDate.getFullYear();
      return `${startYear}-${startYear + 3}`;
    } else if (frequencyLower.includes('3')) {
      // 3-year format: "2025-2027"
      const startYear = startDate.getFullYear();
      return `${startYear}-${startYear + 2}`;
    } else if (frequencyLower.includes('2')) {
      // 2-year format: "2025-2026"
      const startYear = startDate.getFullYear();
      return `${startYear}-${startYear + 1}`;
    } else {
      // Standard annual: "2025"
      return `${startDate.getFullYear()}`;
    }
  } else if (frequencyLower.includes('semi') || frequencyLower.includes('bi-annual')) {
    // Semi-annual format: "H1 2025" or "H2 2025"
    const half = startDate.getMonth() < 6 ? 1 : 2;
    return `H${half} ${startDate.getFullYear()}`;
  } else if (frequencyLower.includes('one time') || frequencyLower.includes('once')) {
    // One-time format: "May 2025 (One-time)"
    return `${format(startDate, 'MMMM yyyy')} (One-time)`;
  } else {
    // Default format for unknown frequencies
    return format(startDate, 'MMMM yyyy');
  }
}

/**
 * Converts a date to start of day (00:00:00.001)
 * @param date The date to convert
 */
export function setStartOfDay(date: Date): Date {
  const newDate = new Date(date);
  newDate.setHours(0, 0, 0, 1); // 00:00:00.001
  return newDate;
}

/**
 * Converts a date to end of day (23:59:59.999)
 * @param date The date to convert
 */
export function setEndOfDay(date: Date): Date {
  const newDate = new Date(date);
  newDate.setHours(23, 59, 59, 999); // 23:59:59.999
  return newDate;
}

/**
 * Approves an auto-generated task and creates a regular task
 * 
 * This function handles:
 * 1. Converting an auto-generated task to a regular task
 * 2. Setting up proper parent-child relationships
 * 3. Handling the isRecurring flag properly (only latest task should have isRecurring=true)
 * 4. Calculating and storing compliance periods
 * 
 * @param storage The storage interface
 * @param autoGenTaskId The ID of the auto-generated task to approve
 * @param tenantId The tenant ID
 */
export async function approveTask(storage: IStorage, autoGenTaskId: number, tenantId: number): Promise<boolean> {
  try {
    // Get the auto-generated task
    const autoGenTask = await storage.getAutoGeneratedTask(autoGenTaskId, tenantId);
    if (!autoGenTask) {
      console.error(`Auto-generated task with ID ${autoGenTaskId} not found for tenant ${tenantId}`);
      return false;
    }

    // Check if the task requires approval
    if (!autoGenTask.needsApproval) {
      console.error(`Auto-generated task with ID ${autoGenTaskId} does not require approval`);
      return false;
    }

    // Create the compliance period based on frequency and dates
    let compliancePeriod = "";
    if (autoGenTask.compliance_frequency && autoGenTask.compliance_start_date) {
      compliancePeriod = calculateCompliancePeriod(
        autoGenTask.compliance_frequency,
        new Date(autoGenTask.compliance_start_date)
      );
    }

    // Fix date handling for compliance start and end dates
    let complianceStartDate = autoGenTask.compliance_start_date 
      ? setStartOfDay(new Date(autoGenTask.compliance_start_date))
      : undefined;
    
    let complianceEndDate = autoGenTask.compliance_end_date
      ? setEndOfDay(new Date(autoGenTask.compliance_end_date))
      : undefined;

    // Determine if this is the latest recurring task
    // Only the latest compliance period task should have isRecurring=true
    let isLatestRecurringTask = false;
    
    if (autoGenTask.is_recurring) {
      // Find all auto-generated tasks with the same parent_task_id to determine if this is the latest
      const relatedAutoTasks = await storage.getAutoGeneratedTasks(
        tenantId,
        autoGenTask.client_id,
        autoGenTask.entity_id
      );
      
      // Filter to tasks with the same parent task id (tasks in the same series)
      // This ensures we're only comparing tasks that are part of the same recurring series
      const sameParentTasks = relatedAutoTasks.filter(t => 
        t.parent_task_id === autoGenTask.parent_task_id
      );
      
      // Sort by compliance start date to find the latest
      const sortedTasks = sameParentTasks.sort((a, b) => {
        const dateA = a.compliance_start_date ? new Date(a.compliance_start_date).getTime() : 0;
        const dateB = b.compliance_start_date ? new Date(b.compliance_start_date).getTime() : 0;
        return dateB - dateA; // descending order
      });
      
      // Check if current task is the latest
      isLatestRecurringTask = sortedTasks.length > 0 && sortedTasks[0].id === autoGenTask.id;
      
      console.log(`Task ${autoGenTask.id} isLatestRecurringTask: ${isLatestRecurringTask}`);
      console.log(`Found ${sameParentTasks.length} tasks with same parent_task_id: ${autoGenTask.parent_task_id}`);
    }

    // Create the regular task
    const newTask = await storage.createTask({
      tenantId: autoGenTask.tenant_id,
      isAdmin: autoGenTask.is_admin,
      taskType: autoGenTask.task_type,
      clientId: autoGenTask.client_id || null,
      entityId: autoGenTask.entity_id || null,
      serviceTypeId: autoGenTask.service_type_id || null,
      taskCategoryId: autoGenTask.task_category_id || null,
      assigneeId: autoGenTask.assignee_id,
      dueDate: new Date(autoGenTask.due_date),
      statusId: autoGenTask.status_id,
      taskDetails: autoGenTask.task_details || null,
      nextToDo: autoGenTask.next_to_do || null,
      isRecurring: isLatestRecurringTask, // Only set to true if this is the latest recurring task
      complianceFrequency: autoGenTask.compliance_frequency || null,
      complianceYear: autoGenTask.compliance_year || null,
      complianceDuration: autoGenTask.compliance_duration || null,
      complianceStartDate: complianceStartDate,
      complianceEndDate: complianceEndDate,
      compliancePeriod: compliancePeriod || null,
      currency: autoGenTask.currency || null,
      serviceRate: autoGenTask.service_rate || null,
      invoiceId: autoGenTask.invoice_id || null,
      parentTaskId: autoGenTask.parent_task_id || null,
    });

    // Mark the auto-generated task as approved (not needing approval anymore)
    await storage.updateAutoGeneratedTask(autoGenTask.id, {
      needs_approval: false
    });

    console.log(`Successfully approved task with ID ${autoGenTaskId} and created regular task with ID ${newTask.id}`);
    return true;
  } catch (error) {
    console.error('Error in approveTask:', error);
    return false;
  }
}