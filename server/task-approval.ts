import { IStorage } from './storage';
import { format } from 'date-fns';

/**
 * This module handles approval of auto-generated tasks
 * using a single-table approach where all tasks (including auto-generated ones) 
 * are stored in a single 'tasks' table
 */
export class TaskApproval {
  private storage: IStorage;

  constructor(storage: IStorage) {
    this.storage = storage;
  }

  /**
   * Calculate compliance period based on frequency and start date
   */
  public calculateCompliancePeriod(frequency: string, startDate: Date): string {
    if (!frequency || !startDate) {
      return "";
    }

    const frequencyLower = frequency.toLowerCase();
    
    // Calculate compliance period based on frequency
    if (frequencyLower.includes('month')) {
      // Monthly format: "May 2025"
      return format(startDate, 'MMMM yyyy');
    } else if (frequencyLower.includes('quarter')) {
      // Quarterly format: "Q2 2025"
      const quarter = Math.floor(startDate.getMonth() / 3) + 1;
      return `Q${quarter} ${startDate.getFullYear()}`;
    } else if (frequencyLower.includes('annual') || frequencyLower.includes('year')) {
      if (frequencyLower.includes('5')) {
        // 5-year format: "2025-2029"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 4}`;
      } else if (frequencyLower.includes('4')) {
        // 4-year format: "2025-2028"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 3}`;
      } else if (frequencyLower.includes('3')) {
        // 3-year format: "2025-2027"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 2}`;
      } else if (frequencyLower.includes('2')) {
        // 2-year format: "2025-2026"
        const startYear = startDate.getFullYear();
        return `${startYear}-${startYear + 1}`;
      } else {
        // Standard annual: "2025"
        return `${startDate.getFullYear()}`;
      }
    } else if (frequencyLower.includes('semi') || frequencyLower.includes('bi-annual')) {
      // Semi-annual format: "H1 2025" or "H2 2025"
      const half = startDate.getMonth() < 6 ? 1 : 2;
      return `H${half} ${startDate.getFullYear()}`;
    } else if (frequencyLower.includes('one time') || frequencyLower.includes('once')) {
      // One-time format: "May 2025 (One-time)"
      return `${format(startDate, 'MMMM yyyy')} (One-time)`;
    } else {
      // Default format for unknown frequencies
      return format(startDate, 'MMMM yyyy');
    }
  }

  /**
   * Get all tasks that need approval
   * Uses the single table approach by filtering for tasks with needsApproval=true
   */
  public async getTasksNeedingApproval(tenantId: number) {
    const tasks = await this.storage.getTasks(tenantId);
    return tasks.filter(task => 
      task.isAutoGenerated === true && 
      task.needsApproval === true);
  }

  /**
   * Approve a task (makes it a regular task)
   * When approved, changes needsApproval to false
   * and keeps track of original template task
   */
  public async approveTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      // Get the auto-generated task
      const task = await this.storage.getTaskById(taskId);
      
      if (!task || task.tenantId !== tenantId) {
        console.error(`Task ${taskId} not found or doesn't belong to tenant ${tenantId}`);
        return false;
      }
      
      if (!task.isAutoGenerated || !task.needsApproval) {
        console.error(`Task ${taskId} is not an auto-generated task pending approval`);
        return false;
      }
      
      // For the parent (template) task, find if this is the latest approval and toggle isRecurring flag accordingly
      if (task.parentTaskId) {
        const templateTask = await this.storage.getTaskById(task.parentTaskId);
        
        if (templateTask) {
          // Find all generated tasks from this template
          const allTasks = await this.storage.getTasks(tenantId);
          const childTasks = allTasks.filter(t => t.parentTaskId === templateTask.id);
          
          // Find the latest child task by compliance period (assuming chronological ordering)
          let latestChild = task;
          for (const childTask of childTasks) {
            if (childTask.id !== task.id && childTask.complianceStartDate) {
              if (!latestChild.complianceStartDate || 
                  new Date(childTask.complianceStartDate) > new Date(latestChild.complianceStartDate)) {
                latestChild = childTask;
              }
            }
          }
          
          // If this is the latest child, set isRecurring to true, 
          // otherwise ensure isRecurring is false to maintain one-to-one relationship
          const isLatest = latestChild.id === task.id;
          
          // Update template task (keep recurring flag on template)
          await this.storage.updateTask(templateTask.id, {
            updatedAt: new Date()
          });
          
          // Update this task
          await this.storage.updateTask(task.id, {
            isRecurring: isLatest, // Only the latest task should be recurring
            needsApproval: false,  // Approved
            updatedAt: new Date()
          });
          
          // Update other child tasks to ensure only one is recurring
          if (isLatest) {
            for (const childTask of childTasks) {
              if (childTask.id !== task.id && childTask.isRecurring) {
                await this.storage.updateTask(childTask.id, {
                  isRecurring: false,
                  updatedAt: new Date()
                });
              }
            }
          }
          
          console.log(`Approved auto-generated task ${taskId}, set as ${isLatest ? '' : 'non-'}recurring`);
          return true;
        }
      }
      
      // Fallback if parent task not found
      await this.storage.updateTask(task.id, {
        needsApproval: false,
        updatedAt: new Date()
      });
      
      console.log(`Approved auto-generated task ${taskId}`);
      return true;
    } catch (error) {
      console.error(`Error approving task ${taskId}:`, error);
      return false;
    }
  }

  /**
   * Approve all pending tasks for a tenant
   */
  public async approveAllPendingTasks(tenantId: number): Promise<number> {
    try {
      // Find all auto-generated tasks that need approval
      const pendingTasks = await this.getTasksNeedingApproval(tenantId);
      let approvedCount = 0;
      
      // Approve them one by one to maintain proper recurring flags
      for (const task of pendingTasks) {
        const approved = await this.approveTask(task.id, tenantId);
        if (approved) {
          approvedCount++;
        }
      }
      
      console.log(`Approved ${approvedCount} pending tasks for tenant ${tenantId}`);
      return approvedCount;
    } catch (error) {
      console.error(`Error approving all pending tasks for tenant ${tenantId}:`, error);
      return 0;
    }
  }

  /**
   * Reject a task (delete it)
   */
  public async rejectTask(taskId: number, tenantId: number): Promise<boolean> {
    try {
      const task = await this.storage.getTaskById(taskId);
      
      if (!task || task.tenantId !== tenantId) {
        console.error(`Task ${taskId} not found or doesn't belong to tenant ${tenantId}`);
        return false;
      }
      
      if (!task.isAutoGenerated || !task.needsApproval) {
        console.error(`Task ${taskId} is not an auto-generated task pending approval`);
        return false;
      }
      
      await this.storage.deleteTask(taskId);
      console.log(`Rejected and deleted auto-generated task ${taskId}`);
      return true;
    } catch (error) {
      console.error(`Error rejecting task ${taskId}:`, error);
      return false;
    }
  }
}