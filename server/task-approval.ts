/**
 * task-approval.ts
 * 
 * This module provides an improved implementation for approving auto-generated tasks
 * and converting them to regular tasks in the task management system.
 * 
 * The key improvement is that when an auto-generated task is approved, only that specific
 * task instance is moved to the Tasks module while other instances remain in the 
 * Auto Generated Tasks module.
 */

import { IStorage } from "./storage";
import { format } from "date-fns";
import { Task, InsertTask } from "@shared/schema";

/**
 * Approve a specific auto-generated task and convert it to a regular task
 * 
 * This is a completely rewritten implementation that ensures:
 * 1. Only the specific approved task (by ID) is moved to the Tasks Module
 * 2. Multiple instances of the same template task are handled correctly
 * 3. The approved task is properly tracked in the database
 * 
 * @param storage - The data storage implementation
 * @param taskId - The ID of the specific auto-generated task to approve
 * @param tenantId - The tenant ID for security validation
 * @returns A boolean indicating success or failure
 */
export async function approveTask(
  storage: IStorage, 
  taskId: number, 
  tenantId: number
): Promise<boolean> {
  try {
    // Step 1: Get the specific auto-generated task by ID
    const task = await storage.getTask(taskId, tenantId);
    
    // Basic validation
    if (!task) {
      console.log(`Task ${taskId} not found for tenant ${tenantId}`);
      return false;
    }
    
    if (!task.isAutoGenerated) {
      console.log(`Task ${taskId} is not an auto-generated task`);
      return false;
    }
    
    if (!task.needsApproval) {
      console.log(`Task ${taskId} does not need approval (already processed)`);
      return false;
    }
    
    console.log(`Processing approval for auto-generated task ${taskId}`);
    
    // Log task details with checks to avoid undefined references
    const clientId = task.clientId !== undefined ? task.clientId : 'none';
    const entityId = task.entityId !== undefined ? task.entityId : 'none';
    const serviceId = task.serviceTypeId !== undefined ? task.serviceTypeId : 'none';
    
    console.log(`Task details: client: ${clientId}, entity: ${entityId}, service: ${serviceId}`);
    
    if (task.complianceStartDate && task.complianceEndDate) {
      console.log(`Compliance period: ${format(new Date(task.complianceStartDate), 'yyyy-MM-dd')} to ${format(new Date(task.complianceEndDate), 'yyyy-MM-dd')}`);
    }
    
    // Step 2: Check if a regular task already exists for this specific auto-generated task
    // We use a more targeted query to check for direct parent-child relationship
    const existingTasks = await storage.getTasks(tenantId);
    console.log(`Checking for existing regular tasks with parentTaskId = ${task.id}`);
    
    const regularTaskExists = existingTasks.some(existingTask => {
      const isRegularTask = !existingTask.isAutoGenerated;
      const hasParentLink = existingTask.parentTaskId === task.id;
      if (isRegularTask && hasParentLink) {
        console.log(`Found existing regular task ${existingTask.id} with direct parent link to task ${task.id}`);
        return true;
      }
      return false;
    });
    
    if (regularTaskExists) {
      console.log(`Regular task already exists for auto-generated task ${task.id}. Not creating duplicate.`);
      
      // Just update the auto-generated task to no longer need approval
      await storage.updateTask(taskId, {
        needsApproval: false,
        updatedAt: new Date()
      });
      
      return true;
    }
    
    // Step 3: Determine if this is the latest compliance period (for setting isRecurring flag)
    let isLatestCompliancePeriod = true;
    
    if (task.parentTaskId && task.complianceEndDate) {
      const currentTaskEndDate = new Date(task.complianceEndDate);
      
      // Find sibling auto-generated tasks with the same parent
      const siblingTasks = existingTasks.filter(existingTask => {
        if (!existingTask.isAutoGenerated || existingTask.id === task.id) {
          return false;
        }
        
        // Safe comparison taking into account optional fields
        const sameParent = existingTask.parentTaskId === task.parentTaskId;
        const sameClient = existingTask.clientId === task.clientId;
        const sameEntity = existingTask.entityId === task.entityId;
        const sameService = existingTask.serviceTypeId === task.serviceTypeId;
        
        return sameParent && sameClient && sameEntity && sameService;
      });
      
      // Check if any sibling has a later compliance period
      for (const sibling of siblingTasks) {
        if (sibling.complianceEndDate) {
          const siblingEndDate = new Date(sibling.complianceEndDate);
          
          if (siblingEndDate > currentTaskEndDate) {
            isLatestCompliancePeriod = false;
            console.log(`This task is not the latest period - found newer period: ${format(siblingEndDate, 'yyyy-MM-dd')}`);
            break;
          }
        }
      }
    }
    
    // Step 4: Update the auto-generated task to mark it as processed but KEEP IT as auto-generated
    const updateData = {
      needsApproval: false, // No longer needs approval
      updatedAt: new Date() // Track when it was processed
    };
    
    console.log(`Updating auto-generated task ${taskId} to mark as processed`);
    await storage.updateTask(taskId, updateData);
    
    // Step 5: Create a NEW regular task as a copy of the auto-generated task
    const isOneTime = task.complianceFrequency?.toLowerCase() === 'one time' || 
                      task.complianceFrequency?.toLowerCase() === 'once';
    
    // Create the new task with the required fields
    // Use a strict type definition to ensure all required fields are included
    const newTaskData = {
      tenantId: task.tenantId,
      isAdmin: task.isAdmin || false,
      taskType: task.taskType || 'Regular',
      assigneeId: task.assigneeId,
      dueDate: task.dueDate,
      statusId: task.statusId,
      taskDetails: task.taskDetails || '',
      nextToDo: task.nextToDo || '',
      isRecurring: !isOneTime && isLatestCompliancePeriod, // Only latest period should be recurring
      isAutoGenerated: false, // This makes it a regular task
      parentTaskId: task.id, // Link to the specific auto-generated task that was approved
      needsApproval: false, // Regular tasks never need approval
      createdAt: new Date(),
      isCanceled: false
    };
    
    // Safely copy optional fields only if they exist
    if (task.clientId !== undefined && task.clientId !== null) {
      newTaskData.clientId = task.clientId;
    }
    
    if (task.entityId !== undefined && task.entityId !== null) {
      newTaskData.entityId = task.entityId;
    }
    
    if (task.serviceTypeId !== undefined && task.serviceTypeId !== null) {
      newTaskData.serviceTypeId = task.serviceTypeId;
    }
    
    if (task.taskCategoryId !== undefined && task.taskCategoryId !== null) {
      newTaskData.taskCategoryId = task.taskCategoryId;
    }
    
    // Copy compliance fields
    if (task.complianceFrequency) newTaskData.complianceFrequency = task.complianceFrequency;
    if (task.complianceYear) newTaskData.complianceYear = task.complianceYear;
    if (task.complianceDuration) newTaskData.complianceDuration = task.complianceDuration;
    if (task.complianceStartDate) newTaskData.complianceStartDate = task.complianceStartDate;
    if (task.complianceEndDate) newTaskData.complianceEndDate = task.complianceEndDate;
    if (task.compliancePeriod) newTaskData.compliancePeriod = task.compliancePeriod;
    
    // Copy financial fields
    if (task.currency) newTaskData.currency = task.currency;
    if (task.serviceRate) newTaskData.serviceRate = task.serviceRate;
    if (task.invoiceId !== undefined && task.invoiceId !== null) {
      newTaskData.invoiceId = task.invoiceId;
    }
    
    console.log(`Creating new regular task as a copy of auto-generated task ${taskId}`);
    
    // Create the new regular task
    const newTaskId = await storage.createTask(newTaskData);
    
    if (!newTaskId) {
      console.error(`Failed to create new regular task from auto-generated task ${taskId}`);
      return false;
    }
    
    console.log(`Successfully created regular task for auto-generated task ${taskId}`);
    
    // Step 6: If this task is the latest for its period, update the original template task
    // to be non-recurring since the latest instance will now handle recurrence
    if (isLatestCompliancePeriod && task.parentTaskId) {
      console.log(`This is the latest compliance period - updating template task ${task.parentTaskId}`);
      
      // Fetch the original template task to ensure it exists
      const templateTask = await storage.getTask(task.parentTaskId, tenantId);
      
      if (templateTask) {
        console.log(`Updating template task ${templateTask.id} to non-recurring`);
        
        // Update the template task to be non-recurring
        await storage.updateTask(task.parentTaskId, {
          isRecurring: false,
          updatedAt: new Date()
        });
      }
    }
    
    return true;
  } catch (error) {
    console.error(`Error approving task ${taskId}:`, error);
    return false;
  }
}