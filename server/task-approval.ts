/**
 * task-approval.ts
 * 
 * This module provides an improved implementation for approving auto-generated tasks
 * and converting them to regular tasks in the task management system.
 * 
 * The key improvement is that when an auto-generated task is approved, only that specific
 * task instance is moved to the Tasks module while other instances remain in the 
 * Auto Generated Tasks module.
 */

import { IStorage } from "./storage";
import { format } from "date-fns";
import { Task, InsertTask } from "@shared/schema";

/**
 * Approve a specific auto-generated task and convert it to a regular task
 * 
 * This is a completely rewritten implementation that ensures:
 * 1. Only the specific approved task (by ID) is moved to the Tasks Module
 * 2. Multiple instances of the same template task are handled correctly
 * 3. The approved task is properly tracked in the database
 * 
 * @param storage - The data storage implementation
 * @param taskId - The ID of the specific auto-generated task to approve
 * @param tenantId - The tenant ID for security validation
 * @returns A boolean indicating success or failure
 */
export async function approveTask(
  storage: IStorage, 
  taskId: number, 
  tenantId: number
): Promise<boolean> {
  try {
    console.log(`[TASK APPROVAL] Starting approval process for auto-generated task ID ${taskId}`);
    
    // Step 1: Get the specific auto-generated task by ID
    const task = await storage.getTask(taskId, tenantId);
    
    // Basic validation
    if (!task) {
      console.log(`[TASK APPROVAL] Task ${taskId} not found for tenant ${tenantId}`);
      return false;
    }
    
    if (!task.isAutoGenerated) {
      console.log(`[TASK APPROVAL] Task ${taskId} is not an auto-generated task`);
      return false;
    }
    
    if (!task.needsApproval) {
      console.log(`[TASK APPROVAL] Task ${taskId} does not need approval (already processed)`);
      return false;
    }
    
    // Log task details with checks to avoid undefined references
    const clientId = task.clientId !== undefined ? task.clientId : 'none';
    const entityId = task.entityId !== undefined ? task.entityId : 'none';
    const serviceId = task.serviceTypeId !== undefined ? task.serviceTypeId : 'none';
    
    console.log(`[TASK APPROVAL] Processing task: client: ${clientId}, entity: ${entityId}, service: ${serviceId}`);
    
    // Step 2: CRITICAL SAFETY CHECK - Check if a regular task already exists with this specific task as parent
    // This prevents creating duplicate regular tasks for the same auto-generated task
    const existingTasks = await storage.getTasks(tenantId);
    const regularTasksWithThisParent = existingTasks.filter(existingTask => 
      !existingTask.isAutoGenerated && existingTask.parentTaskId === task.id
    );
    
    if (regularTasksWithThisParent.length > 0) {
      console.log(`[TASK APPROVAL] Found ${regularTasksWithThisParent.length} existing regular task(s) with parent ID ${task.id} - NOT creating another one`);
      
      // Just mark the auto-generated task as processed and return
      await storage.updateTask(taskId, {
        needsApproval: false,
        updatedAt: new Date()
      });
      
      return true;
    }
    
    // Step 3: Mark the auto-generated task as processed to prevent double-approval
    console.log(`[TASK APPROVAL] Marking auto-generated task ${taskId} as processed (needsApproval = false)`);
    
    await storage.updateTask(taskId, {
      needsApproval: false,
      updatedAt: new Date()
    });
    
    // Step 4: Simplified "latest compliance period" check - find the task with the latest end date
    let isLatestCompliancePeriod = true;
    
    // First determine if this is a one-time task or not
    const isOneTime = task.complianceFrequency?.toLowerCase() === 'one time' || 
                      task.complianceFrequency?.toLowerCase() === 'once';
    
    // Only run this check for non-one-time tasks that have a parent and end date
    if (!isOneTime && task.parentTaskId && task.complianceEndDate) {
      const currentTaskEndDate = new Date(task.complianceEndDate);
      
      // Find all other tasks with the same parent template
      const siblingTasks = existingTasks.filter(t => 
        t.isAutoGenerated && 
        t.parentTaskId === task.parentTaskId &&
        t.id !== task.id // exclude current task
      );
      
      // Check if any sibling has a LATER compliance period
      for (const sibling of siblingTasks) {
        if (sibling.complianceEndDate) {
          const siblingEndDate = new Date(sibling.complianceEndDate);
          
          if (siblingEndDate > currentTaskEndDate) {
            // We found a task with a later end date, so this is NOT the latest period
            isLatestCompliancePeriod = false;
            console.log(`[TASK APPROVAL] This is NOT the latest period - found task with later period ending ${siblingEndDate.toISOString()}`);
            break;
          }
        }
      }
      
      if (isLatestCompliancePeriod) {
        console.log(`[TASK APPROVAL] This IS the latest compliance period (end date: ${currentTaskEndDate.toISOString()})`);
      }
    }
    
    // Step 5: Create the regular task (only if we passed the duplicate check)
    // First, ensure all required fields are present
    if (!task.tenantId || !task.assigneeId || !task.dueDate || !task.statusId) {
      console.error(`[TASK APPROVAL] ERROR: Missing required fields for task creation`);
      return false;
    }
    
    console.log(`[TASK APPROVAL] Creating new regular task as a copy of auto-generated task ${taskId}`);
    
    // Create a task object with required fields
    const regularTask: Record<string, any> = {
      tenantId: task.tenantId,
      isAdmin: task.isAdmin || false,
      taskType: task.taskType || 'Regular',
      assigneeId: task.assigneeId,
      dueDate: task.dueDate,
      statusId: task.statusId,
      taskDetails: task.taskDetails || '',
      nextToDo: task.nextToDo || '',
      
      // KEY FIELDS:
      isAutoGenerated: false,                     // This makes it a regular task
      needsApproval: false,                       // Regular tasks don't need approval
      parentTaskId: task.id,                      // Link directly to the approved auto task
      isRecurring: !isOneTime && isLatestCompliancePeriod, // Only recurring if it's the latest period
      
      // Metadata
      createdAt: new Date(),
      isCanceled: false
    };
    
    // Copy client, entity, and service details
    if (task.clientId !== undefined && task.clientId !== null) regularTask.clientId = task.clientId;
    if (task.entityId !== undefined && task.entityId !== null) regularTask.entityId = task.entityId;
    if (task.serviceTypeId !== undefined && task.serviceTypeId !== null) regularTask.serviceTypeId = task.serviceTypeId;
    if (task.taskCategoryId !== undefined && task.taskCategoryId !== null) regularTask.taskCategoryId = task.taskCategoryId;
    
    // Copy compliance fields
    if (task.complianceFrequency) regularTask.complianceFrequency = task.complianceFrequency;
    if (task.complianceYear) regularTask.complianceYear = task.complianceYear;
    if (task.complianceDuration) regularTask.complianceDuration = task.complianceDuration;
    if (task.complianceStartDate) regularTask.complianceStartDate = task.complianceStartDate;
    if (task.complianceEndDate) regularTask.complianceEndDate = task.complianceEndDate;
    if (task.compliancePeriod) regularTask.compliancePeriod = task.compliancePeriod;
    
    // Copy financial fields
    if (task.currency) regularTask.currency = task.currency;
    if (task.serviceRate !== undefined) regularTask.serviceRate = task.serviceRate;
    if (task.invoiceId !== undefined && task.invoiceId !== null) regularTask.invoiceId = task.invoiceId;
    
    // Create the regular task in the database
    console.log(`[TASK APPROVAL] Creating regular task with direct link to auto task (parentTaskId=${task.id})`);
    try {
      // Cast to any to bypass type checking since we've carefully constructed the object
      const newTaskId = await storage.createTask(regularTask as any);
      
      if (!newTaskId) {
        console.error(`[TASK APPROVAL] Failed to create regular task`);
        return false;
      }
      
      console.log(`[TASK APPROVAL] ✓ Successfully created regular task with ID ${newTaskId}`);
      
      // Step 6: If this is the latest period, update the original template task's recurring status
      if (isLatestCompliancePeriod && task.parentTaskId) {
        const templateId = task.parentTaskId;
        console.log(`[TASK APPROVAL] This is the latest period - updating original template task ${templateId}`);
        
        // Get the template task
        const templateTask = await storage.getTask(templateId, tenantId);
        
        if (templateTask) {
          // Since we now have a regular task for the latest period, we can stop the template from recurring
          await storage.updateTask(templateId, {
            isRecurring: false,
            updatedAt: new Date()
          });
          console.log(`[TASK APPROVAL] ✓ Updated template task ${templateId} - set isRecurring to false`);
        }
      }
      
      return true;
    } catch (error) {
      console.error(`[TASK APPROVAL] Error creating regular task:`, error);
      return false;
    }
  } catch (error) {
    console.error(`[TASK APPROVAL] Error in approval process:`, error);
    return false;
  }
}