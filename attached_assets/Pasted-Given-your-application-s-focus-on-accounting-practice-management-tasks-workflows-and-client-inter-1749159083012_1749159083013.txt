Given your application's focus on accounting practice management, tasks, workflows, and client interactions, a robust notification system is crucial for keeping users informed and driving action.
Feature Document: Internal Notification System
1. Introduction & Goals
Feature Name: Internal Notification System
Project: AccFirm - Accounting Firm Practice Management Software
Goal: To implement a comprehensive, real-time internal notification system that informs users (firm staff) about important events, updates, assignments, and required actions within the application. This system aims to:
Enhance team collaboration and communication.
Improve responsiveness and task accountability.
Reduce missed deadlines and overlooked information.
Provide a centralized way for users to stay updated without constant manual checking.
Integrate seamlessly with key modules like Tasks, Clients, Workflow Automation, Finance, and AI Features.
2. Target Users & Use Cases
Target Users: All internal firm staff (SuperAdmins, Members with various roles/permissions).
Key Use Cases:
Task Management:
User is assigned a new task.
A task assigned to the user is updated (status change, due date change, description change).
A task created by the user is completed by someone else.
A user is @mentioned in a task chat/comment.
A task assigned to the user is approaching its due date or becomes overdue.
Workflow Automation:
A workflow requires user approval (e.g., auto-generated task approval).
A workflow action results in an item needing user attention (e.g., "Draft invoice ready for review").
A workflow fails and requires admin intervention.
Client Management:
A new client is assigned to the user.
(If client portal interactions trigger internal notifications) A client uploads a document requiring review.
A client sends a message via the (future) Client Portal secure messaging.
Finance Module:
An invoice generated by the user is paid.
A payment allocation requires review/approval.
AI Features:
AI suggests a service for a client managed by the user.
AI identifies a potential compliance risk for a client managed by the user.
System & Security:
User's permissions are changed (optional, admin configurable).
A critical system event occurs (e.g., AI provider API key invalid).
Internal Communication:
General announcements sent by an Admin (broadcast notifications).
3. Functional Requirements
F1. Notification Creation:
System-triggered notifications (based on events in other modules).
User-triggered notifications (e.g., @mentions).
Admin-triggered broadcast notifications (optional).
F2. Notification Delivery:
Real-time In-App: Notifications should appear promptly within the application interface using WebSockets.
Persistence: Notifications must be stored in the database for users to review later.
F3. User Interface (In-App):
Notification Bell/Indicator: A clearly visible icon (e.g., a bell) in the main application header, displaying a badge with the count of unread notifications.
Notification Panel/Dropdown: Clicking the bell opens a panel showing a list of recent notifications (mix of unread and recently read).
Each item should display: Icon (based on type), Title, brief Message Snippet, Timestamp (e.g., "2m ago," "1h ago"), Unread Indicator.
Clicking a notification should mark it as read and navigate the user to the relevant context (deep linking).
Dedicated Notifications Page: A full page accessible from the panel (e.g., "/notifications") displaying all of the user's notifications with pagination, filtering, and sorting.
F4. Notification Content:
Title: Clear, concise summary.
Message Body: More detailed information. Should support basic formatting and variable substitution (e.g., "Task '{{task.title}}' assigned to you.").
Type: Categorization (e.g., TASK_ASSIGNMENT, MENTION, WORKFLOW_APPROVAL, CLIENT_UPDATE, SYSTEM_ALERT).
Severity: (Optional, for visual distinction) INFO, WARNING, ERROR, SUCCESS.
Link URL (Deep Link): A URL within the application to navigate to the relevant item (e.g., /tasks/123, /clients/45/entities/6).
Timestamp: When the notification was generated.
F5. Notification Management by User:
Mark individual notifications as read.
Mark all notifications as read.
(Future) Delete notifications (soft delete preferably).
F6. Filtering & Sorting (on dedicated page):
Filter by read/unread status.
Filter by notification type.
Filter by date range.
Sort by date (newest/oldest).
F7. Targeting:
Notifications can be targeted to:
Specific users.
Users with specific roles/designations within a tenant.
All users within a tenant (for broadcasts).
F8. @Mentions:
When a user is mentioned (@username) in supported contexts (e.g., task chat), they receive a specific "mention" notification.
F9. User Preferences (Future - Phase 2):
Allow users to customize which types of notifications they receive in-app.
(Future) Opt-in for email digests of unread notifications.
4. Technical Specifications & Architecture
A1. Database Schema (notifications table):
id (PK, UUID or SERIAL)
tenantId (FK, NOT NULL)
userId (FK to users - recipient, NOT NULL)
title (VARCHAR, NOT NULL)
messageBody (TEXT, NOT NULL)
linkUrl (VARCHAR, NULLABLE - for deep linking)
isRead (BOOLEAN, DEFAULT false, INDEXED)
type (VARCHAR, NOT NULL, INDEXED - e.g., 'TASK_ASSIGNMENT', 'MENTION')
severity (VARCHAR, NULLABLE - e.g., 'INFO', 'WARNING')
triggeredByUserId (FK to users - who/what caused it, NULLABLE for system)
relatedModule (VARCHAR, NULLABLE - e.g., 'Tasks', 'Workflows')
relatedEntityId (VARCHAR/INT, NULLABLE - ID of the task, workflow, etc.)
createdAt (TIMESTAMP, DEFAULT NOW(), INDEXED)
readAt (TIMESTAMP, NULLABLE)
A2. Backend Services (NotificationService):
createNotification(data: CreateNotificationDto):
Handles creation, saving to DB.
Resolves recipients if a role is provided.
Emits WebSocket event after saving.
getNotificationsForUser(userId, tenantId, options): Fetches with pagination/filtering.
getUnreadNotificationCount(userId, tenantId): Optimized count query.
markNotificationAsRead(notificationId, userId, tenantId).
markAllNotificationsAsRead(userId, tenantId).
A3. API Endpoints (RESTful, protected by user context & tenantId):
GET /api/v1/me/notifications (with query params for pagination, filtering)
GET /api/v1/me/notifications/unread-count
PUT /api/v1/me/notifications/:notificationId/read
PUT /api/v1/me/notifications/mark-all-read
(Internal Endpoint for other services, e.g., Workflow Automation): POST /api/v1/internal/notifications (requires secure service-to-service auth or elevated permissions).
A4. Real-time Communication (WebSockets - e.g., socket.io):
Server emits new_notification event to specific user rooms (e.g., user_room_${tenantId}_${userId}).
Client listens for this event to update UI (bell count, prepend to panel if open).
A5. Integration Points (Key Modules that will trigger notifications):
Tasks Module: On assignment, status change, due date, mentions.
Workflow Automation Module: For approvals, alerts, completion/failure notifications. NotificationService.createNotification will be a standard "action" type.
User Management: (Optional) On permission changes.
Client Management / Client Portal Interaction: If client actions (e.g., document upload, message) need to notify internal staff.
AI Features Module: For AI-generated suggestions or alerts needing user review.
A6. Security:
Strict tenantId and userId scoping for all notification data access.
Sanitize any user-generated content used in notification messages to prevent XSS.
Deep links must be validated and also respect user permissions for the target resource.
5. Non-Functional Requirements
NFR1. Performance:
Fetching unread count must be very fast.
Loading the notification panel/page should be performant even with many notifications (pagination is key).
Real-time delivery should have minimal latency.
NFR2. Scalability: The system should handle a growing number of users and notification volume per tenant.
NFR3. Reliability: Notifications should not be lost. WebSocket connections should be resilient.
NFR4. Usability: The notification UI should be intuitive and non-intrusive.
NFR5. Maintainability: Code should be well-structured and easy to extend with new notification types.
6. User Interface (UI/UX) Considerations
Visual Cues: Use distinct icons for different notification types. Colors for severity (if implemented) should be consistent with application theme (Shadcn/UI).
Clarity: Messages should be clear, concise, and actionable.
Grouping (Future): Consider grouping similar notifications if volume becomes very high (e.g., "3 new tasks assigned to you" instead of 3 separate notifications in quick succession, though individual entries are still good for the list).
"Do Not Disturb" (Future): Consider a temporary mute or "focus mode" setting.
7. Out of Scope for Initial Release (Phase 2 or Later)
Email notifications / digests.
Push notifications (mobile/desktop app).
Advanced user preference center for fine-grained control over every notification type.
Admin analytics on notification engagement.
Snoozing notifications.
8. Instructions for Replit AI Agent
"AI, please develop the 'Internal Notification System' as outlined in this document.
Key areas of focus:
Database Schema: Implement the notifications table using Drizzle ORM as specified.
Backend Services & APIs: Create the NotificationService and the necessary RESTful API endpoints, ensuring robust tenantId and userId filtering for all operations. Pay close attention to the internal endpoint for other services to trigger notifications.
Real-Time Layer: Integrate WebSockets (socket.io or similar, consistent with any existing WebSocket setup) for real-time delivery of new_notification events to authenticated user clients.
Frontend UI:
Develop the NotificationBell component for the main header, displaying the unread count.
Create the NotificationPanel (dropdown) for recent notifications.
Build the dedicated /notifications page with filtering, sorting, and pagination.
Ensure all UI uses Shadcn/UI components for consistency.
Integration Logic: While you won't implement all triggering events in other modules now, design the NotificationService.createNotification function to be easily callable by other modules (like Tasks, Workflow Automation) when they are enhanced to send notifications.
Mentions: Ensure the system can specifically handle notifications for '@username' mentions, linking them to the user who was mentioned.
Prioritize secure, tenant-isolated data handling and a clean, responsive user interface. Refer to the existing application structure for patterns in API design, database interaction, and frontend component development.