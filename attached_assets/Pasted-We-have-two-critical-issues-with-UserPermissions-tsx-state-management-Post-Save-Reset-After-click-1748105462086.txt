We have two critical issues with UserPermissions.tsx state management:
Post-Save Reset: After clicking "Save Permissions" for a module, its accessLevel in the UI incorrectly resets to "Restricted Access" (or its previous saved state), even if the save was successful.
Data Loss on Reload/Revisit: Saved permissions are lost (UI resets to "Restricted" for all modules) when the page is reloaded or the user navigates away and back to User Permissions.
Please implement the following fixes:
A. Address Post-Save Reset (Issue #1 in UserPermissions.tsx):
In the onSuccess callback of permissionMutation:
The API response from a successful POST/PUT should ideally return the saved/updated permission object.
Instead of just refetching immediately, first, update the local state to reflect the successful save:
Set permissionForm to the state that was just successfully saved (using the data from unsavedModulePermissions[selectedModule] or the response from the mutation if available).
Update the main permissions array (or the React Query cache for [/api/v1/users/${userId}/permissions]) optimistically with this newly saved permission data. This will prevent the useEffect that populates permissionForm from reverting to old data while the refetch is in progress.
Then, clear unsavedModulePermissions[selectedModule].
Then, call refetchPermissions() or queryClient.invalidateQueries to get the canonical state from the server, which should now match the optimistic update.
B. Address Data Loss on Reload/Revisit (Issue #2 - Likely Backend & Frontend Fetching):
Verify Backend Save (Upsert/Update Logic):
Crucially, re-examine the backend API endpoints:
POST /api/v1/user-permissions (the upsert).
PUT /api/v1/user-permissions/:id.
Ensure they are correctly and reliably saving all fields (accessLevel, canRead, canCreate, canUpdate, canDelete) to the database. Log the data being saved and confirm it in the DB. This is the most likely culprit for data loss on reload.
Verify Initial Data Fetch and Form Population (UserPermissions.tsx):
When the component mounts and useQuery for [/api/v1/users/${userId}/permissions] fetches data:
Ensure the useEffect that depends on [selectedModule, permissions, unsavedModulePermissions] correctly populates permissionForm based on the fetched permissions when unsavedModulePermissions[selectedModule] is initially empty.
If a selectedModule is active on load, the form should immediately reflect its saved permissions from the fetched permissions data. If permissions is empty or doesn't contain an entry for the selectedModule, it should correctly default to "Restricted" with all CRUDs false.
Debugging Steps for the AI:
Backend Logs: Add detailed logging in the backend save/upsert permission routes to see exactly what data is received and what SQL operations are performed.
Frontend useEffect Logs: Add console.log statements inside the useEffect that populates permissionForm to see:
The value of selectedModule.
The content of the fetched permissions array.
The content of unsavedModulePermissions.
The existingPermission found (or not found).
The final state permissionForm is being set to.
Network Tab: Inspect the API response for POST/PUT /api/v1/user-permissions and the subsequent fetch from refetchPermissions() to see what data is coming back.
The priority is to ensure the backend save is flawless. Then, refine the frontend's optimistic update and initial load logic.