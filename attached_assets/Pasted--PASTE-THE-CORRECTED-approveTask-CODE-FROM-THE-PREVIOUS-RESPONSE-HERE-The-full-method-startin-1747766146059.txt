// PASTE THE CORRECTED approveTask CODE FROM THE PREVIOUS RESPONSE HERE
// (The full method starting with public async approveTask... and ending with the final } )
public async approveTask(taskId: number, tenantId: number): Promise<boolean> {
  try {
    console.log(`*** NEW APPROVAL LOGIC: Attempting to approve task ${taskId} for tenant ${tenantId} ***`);

    // 1. Fetch the Approved Auto-Generated Task
    const approvedTask = await this.storage.getTask(taskId, tenantId); // Ensure getTask returns full Task object

    if (!approvedTask) {
      console.error(`Task ${taskId} not found for tenant ${tenantId}`);
      return false;
    }

    if (!approvedTask.isAutoGenerated || !approvedTask.needsApproval) {
      console.warn(`Task ${taskId} is not an auto-generated task needing approval. isAutoGenerated: ${approvedTask.isAutoGenerated}, needsApproval: ${approvedTask.needsApproval}`);
      return false;
    }

    // Ensure parentTaskId exists on the approvedTask object from storage.getTask
    if (approvedTask.parentTaskId === null || approvedTask.parentTaskId === undefined) { 
      console.error(`Task ${taskId} is auto-generated but has no parentTaskId. Cannot proceed with 'baton pass'.`);
      return false;
    }

    // 2. Fetch its Original Parent Task
    const originalParentTask = await this.storage.getTask(approvedTask.parentTaskId, tenantId);

    if (!originalParentTask) {
      console.error(`Original parent task ${approvedTask.parentTaskId} not found for approved task ${taskId}.`);
      return false; 
    }

    // 3. Prepare Updates for the Approved Task (to make IT the new recurring master)
    const approvedTaskUpdates: Partial<Task> = { // Ensure Task type is imported if not globally available
      isRecurring: true,
      isAutoGenerated: false,
      needsApproval: false,
      // statusId: ID_OF_ACTIVE_STATUS, // Optional: Consider adding status update logic if needed
      updatedAt: new Date(),
    };

    // 4. Perform the Update on the Approved Task (IN PLACE)
    console.log(`Updating approved task ${approvedTask.id} with:`, JSON.stringify(approvedTaskUpdates));
    const approvedTaskUpdated = await this.storage.updateTask(approvedTask.id, approvedTaskUpdates);
    if (!approvedTaskUpdated) {
      console.error(`Failed to update approved task ${approvedTask.id}.`);
      return false;
    }
    console.log(`Approved task ${approvedTask.id} successfully updated.`);

    // 5. Prepare Updates for the Original Parent Task
    const parentTaskUpdates: Partial<Task> = { // Ensure Task type is imported
      isRecurring: false,
      // statusId: ID_OF_SUPERSEDED_STATUS, // Optional: Consider adding status update logic
      updatedAt: new Date(),
    };

    // 6. Perform the Update on the Original Parent Task (IN PLACE)
    console.log(`Updating original parent task ${originalParentTask.id} with:`, JSON.stringify(parentTaskUpdates));
    const parentTaskUpdated = await this.storage.updateTask(originalParentTask.id, parentTaskUpdates);
    if (!parentTaskUpdated) {
      // Log an error but consider if this should be a fatal error for the approval
      console.error(`Failed to update original parent task ${originalParentTask.id} to set isRecurring=false.`);
    } else {
      console.log(`Original parent task ${originalParentTask.id} successfully updated.`);
    }

    console.log(`Task ${taskId} approved successfully with 'baton pass' logic.`);
    return true;

  } catch (error) {
    console.error(`Error in approveTask for task ${taskId}:`, error);
    return false;
  }
}