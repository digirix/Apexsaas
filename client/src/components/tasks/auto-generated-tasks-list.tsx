import { useState } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { Task, Client, Entity, ServiceType } from "@shared/schema";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { format } from "date-fns";
import { 
  CheckCircle, 
  XCircle, 
  RefreshCw, 
  Calendar, 
  Clock, 
  AlertCircle,
  Loader2,
  Link,
  CalendarDays,
  FileText,
  UserCircle,
  ArrowRight,
  MoveRight,
  Ban,
  Play,
  RotateCcw,
  Trash2
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { 
  Table, 
  TableBody, 
  TableCaption, 
  TableCell, 
  TableHead, 
  TableHeader, 
  TableRow 
} from "@/components/ui/table";
import { 
  Dialog, 
  DialogContent, 
  DialogDescription, 
  DialogFooter, 
  DialogHeader, 
  DialogTitle 
} from "@/components/ui/dialog";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { Skeleton } from "@/components/ui/skeleton";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";

export function AutoGeneratedTasksList() {
  const { toast } = useToast();
  const { user } = useAuth();
  const [selectedTask, setSelectedTask] = useState<Task | null>(null);
  const [showTaskDialog, setShowTaskDialog] = useState(false);
  
  // Fetch auto-generated tasks that need approval
  const { 
    data: autoGeneratedTasks = [], 
    isLoading,
    refetch
  } = useQuery<Task[]>({
    queryKey: ["/api/v1/auto-generated-tasks"],
    refetchOnWindowFocus: false,
  });
  
  // Fetch clients for lookup
  const { data: clients = [] } = useQuery<Client[]>({
    queryKey: ["/api/v1/clients"],
    enabled: autoGeneratedTasks.length > 0,
  });
  
  // Fetch service types for lookup
  const { data: serviceTypes = [] } = useQuery<ServiceType[]>({
    queryKey: ["/api/v1/setup/service-types"],
    enabled: autoGeneratedTasks.length > 0,
  });
  
  // Fetch all entities for client lookup
  const { data: entities = [] } = useQuery<Entity[]>({
    queryKey: ["/api/v1/entities"],
    enabled: autoGeneratedTasks.length > 0,
  });
  
  // Approve task mutation
  const approveMutation = useMutation({
    mutationFn: async (taskId: number) => {
      const response = await apiRequest(
        "POST", 
        `/api/v1/auto-generated-tasks/${taskId}/approve`
      );
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/v1/auto-generated-tasks"] });
      queryClient.invalidateQueries({ queryKey: ["/api/v1/tasks"] });
      toast({
        title: "Task approved",
        description: "The task has been approved and added to your task list.",
      });
    },
    onError: (error: any) => {
      toast({
        title: "Error",
        description: error.message || "Failed to approve task",
        variant: "destructive",
      });
    },
  });
  
  // Reject task mutation
  const rejectMutation = useMutation({
    mutationFn: async (taskId: number) => {
      const response = await apiRequest(
        "POST", 
        `/api/v1/auto-generated-tasks/${taskId}/reject`
      );
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/v1/auto-generated-tasks"] });
      toast({
        title: "Task rejected",
        description: "The task has been rejected and will not be added to your task list.",
      });
    },
    onError: (error: any) => {
      toast({
        title: "Error",
        description: error.message || "Failed to reject task",
        variant: "destructive",
      });
    },
  });
  
  // Approve all tasks mutation
  const approveAllMutation = useMutation({
    mutationFn: async () => {
      const response = await apiRequest(
        "POST", 
        "/api/v1/auto-generated-tasks/approve-all"
      );
      return response.json();
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["/api/v1/auto-generated-tasks"] });
      queryClient.invalidateQueries({ queryKey: ["/api/v1/tasks"] });
      toast({
        title: "All tasks approved",
        description: data.message || "All tasks have been approved and added to your task list.",
      });
    },
    onError: (error: any) => {
      toast({
        title: "Error",
        description: error.message || "Failed to approve all tasks",
        variant: "destructive",
      });
    },
  });
  
  // Manually generate tasks mutation
  const generateTasksMutation = useMutation({
    mutationFn: async () => {
      const response = await apiRequest(
        "POST", 
        "/api/v1/admin/generate-recurring-tasks",
        { tenantId: user?.tenantId }
      );
      return response.json();
    },
    onSuccess: (data) => {
      refetch();
      toast({
        title: "Tasks generated",
        description: data.message || "Recurring tasks have been generated successfully.",
      });
    },
    onError: (error: any) => {
      toast({
        title: "Error",
        description: error.message || "Failed to generate tasks",
        variant: "destructive",
      });
    },
  });
  
  // Activate task mutation
  const activateTaskMutation = useMutation({
    mutationFn: async (taskId: number) => {
      const response = await apiRequest(
        "POST", 
        `/api/v1/tasks/${taskId}/activate`
      );
      return response.json();
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["/api/v1/tasks"] });
      queryClient.invalidateQueries({ queryKey: ["/api/v1/auto-generated-tasks"] });
      setShowTaskDialog(false);
      toast({
        title: "Task activated",
        description: data.message || "Task has been set to active status.",
      });
    },
    onError: (error: any) => {
      toast({
        title: "Error",
        description: error.message || "Failed to activate task",
        variant: "destructive",
      });
    },
  });
  
  // Cancel task mutation
  const cancelTaskMutation = useMutation({
    mutationFn: async (taskId: number) => {
      const response = await apiRequest(
        "POST", 
        `/api/v1/tasks/${taskId}/cancel`
      );
      return response.json();
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["/api/v1/tasks"] });
      queryClient.invalidateQueries({ queryKey: ["/api/v1/auto-generated-tasks"] });
      setShowTaskDialog(false);
      toast({
        title: "Task canceled",
        description: data.message || "Task has been canceled successfully.",
      });
    },
    onError: (error: any) => {
      toast({
        title: "Error",
        description: error.message || "Failed to cancel task",
        variant: "destructive",
      });
    },
  });
  
  // Resume task mutation
  const resumeTaskMutation = useMutation({
    mutationFn: async (taskId: number) => {
      const response = await apiRequest(
        "POST", 
        `/api/v1/tasks/${taskId}/resume`
      );
      return response.json();
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["/api/v1/tasks"] });
      queryClient.invalidateQueries({ queryKey: ["/api/v1/auto-generated-tasks"] });
      setShowTaskDialog(false);
      toast({
        title: "Task resumed",
        description: data.message || "Canceled task has been resumed successfully.",
      });
    },
    onError: (error: any) => {
      toast({
        title: "Error",
        description: error.message || "Failed to resume task",
        variant: "destructive",
      });
    },
  });
  
  // Delete task mutation
  const deleteTaskMutation = useMutation({
    mutationFn: async (taskId: number) => {
      const response = await apiRequest(
        "DELETE", 
        `/api/v1/tasks/${taskId}`
      );
      return response.json();
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["/api/v1/tasks"] });
      queryClient.invalidateQueries({ queryKey: ["/api/v1/auto-generated-tasks"] });
      setShowTaskDialog(false);
      toast({
        title: "Task deleted",
        description: data.message || "Task has been permanently deleted.",
      });
    },
    onError: (error: any) => {
      toast({
        title: "Error",
        description: error.message || "Failed to delete task",
        variant: "destructive",
      });
    },
  });
  
  // Handle view task details
  const handleViewTask = (task: Task) => {
    setSelectedTask(task);
    setShowTaskDialog(true);
  };
  
  // Handle approve task
  const handleApproveTask = (task: Task) => {
    approveMutation.mutate(task.id);
  };
  
  // Handle reject task
  const handleRejectTask = (task: Task) => {
    rejectMutation.mutate(task.id);
  };
  
  // Handle approve all tasks
  const handleApproveAllTasks = () => {
    if (autoGeneratedTasks.length > 0) {
      approveAllMutation.mutate();
    }
  };
  
  // Handle generate tasks
  const handleGenerateTasks = () => {
    generateTasksMutation.mutate();
  };
  
  // Handle activate task
  const handleActivateTask = (task: Task) => {
    activateTaskMutation.mutate(task.id);
  };
  
  // Handle cancel task
  const handleCancelTask = (task: Task) => {
    cancelTaskMutation.mutate(task.id);
  };
  
  // Handle resume task
  const handleResumeTask = (task: Task) => {
    resumeTaskMutation.mutate(task.id);
  };
  
  // Handle delete task
  const handleDeleteTask = (task: Task) => {
    if (window.confirm(`Are you sure you want to permanently delete this task?\nThis action cannot be undone.`)) {
      deleteTaskMutation.mutate(task.id);
    }
  };
  
  // Get client name for a task
  const getClientName = (clientId?: number) => {
    if (!clientId) return "N/A";
    const client = clients.find(c => c.id === clientId);
    return client ? client.displayName : "Unknown Client";
  };
  
  // Get entity name for a task
  const getEntityName = (entityId?: number) => {
    if (!entityId) return "N/A";
    const entity = entities.find(e => e.id === entityId);
    return entity ? entity.name : "Unknown Entity";
  };
  
  // Get service name for a task
  const getServiceName = (serviceTypeId?: number) => {
    if (!serviceTypeId) return "N/A";
    const service = serviceTypes.find(s => s.id === serviceTypeId);
    return service ? service.name : "Unknown Service";
  };

  // Format task date based on frequency
  const formatTaskPeriod = (task: Task) => {
    if (!task.complianceStartDate || !task.complianceEndDate) return "N/A";
    
    const startDate = new Date(task.complianceStartDate);
    const endDate = new Date(task.complianceEndDate);
    
    const frequency = task.complianceFrequency?.toLowerCase();
    
    if (frequency === "monthly") {
      return format(startDate, "MMMM yyyy");
    } else if (frequency === "quarterly") {
      const quarter = Math.floor(startDate.getMonth() / 3) + 1;
      return `Q${quarter} ${startDate.getFullYear()}`;
    } else if (frequency === "annual" || frequency === "yearly") {
      return `${startDate.getFullYear()}`;
    } else {
      return `${format(startDate, "MMM d, yyyy")} - ${format(endDate, "MMM d, yyyy")}`;
    }
  };
  
  return (
    <div className="space-y-6">
      {/* Header with actions */}
      <div className="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4">
        <div>
          <h1 className="text-xl font-semibold">Auto Generated Tasks</h1>
          <p className="text-sm text-muted-foreground">
            Review and approve recurring tasks generated by the system
          </p>
        </div>
        
        <div className="flex gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={handleGenerateTasks}
            disabled={generateTasksMutation.isPending}
          >
            {generateTasksMutation.isPending ? (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            ) : (
              <RefreshCw className="h-4 w-4 mr-2" />
            )}
            Generate Tasks
          </Button>
          
          <Button
            size="sm"
            onClick={handleApproveAllTasks}
            disabled={approveAllMutation.isPending || autoGeneratedTasks.length === 0}
          >
            {approveAllMutation.isPending ? (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            ) : (
              <CheckCircle className="h-4 w-4 mr-2" />
            )}
            Approve All
          </Button>
        </div>
      </div>
      
      {/* Tasks table */}
      {isLoading ? (
        <div className="space-y-4">
          <Skeleton className="h-8 w-full" />
          <Skeleton className="h-12 w-full" />
          <Skeleton className="h-12 w-full" />
          <Skeleton className="h-12 w-full" />
        </div>
      ) : autoGeneratedTasks.length === 0 ? (
        <Card>
          <CardContent className="pt-6 flex flex-col items-center justify-center h-48">
            <CalendarDays className="h-12 w-12 text-muted-foreground mb-4" />
            <p className="text-lg font-medium mb-2">No tasks to approve</p>
            <p className="text-sm text-muted-foreground text-center max-w-md mb-4">
              There are no auto-generated tasks waiting for your approval.
              You can manually trigger task generation or wait for the scheduled generation.
            </p>
            <Button
              variant="outline"
              onClick={handleGenerateTasks}
              disabled={generateTasksMutation.isPending}
            >
              {generateTasksMutation.isPending ? (
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
              ) : (
                <RefreshCw className="h-4 w-4 mr-2" />
              )}
              Generate Tasks Now
            </Button>
          </CardContent>
        </Card>
      ) : (
        <Card>
          <CardHeader className="pb-1">
            <CardTitle className="text-lg">Pending Tasks</CardTitle>
            <CardDescription>
              {autoGeneratedTasks.length} task{autoGeneratedTasks.length !== 1 && 's'} awaiting your approval
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Task Details</TableHead>
                  <TableHead>Client / Entity</TableHead>
                  <TableHead>Service</TableHead>
                  <TableHead>Compliance Period</TableHead>
                  <TableHead>Due Date</TableHead>
                  <TableHead className="text-right">Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {autoGeneratedTasks.map((task) => (
                  <TableRow key={task.id} className="cursor-pointer hover:bg-muted/50" onClick={() => handleViewTask(task)}>
                    <TableCell className="font-medium">
                      {task.taskDetails || `Task #${task.id}`}
                    </TableCell>
                    <TableCell>
                      {task.clientId ? (
                        <div>
                          <div>{getClientName(task.clientId)}</div>
                          {task.entityId && (
                            <div className="text-xs text-muted-foreground flex items-center">
                              <MoveRight className="h-3 w-3 mr-1" />
                              {getEntityName(task.entityId)}
                            </div>
                          )}
                        </div>
                      ) : (
                        "N/A"
                      )}
                    </TableCell>
                    <TableCell>
                      {task.serviceTypeId ? (
                        getServiceName(task.serviceTypeId)
                      ) : (
                        "N/A"
                      )}
                    </TableCell>
                    <TableCell>
                      <div className="flex items-center">
                        <Calendar className="h-4 w-4 mr-1 text-muted-foreground" />
                        <span>{formatTaskPeriod(task)}</span>
                      </div>
                    </TableCell>
                    <TableCell>
                      <div className="flex items-center">
                        <Clock className="h-4 w-4 mr-1 text-muted-foreground" />
                        <span>{format(new Date(task.dueDate), "MMM d, yyyy")}</span>
                      </div>
                    </TableCell>
                    <TableCell className="text-right">
                      <div className="flex justify-end gap-2" onClick={(e) => e.stopPropagation()}>
                        <TooltipProvider>
                          <Tooltip>
                            <TooltipTrigger asChild>
                              <Button
                                variant="ghost"
                                size="icon"
                                onClick={() => handleRejectTask(task)}
                                disabled={rejectMutation.isPending}
                              >
                                <XCircle className="h-4 w-4 text-destructive" />
                              </Button>
                            </TooltipTrigger>
                            <TooltipContent>
                              <p>Reject Task</p>
                            </TooltipContent>
                          </Tooltip>
                        </TooltipProvider>
                        
                        <TooltipProvider>
                          <Tooltip>
                            <TooltipTrigger asChild>
                              <Button
                                variant="ghost"
                                size="icon"
                                onClick={() => handleApproveTask(task)}
                                disabled={approveMutation.isPending}
                              >
                                <CheckCircle className="h-4 w-4 text-success" />
                              </Button>
                            </TooltipTrigger>
                            <TooltipContent>
                              <p>Approve Task</p>
                            </TooltipContent>
                          </Tooltip>
                        </TooltipProvider>
                      </div>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </CardContent>
          <CardFooter className="flex justify-between border-t pt-4">
            <div className="text-sm text-muted-foreground">
              Showing {autoGeneratedTasks.length} pending task{autoGeneratedTasks.length !== 1 && 's'}
            </div>
            <Button
              variant="outline"
              size="sm"
              onClick={handleApproveAllTasks}
              disabled={approveAllMutation.isPending}
            >
              {approveAllMutation.isPending ? (
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
              ) : (
                <CheckCircle className="h-4 w-4 mr-2" />
              )}
              Approve All
            </Button>
          </CardFooter>
        </Card>
      )}
      
      {/* Task details dialog */}
      {selectedTask && (
        <Dialog open={showTaskDialog} onOpenChange={setShowTaskDialog}>
          <DialogContent className="sm:max-w-md">
            <DialogHeader>
              <DialogTitle>Task Details</DialogTitle>
              <DialogDescription>
                Review the auto-generated task details before approving
              </DialogDescription>
            </DialogHeader>
            
            <div className="space-y-4 py-4">
              <div className="space-y-1">
                <h4 className="text-sm font-medium text-muted-foreground">Description</h4>
                <p className="text-sm">{selectedTask.taskDetails || "No description provided"}</p>
              </div>
              
              {selectedTask.clientId && (
                <div className="space-y-1">
                  <h4 className="text-sm font-medium text-muted-foreground">Client</h4>
                  <p className="text-sm">{getClientName(selectedTask.clientId)}</p>
                </div>
              )}
              
              {selectedTask.entityId && (
                <div className="space-y-1">
                  <h4 className="text-sm font-medium text-muted-foreground">Entity</h4>
                  <p className="text-sm">{getEntityName(selectedTask.entityId)}</p>
                </div>
              )}
              
              {selectedTask.serviceTypeId && (
                <div className="space-y-1">
                  <h4 className="text-sm font-medium text-muted-foreground">Service</h4>
                  <p className="text-sm">{getServiceName(selectedTask.serviceTypeId)}</p>
                </div>
              )}
              
              <div className="space-y-1">
                <h4 className="text-sm font-medium text-muted-foreground">Compliance Details</h4>
                <div className="grid grid-cols-2 gap-2">
                  <div>
                    <p className="text-xs text-muted-foreground">Frequency</p>
                    <p className="text-sm">{selectedTask.complianceFrequency || "N/A"}</p>
                  </div>
                  <div>
                    <p className="text-xs text-muted-foreground">Period</p>
                    <p className="text-sm">{formatTaskPeriod(selectedTask)}</p>
                  </div>
                  <div>
                    <p className="text-xs text-muted-foreground">Due Date</p>
                    <p className="text-sm">{format(new Date(selectedTask.dueDate), "MMM d, yyyy")}</p>
                  </div>
                </div>
              </div>
              
              {/* Status Information */}
              <div className="space-y-1">
                <h4 className="text-sm font-medium text-muted-foreground">Status Information</h4>
                <div className="grid grid-cols-2 gap-2">
                  <div>
                    <p className="text-xs text-muted-foreground">Active</p>
                    <p className="text-sm">{selectedTask.activatedAt ? "Yes" : "No"}</p>
                  </div>
                  <div>
                    <p className="text-xs text-muted-foreground">Activated On</p>
                    <p className="text-sm">{selectedTask.activatedAt ? format(new Date(selectedTask.activatedAt), "MMM d, yyyy") : "Not activated"}</p>
                  </div>
                  <div>
                    <p className="text-xs text-muted-foreground">Canceled</p>
                    <p className="text-sm">{selectedTask.isCanceled ? "Yes" : "No"}</p>
                  </div>
                  {selectedTask.canceledAt && (
                    <div>
                      <p className="text-xs text-muted-foreground">Canceled On</p>
                      <p className="text-sm">{format(new Date(selectedTask.canceledAt), "MMM d, yyyy")}</p>
                    </div>
                  )}
                </div>
              </div>
              
              {/* Task Management Buttons */}
              <div className="space-y-2 pt-2">
                <h4 className="text-sm font-medium text-muted-foreground mb-2">Task Management</h4>
                <div className="flex flex-wrap gap-2">
                  {!selectedTask.activatedAt && !selectedTask.isCanceled && (
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={() => handleActivateTask(selectedTask)}
                      disabled={activateTaskMutation.isPending}
                    >
                      {activateTaskMutation.isPending ? (
                        <Loader2 className="h-4 w-4 mr-1 animate-spin" />
                      ) : (
                        <Play className="h-4 w-4 mr-1" />
                      )}
                      Set to Active
                    </Button>
                  )}
                  
                  {!selectedTask.isCanceled && (
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={() => handleCancelTask(selectedTask)}
                      disabled={cancelTaskMutation.isPending}
                    >
                      {cancelTaskMutation.isPending ? (
                        <Loader2 className="h-4 w-4 mr-1 animate-spin" />
                      ) : (
                        <Ban className="h-4 w-4 mr-1" />
                      )}
                      Cancel Task
                    </Button>
                  )}
                  
                  {selectedTask.isCanceled && (
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={() => handleResumeTask(selectedTask)}
                      disabled={resumeTaskMutation.isPending}
                    >
                      {resumeTaskMutation.isPending ? (
                        <Loader2 className="h-4 w-4 mr-1 animate-spin" />
                      ) : (
                        <RotateCcw className="h-4 w-4 mr-1" />
                      )}
                      Resume Task
                    </Button>
                  )}
                  
                  <Button 
                    variant="destructive" 
                    size="sm"
                    onClick={() => handleDeleteTask(selectedTask)}
                    disabled={deleteTaskMutation.isPending}
                  >
                    {deleteTaskMutation.isPending ? (
                      <Loader2 className="h-4 w-4 mr-1 animate-spin" />
                    ) : (
                      <Trash2 className="h-4 w-4 mr-1" />
                    )}
                    Delete
                  </Button>
                </div>
              </div>
            </div>
            
            <DialogFooter className="gap-2 sm:gap-0">
              {selectedTask.needsApproval && (
                <>
                  <Button
                    variant="outline"
                    onClick={() => handleRejectTask(selectedTask)}
                    disabled={rejectMutation.isPending}
                  >
                    {rejectMutation.isPending ? (
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                    ) : (
                      <XCircle className="h-4 w-4 mr-2" />
                    )}
                    Reject
                  </Button>
                  <Button
                    onClick={() => handleApproveTask(selectedTask)}
                    disabled={approveMutation.isPending}
                  >
                    {approveMutation.isPending ? (
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                    ) : (
                      <CheckCircle className="h-4 w-4 mr-2" />
                    )}
                    Approve
                  </Button>
                </>
              )}
              {!selectedTask.needsApproval && (
                <Button
                  onClick={() => setShowTaskDialog(false)}
                >
                  Close
                </Button>
              )}
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}
    </div>
  );
}